<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORCA Output Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            gap: 15px;
            align-items: center;
        }

        button {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .status {
            flex: 1;
            text-align: right;
            color: #666;
            font-size: 14px;
        }

        .status.success {
            color: #28a745;
            font-weight: 600;
        }

        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e0e0e0;
            overflow-x: auto;
        }

        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background: transparent;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }

        .tab:hover {
            background: #e9ecef;
            color: #333;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: white;
        }

        .tab-content {
            display: none;
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .card h3 {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card .value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .card .label {
            font-size: 0.85em;
            opacity: 0.8;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
        }

        tbody tr:nth-child(even) {
            background: #f8f9fa;
        }

        tbody tr:hover {
            background: #e9ecef;
        }

        .section-title {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .info-box {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .info-box h4 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .progress {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            transition: width 0.5s;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .json-viewer {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            max-height: 600px;
            overflow-y: auto;
        }

        .molecular-structure {
            text-align: center;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 20px 0;
        }

        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* File upload styles */
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9fa;
        }

        .upload-area:hover {
            border-color: #5568d3;
            background: #e7f1ff;
        }

        .upload-area.dragover {
            border-color: #5568d3;
            background: #e7f1ff;
            transform: scale(1.02);
        }

        input[type="file"] {
            display: none;
        }

        /* Visualization container */
        .viz-container {
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #molecule-viewer {
            width: 100%;
            height: 500px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
        }

        /* Collapsible sections */
        .collapsible {
            cursor: pointer;
            padding: 15px;
            background: #f8f9fa;
            border: none;
            text-align: left;
            width: 100%;
            font-size: 16px;
            font-weight: 600;
            border-radius: 6px;
            margin-top: 10px;
            transition: all 0.3s;
        }

        .collapsible:hover {
            background: #e7f1ff;
        }

        .collapsible.active {
            background: #667eea;
            color: white;
        }

        .collapsible:after {
            content: '\002B';  /* + symbol */
            float: right;
            font-weight: bold;
        }

        .collapsible.active:after {
            content: "\2212";  /* - symbol */
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: white;
        }

        .collapsible-content.active {
            max-height: 2000px;
            padding: 15px;
        }

        /* Export buttons */
        .export-buttons {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .btn-export {
            padding: 8px 16px;
            font-size: 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-export:hover {
            background: #218838;
        }
    </style>

    <!-- 3Dmol.js for 3D molecular visualization -->
    <script src="https://3Dmol.csb.pitt.edu/build/3Dmol-min.js"></script>

    <!-- Plotly.js for interactive charts -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß™ ORCA Output Viewer</h1>
            <p>Comprehensive Quantum Chemistry Data Visualization</p>
            <p style="margin-top: 10px; font-size: 0.9em;">38/57 sections parsed (67% coverage) | 53 Interactive Visualizations</p>
        </header>

        <div class="controls">
            <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                <input type="file" id="fileInput" accept=".out,.txt" onchange="uploadFile(event)">
                <p>üì§ <strong>Upload ORCA Output File</strong></p>
                <p style="font-size: 12px; margin-top: 5px;">Drag & drop or click to browse (.out, .txt)</p>
            </div>
            <div style="display: flex; gap: 10px; flex: 1; align-items: center;">
                <button class="btn-primary" onclick="loadDefaultData()">üìÇ Load Example</button>
                <button class="btn-secondary" onclick="exportJSON()">üíæ Export JSON</button>
                <div class="status" id="status">Upload a file or load example data</div>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="showTab('summary')">üìä Summary</button>
            <button class="tab" onclick="showTab('molecule')">üî¨ 3D Molecule</button>
            <button class="tab" onclick="showTab('plots')">üìà Interactive Plots</button>
            <button class="tab" onclick="showTab('geometry')">üìç Geometry</button>
            <button class="tab" onclick="showTab('energy')">‚ö° Energy</button>
            <button class="tab" onclick="showTab('orbitals')">üåÄ Orbitals</button>
            <button class="tab" onclick="showTab('vibrations')">üéµ Vibrations</button>
            <button class="tab" onclick="showTab('nmr')">üß≤ NMR</button>
            <button class="tab" onclick="showTab('population')">üë• Population</button>
            <button class="tab" onclick="showTab('raw')">üìÑ Raw JSON</button>
        </div>

        <!-- Summary Tab -->
        <div id="summary" class="tab-content active">
            <h2 class="section-title">Summary Overview</h2>
            <div id="summary-content">
                <p class="loading">Click "Load Data" to parse ORCA output file</p>
            </div>
        </div>

        <!-- 3D Molecule Tab -->
        <div id="molecule" class="tab-content">
            <h2 class="section-title">üî¨ 3D Molecular Structure</h2>
            <div class="viz-container">
                <div id="molecule-viewer"></div>
                <div style="margin-top: 15px;">
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                        <strong>Style:</strong>
                        <button class="btn-secondary" onclick="setMoleculeStyle('stick')">Stick</button>
                        <button class="btn-secondary" onclick="setMoleculeStyle('sphere')">Sphere</button>
                        <button class="btn-secondary" onclick="setMoleculeStyle('cartoon')">Ball & Stick</button>
                        <button class="btn-secondary" onclick="toggleLabels()">Labels</button>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                        <strong>Color By:</strong>
                        <button class="btn-secondary" onclick="setChargeColoring('none')">Element</button>
                        <button class="btn-secondary" onclick="setChargeColoring('mulliken')">Mulliken Charge</button>
                        <button class="btn-secondary" onclick="setChargeColoring('loewdin')">Loewdin Charge</button>
                        <button class="btn-secondary" onclick="toggleDipole()">Dipole Vector</button>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn-secondary" onclick="toggleBondOrders()">Show Bond Orders</button>
                        <button class="btn-export" onclick="exportMoleculeImage()">üì∑ Export PNG</button>
                    </div>
                    <div id="charge-legend" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 6px; display: none;">
                        <strong>Charge Scale:</strong>
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                            <span style="color: red;">‚àí1.0 (negative)</span>
                            <div style="flex: 1; height: 20px; background: linear-gradient(to right, red, white, blue); border-radius: 4px;"></div>
                            <span style="color: blue;">+1.0 (positive)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Interactive Plots Tab -->
        <div id="plots" class="tab-content">
            <h2 class="section-title">üìà Interactive Data Visualization</h2>

            <button class="collapsible" onclick="toggleCollapsible(this)">SCF Convergence Plot</button>
            <div class="collapsible-content">
                <div id="scf-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('scf-plot', 'scf_convergence.png')">üì∑ PNG</button>
                    <button class="btn-export" onclick="exportPlot('scf-plot', 'scf_convergence.svg')">üìÑ SVG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">IR Spectrum</button>
            <div class="collapsible-content">
                <div id="ir-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('ir-plot', 'ir_spectrum.png')">üì∑ PNG</button>
                    <button class="btn-export" onclick="exportPlot('ir-plot', 'ir_spectrum.svg')">üìÑ SVG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Raman Spectrum</button>
            <div class="collapsible-content">
                <div id="raman-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('raman-plot', 'raman_spectrum.png')">üì∑ PNG</button>
                    <button class="btn-export" onclick="exportPlot('raman-plot', 'raman_spectrum.svg')">üìÑ SVG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Thermochemistry Energy Diagram</button>
            <div class="collapsible-content">
                <div id="thermo-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('thermo-plot', 'thermochemistry.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Energy Diagram</button>
            <div class="collapsible-content">
                <div id="orbital-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('orbital-plot', 'orbital_energies.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">NMR Spectrum</button>
            <div class="collapsible-content">
                <div id="nmr-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('nmr-plot', 'nmr_spectrum.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">IR + Raman Overlay ‚ú®</button>
            <div class="collapsible-content">
                <div id="combined-spectrum-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('combined-spectrum-plot', 'ir_raman_combined.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Computation Timing Breakdown ‚è±Ô∏è</button>
            <div class="collapsible-content">
                <div id="timing-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('timing-plot', 'timing_breakdown.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">SCF Convergence Details üî¨</button>
            <div class="collapsible-content">
                <div id="scf-details-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('scf-details-plot', 'scf_details.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Multi-line plot showing energy convergence, density change, and DIIS error
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Basis Set Composition üìö</button>
            <div class="collapsible-content">
                <div id="basis-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('basis-plot', 'basis_composition.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">DFT Grid Statistics üéØ</button>
            <div class="collapsible-content">
                <div id="grid-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('grid-plot', 'grid_statistics.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Geometry Optimization Trajectory üé¨</button>
            <div class="collapsible-content">
                <div id="opt-trajectory-plot" style="width: 100%; height: 500px;"></div>
                <div style="margin: 15px 0;">
                    <label for="opt-slider"><strong>Geometry Step:</strong> <span id="opt-step-label">1</span></label>
                    <input type="range" id="opt-slider" min="0" max="0" value="0" style="width: 100%;" oninput="updateOptStep(this.value)">
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="btn-secondary" onclick="playOptAnimation()">‚ñ∂Ô∏è Play</button>
                        <button class="btn-secondary" onclick="pauseOptAnimation()">‚è∏Ô∏è Pause</button>
                        <button class="btn-secondary" onclick="resetOptAnimation()">‚èÆÔ∏è Reset</button>
                    </div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('opt-trajectory-plot', 'optimization_trajectory.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Energy vs optimization step. Use slider to view geometry at each step.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Vibrational Mode Animation üéµ</button>
            <div class="collapsible-content">
                <div style="margin-bottom: 15px;">
                    <label for="mode-selector"><strong>Select Vibrational Mode:</strong></label>
                    <select id="mode-selector" onchange="selectVibrationalMode(this.value)" style="width: 100%; padding: 8px; margin-top: 5px;">
                        <option value="">-- Select Mode --</option>
                    </select>
                </div>
                <div id="vib-mode-info" style="padding: 10px; background: #f8f9fa; border-radius: 4px; margin-bottom: 10px; display: none;">
                    <p><strong>Frequency:</strong> <span id="vib-frequency">--</span> cm‚Åª¬π</p>
                    <p><strong>IR Intensity:</strong> <span id="vib-ir-intensity">--</span> km/mol</p>
                    <p><strong>Raman Activity:</strong> <span id="vib-raman-activity">--</span></p>
                </div>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button class="btn-secondary" onclick="playVibAnimation()">‚ñ∂Ô∏è Animate</button>
                    <button class="btn-secondary" onclick="pauseVibAnimation()">‚è∏Ô∏è Pause</button>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <strong>Amplitude:</strong>
                        <input type="range" id="vib-amplitude" min="0.1" max="2.0" step="0.1" value="1.0" style="width: 100px;" oninput="updateVibAmplitude(this.value)">
                        <span id="vib-amp-label">1.0</span>
                    </label>
                </div>
                <p style="font-size: 12px; color: #666;">
                    Select a mode to see atomic displacements. Animation shows normal mode vibration.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Charge Heatmap üå°Ô∏è</button>
            <div class="collapsible-content">
                <div id="orbital-heatmap-plot" style="width: 100%; height: 600px;"></div>
                <div style="display: flex; gap: 10px; margin: 15px 0;">
                    <button class="btn-secondary" onclick="zoomToHOMOLUMO()">üîç Zoom to HOMO-LUMO</button>
                    <button class="btn-secondary" onclick="resetHeatmapZoom()">üîÑ Reset Zoom</button>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <strong>Charge Type:</strong>
                        <select id="heatmap-charge-type" onchange="updateHeatmapChargeType(this.value)">
                            <option value="mulliken">Mulliken</option>
                            <option value="loewdin">Loewdin</option>
                        </select>
                    </label>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('orbital-heatmap-plot', 'orbital_charges_heatmap.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    2D heatmap showing charge contribution of each MO on each atom. Click to highlight.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">NMR J-Coupling Network üîó</button>
            <div class="collapsible-content">
                <div id="jcoupling-network-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('jcoupling-network-plot', 'jcoupling_network.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Network graph showing J-coupling between nuclei. Edge thickness represents coupling strength.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Chemical Shielding Tensors üìä</button>
            <div class="collapsible-content">
                <div id="shielding-tensors-table"></div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Full chemical shielding tensor data for all nuclei. Click rows to expand tensor details.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">HOMO-LUMO Gap Tracker üìâ</button>
            <div class="collapsible-content">
                <div id="homo-lumo-gap-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('homo-lumo-gap-plot', 'homo_lumo_gap.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    HOMO-LUMO energy gap evolution during geometry optimization.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Density of States üìä</button>
            <div class="collapsible-content">
                <div id="dos-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('dos-plot', 'density_of_states.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Density of states with Gaussian broadening. Blue = occupied, Red = virtual.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Mulliken Overlap Network üï∏Ô∏è</button>
            <div class="collapsible-content">
                <div id="overlap-network-plot" style="width: 100%; height: 600px;"></div>
                <div style="display: flex; gap: 10px; margin: 15px 0;">
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <strong>Layout:</strong>
                        <select id="overlap-layout" onchange="updateOverlapLayout(this.value)">
                            <option value="circular">Circular</option>
                            <option value="3d">3D Molecular</option>
                        </select>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <strong>Min Overlap:</strong>
                        <input type="range" id="overlap-threshold" min="0" max="5" step="0.5" value="1.0" style="width: 100px;" oninput="updateOverlapThreshold(this.value)">
                        <span id="overlap-threshold-label">1.0</span>
                    </label>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('overlap-network-plot', 'overlap_network.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Network showing Mulliken overlap charges between atom pairs. Edge thickness = |overlap charge|.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Polarizability Visualization üéØ</button>
            <div class="collapsible-content">
                <div id="polarizability-plot" style="width: 100%; height: 400px;"></div>
                <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <h4 style="margin-top: 0;">Polarizability Tensor</h4>
                    <div id="polarizability-tensor-display"></div>
                    <h4 style="margin-top: 15px;">Eigenvalues (Principal Components)</h4>
                    <div id="polarizability-eigenvalues"></div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('polarizability-plot', 'polarizability.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Static polarizability tensor components and eigenvalues. Bar chart shows anisotropy.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Bond Order Comparison ‚öñÔ∏è</button>
            <div class="collapsible-content">
                <div id="bond-order-comparison-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('bond-order-comparison-plot', 'bond_order_comparison.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Side-by-side comparison of Mayer and Loewdin bond orders. Shows correlation between methods.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Charge Analysis Comparison üìä</button>
            <div class="collapsible-content">
                <div id="charge-comparison-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('charge-comparison-plot', 'charge_comparison.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Mulliken vs Loewdin atomic charges scatter plot. Points on diagonal indicate agreement.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Energy Components Breakdown ‚ö°</button>
            <div class="collapsible-content">
                <div id="energy-components-plot" style="width: 100%; height: 400px;"></div>
                <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <div id="energy-components-details"></div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('energy-components-plot', 'energy_components.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Breakdown of total energy into nuclear, electronic, kinetic, and exchange-correlation components.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Dispersion Correction (DFTD3) üåä</button>
            <div class="collapsible-content">
                <div id="dispersion-plot" style="width: 100%; height: 300px;"></div>
                <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <div id="dispersion-details"></div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('dispersion-plot', 'dispersion.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    DFTD3 dispersion correction showing E6 and E8 contributions.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Population by Element üß™</button>
            <div class="collapsible-content">
                <div id="orbital-population-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('orbital-population-plot', 'orbital_population.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Mulliken orbital population (s, p, d, f, g) breakdown by atom. Stacked bars show orbital character.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Internal Coordinates Distribution üìê</button>
            <div class="collapsible-content">
                <div id="internal-coords-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('internal-coords-plot', 'internal_coordinates.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Distribution of bond lengths and angles in the molecular structure.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">SCF Iteration Efficiency üìâ</button>
            <div class="collapsible-content">
                <div id="scf-efficiency-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('scf-efficiency-plot', 'scf_efficiency.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Energy reduction per SCF iteration. Shows convergence rate and efficiency.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">CPCM Solvation Analysis üíß</button>
            <div class="collapsible-content">
                <div id="solvation-plot" style="width: 100%; height: 400px;"></div>
                <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <div id="solvation-details"></div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('solvation-plot', 'solvation.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    CPCM solvation energy components: electrostatic, cavitation, dispersion, repulsion.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Energy Distribution üìä</button>
            <div class="collapsible-content">
                <div id="orbital-distribution-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('orbital-distribution-plot', 'orbital_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Histogram of orbital energies showing distribution across energy range.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Frequency Analysis by Type üéº</button>
            <div class="collapsible-content">
                <div id="frequency-analysis-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('frequency-analysis-plot', 'frequency_analysis.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Vibrational frequencies categorized by energy range with IR/Raman activity overlay.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Charge Distribution Analysis ü•ß</button>
            <div class="collapsible-content">
                <div id="charge-distribution-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('charge-distribution-plot', 'charge_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Pie chart showing distribution of positive, neutral, and negative charges across atoms.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Bond Order vs Length Correlation üìà</button>
            <div class="collapsible-content">
                <div id="bond-correlation-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('bond-correlation-plot', 'bond_correlation.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Scatter plot showing relationship between bond length and bond order (Mayer).
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Eigenvalue Spectrum üåà</button>
            <div class="collapsible-content">
                <div id="eigenvalue-spectrum-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('eigenvalue-spectrum-plot', 'eigenvalue_spectrum.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    All orbital energies displayed as horizontal bars with HOMO-LUMO gap highlighted.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">IR vs Raman Activity Correlation üî¨</button>
            <div class="collapsible-content">
                <div id="ir-raman-correlation-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('ir-raman-correlation-plot', 'ir_raman_correlation.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Scatter plot comparing IR intensity vs Raman activity for each vibrational mode.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Atomic Mass Distribution üìä</button>
            <div class="collapsible-content">
                <div id="mass-distribution-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('mass-distribution-plot', 'mass_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Bar chart showing atomic mass contribution by element type.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Dipole Moment Components üß≤</button>
            <div class="collapsible-content">
                <div id="dipole-components-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('dipole-components-plot', 'dipole_components.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    3D bar chart showing dipole moment x, y, z components and total magnitude.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Thermochemistry Breakdown üå°Ô∏è</button>
            <div class="collapsible-content">
                <div id="thermo-breakdown-plot" style="width: 100%; height: 400px;"></div>
                <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <div id="thermo-breakdown-details"></div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('thermo-breakdown-plot', 'thermo_breakdown.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Detailed breakdown of thermochemical corrections: ZPE, thermal, enthalpy, entropy contributions.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Atom Type Statistics üìà</button>
            <div class="collapsible-content">
                <div id="atom-stats-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('atom-stats-plot', 'atom_statistics.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Count and percentage of each element type in the molecule.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Bond Angle Distribution üìê</button>
            <div class="collapsible-content">
                <div id="angle-distribution-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('angle-distribution-plot', 'angle_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Histogram showing distribution of bond angles with statistics.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Element Composition ü•ß</button>
            <div class="collapsible-content">
                <div id="element-composition-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('element-composition-plot', 'element_composition.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Pie chart showing molecular composition by element count.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Optimization Convergence Metrics üìâ</button>
            <div class="collapsible-content">
                <div id="opt-convergence-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('opt-convergence-plot', 'opt_convergence.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Energy change per optimization step showing convergence rate.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Mulliken Population Correlation üî¨</button>
            <div class="collapsible-content">
                <div id="population-correlation-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('population-correlation-plot', 'population_correlation.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Scatter matrix showing correlations between s, p, d orbital populations.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Interatomic Distance Analysis üìè</button>
            <div class="collapsible-content">
                <div id="distance-analysis-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('distance-analysis-plot', 'distance_analysis.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Histogram of all pairwise interatomic distances.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Coordination Number Analysis üîó</button>
            <div class="collapsible-content">
                <div id="coordination-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('coordination-plot', 'coordination_numbers.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Coordination number (number of nearby atoms within 3.5 √Ö) for each atom.
                </p>
            </div>
        </div>

        <!-- Geometry Tab -->
        <div id="geometry" class="tab-content">
            <h2 class="section-title">Molecular Geometry</h2>
            <div id="geometry-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- Energy Tab -->
        <div id="energy" class="tab-content">
            <h2 class="section-title">Energy Data</h2>
            <div id="energy-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- Orbitals Tab -->
        <div id="orbitals" class="tab-content">
            <h2 class="section-title">Molecular Orbitals</h2>
            <div id="orbitals-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- Vibrations Tab -->
        <div id="vibrations" class="tab-content">
            <h2 class="section-title">Vibrational Analysis</h2>
            <div id="vibrations-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- NMR Tab -->
        <div id="nmr" class="tab-content">
            <h2 class="section-title">NMR Spectroscopy</h2>
            <div id="nmr-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- Population Tab -->
        <div id="population" class="tab-content">
            <h2 class="section-title">Population Analysis</h2>
            <div id="population-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- Raw JSON Tab -->
        <div id="raw" class="tab-content">
            <h2 class="section-title">Raw JSON Data</h2>
            <div id="raw-content" class="json-viewer">
                <p>No data loaded</p>
            </div>
        </div>
    </div>

    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script>
        let data = null;
        let viewer3d = null;
        let showLabels = false;

        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');

            // Render 3D molecule when tab is shown
            if (tabName === 'molecule' && data) {
                setTimeout(() => render3DMolecule(), 100);
            }
        }

        function setStatus(message, success = false) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = success ? 'status success' : 'status';
        }

        // File upload handlers
        function uploadFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            handleFileUpload(file);
        }

        async function handleFileUpload(file) {
            setStatus(`Uploading ${file.name}...`);
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });
                const result = await response.json();

                if (result.success) {
                    data = result.data;
                    setStatus(`‚úì Parsed ${file.name} successfully`, true);
                    renderAllTabs();
                } else {
                    setStatus(`‚úó Error: ${result.message}`, false);
                }
            } catch (error) {
                setStatus(`‚úó Upload failed: ${error.message}`, false);
            }
        }

        // Drag and drop
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFileUpload(file);
        });

        async function loadDefaultData() {
            setStatus('Loading example data...');

            try {
                const response = await fetch('/api/parse', { method: 'POST' });
                const result = await response.json();

                if (result.success) {
                    data = result.data;
                    setStatus('‚úì Example data loaded successfully', true);
                    renderAllTabs();
                } else {
                    setStatus('‚úó Error: ' + result.message);
                }
            } catch (error) {
                setStatus('‚úó Error: ' + error.message);
            }
        }

        function renderAllTabs() {
            renderSummary();
            renderGeometry();
            renderEnergy();
            renderOrbitals();
            renderVibrations();
            renderNMR();
            renderPopulation();
            renderRawJSON();
            // Visualization tabs - rendered on demand when tab is shown
            renderAllPlots();
        }

        function renderSummary() {
            if (!data) return;

            const content = `
                <div class="summary-grid">
                    <div class="card">
                        <h3>Basis Set</h3>
                        <div class="value">${data.job_info.basis_set}</div>
                        <div class="label">${data.job_info.num_electrons} electrons</div>
                    </div>
                    <div class="card">
                        <h3>Final Energy</h3>
                        <div class="value">${data.final_energy ? data.final_energy.toFixed(6) : 'N/A'}</div>
                        <div class="label">Hartree</div>
                    </div>
                    <div class="card">
                        <h3>Atoms</h3>
                        <div class="value">${data.coordinates.length}</div>
                        <div class="label">Molecular system</div>
                    </div>
                    <div class="card">
                        <h3>Dipole Moment</h3>
                        <div class="value">${data.dipole_moment?.magnitude_debye?.toFixed(4) || 'N/A'}</div>
                        <div class="label">Debye</div>
                    </div>
                </div>

                <div class="info-box">
                    <h4>üìà Parser Coverage</h4>
                    <p>This file contains 34 parsed sections out of 57 total sections (60% coverage)</p>
                    <div class="progress">
                        <div class="progress-bar" style="width: 60%">60%</div>
                    </div>
                </div>

                <div class="info-box">
                    <h4>‚ÑπÔ∏è Computation Details</h4>
                    <p><strong>Basis Functions:</strong> ${data.basis_set_info?.num_basis_functions || 'N/A'}</p>
                    <p><strong>DFT Grid Points:</strong> ${data.dft_grid_info?.total_grid_points?.toLocaleString() || 'N/A'}</p>
                    <p><strong>Total Runtime:</strong> ${data.timing_data?.total_run_time ? (data.timing_data.total_run_time / 60).toFixed(1) + ' minutes' : 'N/A'}</p>
                </div>
            `;

            document.getElementById('summary-content').innerHTML = content;
        }

        function renderGeometry() {
            if (!data || !data.coordinates) return;

            let html = '<table><thead><tr><th>Atom</th><th>Element</th><th>X (√Ö)</th><th>Y (√Ö)</th><th>Z (√Ö)</th></tr></thead><tbody>';
            
            data.coordinates.forEach((coord, i) => {
                html += `<tr>
                    <td>${i}</td>
                    <td><strong>${coord[0] || 'N/A'}</strong></td>
                    <td>${typeof coord[1] === 'number' ? coord[1].toFixed(6) : 'N/A'}</td>
                    <td>${typeof coord[2] === 'number' ? coord[2].toFixed(6) : 'N/A'}</td>
                    <td>${typeof coord[3] === 'number' ? coord[3].toFixed(6) : 'N/A'}</td>
                </tr>`;
            });

            html += '</tbody></table>';
            document.getElementById('geometry-content').innerHTML = html;
        }

        function renderEnergy() {
            if (!data) return;

            const thermo = data.thermochemistry || {};
            const html = `
                <div class="info-box">
                    <h4>Single Point Energy</h4>
                    <p><strong>Final Energy:</strong> ${data.final_energy ? data.final_energy.toFixed(6) : 'N/A'} Eh</p>
                </div>

                <div class="info-box">
                    <h4>Thermochemistry (298.15 K)</h4>
                    <p><strong>Gibbs Free Energy:</strong> ${thermo.gibbs_free_energy ? thermo.gibbs_free_energy.toFixed(6) : 'N/A'} Eh</p>
                    <p><strong>Enthalpy:</strong> ${thermo.total_enthalpy ? thermo.total_enthalpy.toFixed(6) : 'N/A'} Eh</p>
                    <p><strong>Zero Point Energy:</strong> ${thermo.zero_point_energy ? thermo.zero_point_energy.toFixed(6) : 'N/A'} Eh</p>
                </div>

                <div class="info-box">
                    <h4>SCF Convergence</h4>
                    <p><strong>Iterations:</strong> ${data.scf_energies?.length || 'N/A'}</p>
                    <p><strong>Final Energy:</strong> ${data.scf_energies?.length ? data.scf_energies[data.scf_energies.length - 1].toFixed(6) + ' Eh' : 'N/A'}</p>
                </div>
            `;

            document.getElementById('energy-content').innerHTML = html;
        }

        function renderOrbitals() {
            if (!data || !data.orbital_energies) return;

            const orbitals = data.orbital_energies.slice(0, 50); // Show first 50

            let html = '<table><thead><tr><th>MO</th><th>Occupation</th><th>Energy (eV)</th><th>Energy (Eh)</th></tr></thead><tbody>';
            
            orbitals.forEach(orb => {
                const highlight = orb.occupation > 0.5 && orb.occupation < 2.0 ? 'style="background: #ffffcc;"' : '';
                html += `<tr ${highlight}>
                    <td>${orb.index || 'N/A'}</td>
                    <td>${orb.occupation?.toFixed(4) || 'N/A'}</td>
                    <td>${orb.energy_ev?.toFixed(4) || 'N/A'}</td>
                    <td>${orb.energy_eh?.toFixed(6) || 'N/A'}</td>
                </tr>`;
            });

            html += '</tbody></table>';
            html += `<p style="margin-top: 20px; color: #666;">Showing first 50 of ${data.orbital_energies.length} molecular orbitals</p>`;
            
            document.getElementById('orbitals-content').innerHTML = html;
        }

        function renderVibrations() {
            if (!data || !data.frequencies) return;

            let html = '<table><thead><tr><th>Mode</th><th>Frequency (cm‚Åª¬π)</th><th>Raman Activity</th></tr></thead><tbody>';
            
            data.frequencies.forEach((freq, i) => {
                const raman = data.raman_spectrum?.[i]?.activity?.toFixed(2) || 'N/A';
                html += `<tr>
                    <td>${i + 1}</td>
                    <td>${typeof freq === 'number' ? freq.toFixed(2) : 'N/A'}</td>
                    <td>${raman}</td>
                </tr>`;
            });

            html += '</tbody></table>';
            document.getElementById('vibrations-content').innerHTML = html;
        }

        function renderNMR() {
            if (!data || !data.nmr_data) return;

            const shifts = data.nmr_data.chemical_shifts;
            
            let html = '<table><thead><tr><th>Nucleus</th><th>Element</th><th>Isotropic (ppm)</th><th>Anisotropy (ppm)</th></tr></thead><tbody>';
            
            shifts.forEach(shift => {
                html += `<tr>
                    <td>${shift.nucleus || 'N/A'}</td>
                    <td><strong>${shift.element || 'N/A'}</strong></td>
                    <td>${shift.isotropic?.toFixed(2) || 'N/A'}</td>
                    <td>${shift.anisotropy?.toFixed(2) || 'N/A'}</td>
                </tr>`;
            });

            html += '</tbody></table>';
            document.getElementById('nmr-content').innerHTML = html;
        }

        function renderPopulation() {
            if (!data) return;

            let html = '<div class="info-box"><h4>Mulliken Charges</h4><table><thead><tr><th>Atom</th><th>Element</th><th>Charge</th></tr></thead><tbody>';
            
            Object.entries(data.mulliken_charges).forEach(([atom, info]) => {
                html += `<tr>
                    <td>${atom}</td>
                    <td><strong>${info.element || 'N/A'}</strong></td>
                    <td>${info.charge?.toFixed(4) || 'N/A'}</td>
                </tr>`;
            });

            html += '</tbody></table></div>';

            html += '<div class="info-box"><h4>Bond Orders</h4>';
            html += `<p><strong>Mayer Bond Orders:</strong> ${data.mayer_bond_orders.length} bonds</p>`;
            html += `<p><strong>Loewdin Bond Orders:</strong> ${data.loewdin_bond_orders.length} bonds</p>`;
            html += '</div>';

            document.getElementById('population-content').innerHTML = html;
        }

        function renderRawJSON() {
            if (!data) return;
            document.getElementById('raw-content').innerHTML = '<pre>' + JSON.stringify(data, null, 2) + '</pre>';
        }

        function exportJSON() {
            if (!data) {
                alert('No data loaded. Please load data first.');
                return;
            }

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'orca_output_parsed.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function refreshData() {
            location.reload();
        }

        // ===== 3D MOLECULAR VISUALIZATION =====
        function render3DMolecule() {
            if (!data || !data.coordinates || data.coordinates.length === 0) {
                console.error('No coordinate data available');
                return;
            }

            const container = document.getElementById('molecule-viewer');
            if (!container) {
                console.error('Molecule viewer container not found');
                return;
            }

            container.innerHTML = ''; // Clear previous viewer

            try {
                viewer3d = $3Dmol.createViewer(container, {
                    backgroundColor: 'white',
                    antialias: true
                });

                // Convert coordinates to XYZ format
                let xyzData = `${data.coordinates.length}\n`;
                xyzData += `ORCA Molecule - ${data.job_info?.basis_set || 'Unknown basis'}\n`;

                data.coordinates.forEach((coord, idx) => {
                    const [element, x, y, z] = coord;
                    if (element && typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {
                        xyzData += `${element}  ${x.toFixed(6)}  ${y.toFixed(6)}  ${z.toFixed(6)}\n`;
                    } else {
                        console.warn(`Invalid coordinate at index ${idx}:`, coord);
                    }
                });

                // Add model with better error handling
                const model = viewer3d.addModel(xyzData, 'xyz');

                if (!model) {
                    throw new Error('Failed to create 3D model');
                }

                // Set default style with better visibility
                viewer3d.setStyle({}, {
                    stick: {radius: 0.15, color: 'spectrum'},
                    sphere: {scale: 0.3}
                });

                // Add hover labels
                viewer3d.setHoverable({}, true, function(atom, viewer, event, container) {
                    if (!atom.label) {
                        const label = `${atom.elem} #${atom.serial}\n` +
                                    `x: ${atom.x.toFixed(3)}\n` +
                                    `y: ${atom.y.toFixed(3)}\n` +
                                    `z: ${atom.z.toFixed(3)}`;
                        viewer.addLabel(label, {
                            position: atom,
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            fontColor: 'white',
                            fontSize: 12,
                            showBackground: true
                        });
                        atom.label = true;
                    }
                }, function(atom) {
                    if (atom.label) {
                        viewer3d.removeAllLabels();
                        atom.label = false;
                    }
                });

                viewer3d.zoomTo();
                viewer3d.render();

                console.log('3D molecule rendered successfully');
            } catch (error) {
                console.error('Error rendering 3D molecule:', error);
                container.innerHTML = `<div style="padding: 20px; color: red;">
                    <strong>Error rendering 3D molecule:</strong><br>
                    ${error.message}<br>
                    Please check the console for details.
                </div>`;
            }
        }

        function setMoleculeStyle(style) {
            if (!viewer3d) return;
            viewer3d.setStyle({}, {});

            if (style === 'stick') {
                viewer3d.setStyle({}, {stick: {radius: 0.15}});
            } else if (style === 'sphere') {
                viewer3d.setStyle({}, {sphere: {scale: 0.5}});
            } else if (style === 'cartoon') {
                viewer3d.setStyle({}, {stick: {radius: 0.15}, sphere: {scale: 0.3}});
            }

            viewer3d.render();
        }

        function toggleLabels() {
            if (!viewer3d || !data) return;
            showLabels = !showLabels;

            viewer3d.removeAllLabels();
            if (showLabels) {
                data.coordinates.forEach((coord, i) => {
                    viewer3d.addLabel(coord[0], {
                        position: {x: coord[1], y: coord[2], z: coord[3]},
                        backgroundColor: 'white',
                        fontColor: 'black',
                        fontSize: 12
                    });
                });
            }
            viewer3d.render();
        }

        function exportMoleculeImage() {
            if (!viewer3d) return;
            const imgData = viewer3d.pngURI();
            const a = document.createElement('a');
            a.href = imgData;
            a.download = 'molecule_3d.png';
            a.click();
        }

        // ===== CHARGE COLORING =====
        let currentChargeType = 'none';

        function setChargeColoring(chargeType) {
            if (!viewer3d || !data) return;
            currentChargeType = chargeType;

            const legend = document.getElementById('charge-legend');

            if (chargeType === 'none') {
                // Reset to element colors
                viewer3d.setStyle({}, {stick: {radius: 0.15}, sphere: {scale: 0.3}});
                legend.style.display = 'none';
            } else {
                // Get charges
                const charges = chargeType === 'mulliken' ? data.mulliken_charges : data.loewdin_charges;
                if (!charges) {
                    alert(`${chargeType} charges not available in data`);
                    return;
                }

                // Color each atom by charge
                data.coordinates.forEach((coord, i) => {
                    const element = coord[0];
                    const atomKey = `${i}${element}`;
                    const chargeData = charges[atomKey];

                    if (chargeData) {
                        const charge = chargeData.charge;
                        const color = chargeToColor(charge);
                        viewer3d.setStyle({serial: i}, {
                            stick: {radius: 0.15},
                            sphere: {scale: 0.4, color: color}
                        });
                    }
                });

                legend.style.display = 'block';
            }

            viewer3d.render();
        }

        function chargeToColor(charge) {
            // Map charge to color: red (negative) -> white (neutral) -> blue (positive)
            const clampedCharge = Math.max(-1, Math.min(1, charge)); // Clamp to [-1, 1]

            if (clampedCharge < 0) {
                // Negative: white to red
                const intensity = Math.abs(clampedCharge);
                const r = 255;
                const g = Math.round(255 * (1 - intensity));
                const b = Math.round(255 * (1 - intensity));
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Positive: white to blue
                const intensity = clampedCharge;
                const r = Math.round(255 * (1 - intensity));
                const g = Math.round(255 * (1 - intensity));
                const b = 255;
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        // ===== DIPOLE MOMENT VECTOR =====
        let showDipole = false;

        function toggleDipole() {
            if (!viewer3d || !data || !data.dipole_moment) return;
            showDipole = !showDipole;

            viewer3d.removeAllShapes();

            if (showDipole) {
                const dipole = data.dipole_moment;
                const mag = dipole.magnitude_debye;

                // Scale factor for arrow length
                const scale = 2.0;

                // Draw arrow from center of molecule
                const center = {x: 0, y: 0, z: 0};
                const end = {
                    x: dipole.x_debye * scale,
                    y: dipole.y_debye * scale,
                    z: dipole.z_debye * scale
                };

                viewer3d.addArrow({
                    start: center,
                    end: end,
                    radius: 0.2,
                    color: 'purple',
                    mid: 0.8
                });

                viewer3d.addLabel(`Œº = ${mag.toFixed(2)} D`, {
                    position: end,
                    backgroundColor: 'purple',
                    fontColor: 'white',
                    fontSize: 14
                });
            }

            viewer3d.render();
        }

        // ===== BOND ORDERS =====
        let showBondOrdersFlag = false;

        function toggleBondOrders() {
            if (!viewer3d || !data || !data.mayer_bond_orders) return;
            showBondOrdersFlag = !showBondOrdersFlag;

            viewer3d.removeAllLabels();

            if (showBondOrdersFlag) {
                // Show bond orders as labels
                data.mayer_bond_orders.forEach(bond => {
                    if (bond.bond_order > 0.5) { // Only show significant bonds
                        const coord1 = data.coordinates[bond.atom1_index];
                        const coord2 = data.coordinates[bond.atom2_index];

                        if (coord1 && coord2) {
                            const midpoint = {
                                x: (coord1[1] + coord2[1]) / 2,
                                y: (coord1[2] + coord2[2]) / 2,
                                z: (coord1[3] + coord2[3]) / 2
                            };

                            viewer3d.addLabel(bond.bond_order.toFixed(2), {
                                position: midpoint,
                                backgroundColor: 'rgba(255, 255, 0, 0.7)',
                                fontColor: 'black',
                                fontSize: 10
                            });
                        }
                    }
                });
            }

            viewer3d.render();
        }

        // ===== PLOTLY VISUALIZATIONS =====
        function renderAllPlots() {
            if (!data) return;
            renderSCFPlot();
            renderIRPlot();
            renderRamanPlot();
            renderThermoPlot();
            renderOrbitalPlot();
            renderNMRPlot();
            renderCombinedSpectrum();
            renderTimingBreakdown();
            renderSCFDetails();
            renderBasisComposition();
            renderGridStatistics();
            // NEW VISUALIZATIONS
            renderOptimizationTrajectory();
            populateVibrationalModes();
            renderOrbitalChargeHeatmap();
            renderJCouplingNetwork();
            renderChemicalShieldingTable();
            renderHOMOLUMOGapTracker();
            renderDensityOfStates();
            renderMullikenOverlapNetwork();
            renderPolarizabilityVisualization();
            renderBondOrderComparison();
            renderChargeComparison();
            renderEnergyComponents();
            renderDispersionCorrection();
            renderOrbitalPopulation();
            renderInternalCoordinates();
            renderSCFEfficiency();
            renderSolvationAnalysis();
            renderOrbitalDistribution();
            renderFrequencyAnalysis();
            renderChargeDistributionPie();
            renderBondCorrelation();
            renderEigenvalueSpectrum();
            renderIRRamanCorrelation();
            renderMassDistribution();
            renderDipoleComponents();
            renderThermoBreakdown();
            renderAtomStats();
            renderAngleDistribution();
            renderElementComposition();
            renderOptConvergence();
            renderPopulationCorrelation();
            renderDistanceAnalysis();
            renderCoordinationNumbers();
        }

        function renderSCFPlot() {
            if (!data || !data.scf_energies || data.scf_energies.length === 0) return;

            const trace = {
                x: Array.from({length: data.scf_energies.length}, (_, i) => i + 1),
                y: data.scf_energies,
                mode: 'lines+markers',
                name: 'SCF Energy',
                line: {color: '#667eea', width: 2},
                marker: {size: 6}
            };

            const layout = {
                title: 'SCF Convergence',
                xaxis: {title: 'Iteration'},
                yaxis: {title: 'Energy (Eh)'},
                hovermode: 'closest'
            };

            Plotly.newPlot('scf-plot', [trace], layout, {responsive: true});
        }

        function renderIRPlot() {
            if (!data || !data.ir_spectrum || data.ir_spectrum.length === 0) return;

            const frequencies = data.ir_spectrum.map(d => d.frequency);
            const intensities = data.ir_spectrum.map(d => d.intensity);

            const trace = {
                x: frequencies,
                y: intensities,
                type: 'bar',
                marker: {color: '#28a745'},
                name: 'IR Intensity'
            };

            const layout = {
                title: 'IR Spectrum',
                xaxis: {title: 'Frequency (cm‚Åª¬π)'},
                yaxis: {title: 'Intensity (km/mol)'},
                hovermode: 'closest'
            };

            Plotly.newPlot('ir-plot', [trace], layout, {responsive: true});
        }

        function renderRamanPlot() {
            if (!data || !data.raman_spectrum || data.raman_spectrum.length === 0) return;

            const frequencies = data.raman_spectrum.map(d => d.frequency);
            const activities = data.raman_spectrum.map(d => d.activity);

            const trace = {
                x: frequencies,
                y: activities,
                type: 'bar',
                marker: {color: '#dc3545'},
                name: 'Raman Activity'
            };

            const layout = {
                title: 'Raman Spectrum',
                xaxis: {title: 'Frequency (cm‚Åª¬π)'},
                yaxis: {title: 'Raman Activity'},
                hovermode: 'closest'
            };

            Plotly.newPlot('raman-plot', [trace], layout, {responsive: true});
        }

        function renderThermoPlot() {
            if (!data || !data.thermochemistry) return;

            const thermo = data.thermochemistry;
            const labels = ['Electronic', 'ZPE', 'Thermal', 'Enthalpy', 'Gibbs Free'];
            const values = [
                data.final_energy || 0,
                thermo.zero_point_energy || 0,
                thermo.total_enthalpy || 0,
                thermo.total_enthalpy || 0,
                thermo.gibbs_free_energy || 0
            ];

            const trace = {
                x: labels,
                y: values,
                type: 'bar',
                marker: {color: ['#667eea', '#764ba2', '#28a745', '#ffc107', '#dc3545']}
            };

            const layout = {
                title: 'Thermochemistry Energy Diagram',
                yaxis: {title: 'Energy (Eh)'},
                hovermode: 'closest'
            };

            Plotly.newPlot('thermo-plot', [trace], layout, {responsive: true});
        }

        function renderOrbitalPlot() {
            if (!data || !data.orbital_energies || data.orbital_energies.length === 0) return;

            // Show orbitals around HOMO-LUMO (e.g., HOMO-10 to LUMO+10)
            const orbitals = data.orbital_energies.slice(Math.max(0, data.orbital_energies.length / 2 - 20), data.orbital_energies.length / 2 + 20);

            const occupied = orbitals.filter(o => o.occupation > 0.5);
            const virtual = orbitals.filter(o => o.occupation <= 0.5);

            const trace1 = {
                x: occupied.map(o => o.index),
                y: occupied.map(o => o.energy_ev),
                mode: 'markers',
                name: 'Occupied',
                marker: {size: 8, color: '#28a745'}
            };

            const trace2 = {
                x: virtual.map(o => o.index),
                y: virtual.map(o => o.energy_ev),
                mode: 'markers',
                name: 'Virtual',
                marker: {size: 8, color: '#dc3545'}
            };

            const layout = {
                title: 'Molecular Orbital Energy Diagram',
                xaxis: {title: 'MO Index'},
                yaxis: {title: 'Energy (eV)'},
                hovermode: 'closest'
            };

            Plotly.newPlot('orbital-plot', [trace1, trace2], layout, {responsive: true});
        }

        function renderNMRPlot() {
            if (!data || !data.nmr_data || !data.nmr_data.chemical_shifts || data.nmr_data.chemical_shifts.length === 0) return;

            const shifts = data.nmr_data.chemical_shifts;
            const x = shifts.map(s => s.isotropic);
            const y = Array(shifts.length).fill(1); // Height of peaks
            const labels = shifts.map(s => `${s.element}${s.nucleus}`);

            const trace = {
                x: x,
                y: y,
                mode: 'markers',
                marker: {size: 12, color: '#667eea'},
                text: labels,
                hoverinfo: 'text+x'
            };

            const layout = {
                title: 'NMR Chemical Shifts',
                xaxis: {title: 'Chemical Shift (ppm)', autorange: 'reversed'},
                yaxis: {title: 'Intensity', showticklabels: false},
                hovermode: 'closest'
            };

            Plotly.newPlot('nmr-plot', [trace], layout, {responsive: true});
        }

        function renderCombinedSpectrum() {
            if (!data || (!data.ir_spectrum && !data.raman_spectrum)) return;

            const traces = [];

            // IR spectrum trace
            if (data.ir_spectrum && data.ir_spectrum.length > 0) {
                const irTrace = {
                    x: data.ir_spectrum.map(d => d.frequency),
                    y: data.ir_spectrum.map(d => d.intensity),
                    type: 'bar',
                    name: 'IR Intensity',
                    marker: {color: '#28a745'},
                    yaxis: 'y',
                    opacity: 0.7
                };
                traces.push(irTrace);
            }

            // Raman spectrum trace
            if (data.raman_spectrum && data.raman_spectrum.length > 0) {
                const ramanTrace = {
                    x: data.raman_spectrum.map(d => d.frequency),
                    y: data.raman_spectrum.map(d => d.activity),
                    type: 'bar',
                    name: 'Raman Activity',
                    marker: {color: '#dc3545'},
                    yaxis: 'y2',
                    opacity: 0.7
                };
                traces.push(ramanTrace);
            }

            const layout = {
                title: 'IR + Raman Combined Spectrum',
                xaxis: {title: 'Frequency (cm‚Åª¬π)'},
                yaxis: {
                    title: 'IR Intensity (km/mol)',
                    titlefont: {color: '#28a745'},
                    tickfont: {color: '#28a745'}
                },
                yaxis2: {
                    title: 'Raman Activity',
                    titlefont: {color: '#dc3545'},
                    tickfont: {color: '#dc3545'},
                    overlaying: 'y',
                    side: 'right'
                },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('combined-spectrum-plot', traces, layout, {responsive: true});
        }

        function renderTimingBreakdown() {
            if (!data || !data.timing_data) return;

            const timing = data.timing_data;

            // Extract timing data (exclude total_run_time)
            const modules = [];
            const times = [];

            for (const [key, value] of Object.entries(timing)) {
                if (key !== 'total_run_time' && typeof value === 'number' && value > 0) {
                    // Format key for display
                    const displayName = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    modules.push(displayName);
                    times.push(value);
                }
            }

            if (modules.length === 0) {
                // No timing data available
                return;
            }

            const trace = {
                labels: modules,
                values: times,
                type: 'pie',
                textinfo: 'label+percent',
                hoverinfo: 'label+value+percent',
                marker: {
                    colors: ['#667eea', '#764ba2', '#28a745', '#ffc107', '#dc3545', '#17a2b8', '#6c757d', '#e83e8c']
                }
            };

            const layout = {
                title: 'Computation Time Breakdown',
                height: 400,
                showlegend: true
            };

            Plotly.newPlot('timing-plot', [trace], layout, {responsive: true});
        }

        function renderSCFDetails() {
            if (!data || !data.scf_iterations || data.scf_iterations.length === 0) return;

            const iterations = data.scf_iterations;
            const xData = iterations.map((_, i) => i + 1);

            const traces = [];

            // Energy convergence
            if (iterations[0].energy !== undefined) {
                traces.push({
                    x: xData,
                    y: iterations.map(it => it.energy),
                    name: 'Energy (Eh)',
                    mode: 'lines+markers',
                    line: {color: '#667eea', width: 2},
                    marker: {size: 6},
                    yaxis: 'y',
                    hovertemplate: 'Iteration %{x}<br>Energy: %{y:.8f} Eh<extra></extra>'
                });
            }

            // Density convergence
            if (iterations[0].max_density_change !== undefined) {
                traces.push({
                    x: xData,
                    y: iterations.map(it => Math.abs(it.max_density_change)),
                    name: 'Density Change',
                    mode: 'lines+markers',
                    line: {color: '#28a745', width: 2, dash: 'dot'},
                    marker: {size: 6},
                    yaxis: 'y2',
                    hovertemplate: 'Iteration %{x}<br>Density: %{y:.2e}<extra></extra>'
                });
            }

            // DIIS error
            if (iterations[0].diis_error !== undefined) {
                traces.push({
                    x: xData,
                    y: iterations.map(it => it.diis_error),
                    name: 'DIIS Error',
                    mode: 'lines+markers',
                    line: {color: '#dc3545', width: 2, dash: 'dash'},
                    marker: {size: 6},
                    yaxis: 'y3',
                    hovertemplate: 'Iteration %{x}<br>DIIS Error: %{y:.2e}<extra></extra>'
                });
            }

            if (traces.length === 0) return;

            const layout = {
                title: 'SCF Convergence Details',
                xaxis: {title: 'Iteration'},
                yaxis: {
                    title: 'Energy (Eh)',
                    titlefont: {color: '#667eea'},
                    tickfont: {color: '#667eea'}
                },
                yaxis2: {
                    title: 'Density Change',
                    titlefont: {color: '#28a745'},
                    tickfont: {color: '#28a745'},
                    overlaying: 'y',
                    side: 'right',
                    type: 'log'
                },
                yaxis3: {
                    title: 'DIIS Error',
                    titlefont: {color: '#dc3545'},
                    tickfont: {color: '#dc3545'},
                    anchor: 'free',
                    overlaying: 'y',
                    side: 'right',
                    position: 0.95,
                    type: 'log'
                },
                hovermode: 'x unified',
                showlegend: true,
                legend: {x: 0.01, y: 0.99}
            };

            Plotly.newPlot('scf-details-plot', traces, layout, {responsive: true});
        }

        function renderBasisComposition() {
            if (!data || !data.basis_set_info) return;

            const basis = data.basis_set_info;

            // Count shells by type
            const shellCounts = {};
            let totalPrimitives = 0;

            // Try to extract shell information
            // This is a simplified version - real implementation depends on data structure
            const labels = [];
            const values = [];

            if (basis.num_basis_functions) {
                // If we have detailed shell info, use it
                // Otherwise, show general info
                labels.push('Total Basis Functions');
                values.push(basis.num_basis_functions);
            }

            if (basis.num_contracted_shells) {
                labels.push('Contracted Shells');
                values.push(basis.num_contracted_shells);
            }

            if (basis.num_primitive_shells) {
                labels.push('Primitive Shells');
                values.push(basis.num_primitive_shells);
            }

            if (labels.length === 0) return;

            const trace = {
                labels: labels,
                values: values,
                type: 'pie',
                textinfo: 'label+value',
                hoverinfo: 'label+value+percent',
                marker: {
                    colors: ['#667eea', '#764ba2', '#28a745', '#ffc107', '#dc3545']
                },
                hovertemplate: '%{label}<br>Count: %{value}<br>Percent: %{percent}<extra></extra>'
            };

            const layout = {
                title: `Basis Set: ${basis.basis_set_name || 'Unknown'}`,
                height: 400,
                showlegend: true,
                annotations: [{
                    text: `${basis.num_basis_functions || 0} Functions`,
                    x: 0.5,
                    y: -0.1,
                    xref: 'paper',
                    yref: 'paper',
                    showarrow: false,
                    font: {size: 14}
                }]
            };

            Plotly.newPlot('basis-plot', [trace], layout, {responsive: true});
        }

        function renderGridStatistics() {
            if (!data || (!data.dft_grid_info && !data.cosx_grids)) return;

            const traces = [];

            // DFT Grid data
            if (data.dft_grid_info) {
                const grid = data.dft_grid_info;
                traces.push({
                    x: ['Total Grid Points', 'Radial Points', 'Angular Points'],
                    y: [
                        grid.total_grid_points || 0,
                        grid.radial_grid_points || 0,
                        grid.angular_grid_points || 0
                    ],
                    name: 'DFT Grid',
                    type: 'bar',
                    marker: {color: '#667eea'},
                    hovertemplate: '%{x}: %{y:,}<extra></extra>'
                });
            }

            // COSX Grids
            if (data.cosx_grids && data.cosx_grids.length > 0) {
                const cosxLabels = data.cosx_grids.map((g, i) => `Grid ${g.grid_number || i+1}`);
                const cosxPoints = data.cosx_grids.map(g => g.total_grid_points || 0);

                traces.push({
                    x: cosxLabels,
                    y: cosxPoints,
                    name: 'COSX Grids',
                    type: 'bar',
                    marker: {color: '#28a745'},
                    hovertemplate: '%{x}: %{y:,} points<extra></extra>'
                });
            }

            if (traces.length === 0) return;

            const layout = {
                title: 'DFT Grid Statistics',
                xaxis: {title: 'Grid Type'},
                yaxis: {title: 'Number of Points', type: 'log'},
                barmode: 'group',
                hovermode: 'closest',
                showlegend: traces.length > 1
            };

            Plotly.newPlot('grid-plot', traces, layout, {responsive: true});
        }

        // ===== COLLAPSIBLE SECTIONS =====
        function toggleCollapsible(element) {
            element.classList.toggle('active');
            const content = element.nextElementSibling;
            content.classList.toggle('active');
        }

        // ===== EXPORT FUNCTIONS =====
        function exportPlot(plotId, filename) {
            Plotly.downloadImage(plotId, {
                format: filename.endsWith('.svg') ? 'svg' : 'png',
                filename: filename.replace(/\.(png|svg)$/, ''),
                width: 1200,
                height: 800
            });
        }

        // ===== NEW VISUALIZATIONS =====

        // 1. GEOMETRY OPTIMIZATION TRAJECTORY
        let optAnimationInterval = null;

        function renderOptimizationTrajectory() {
            if (!data || !data.optimization_energies || data.optimization_energies.length === 0) return;

            const energies = data.optimization_energies;
            const steps = Array.from({length: energies.length}, (_, i) => i + 1);

            // Update slider max
            const slider = document.getElementById('opt-slider');
            slider.max = energies.length - 1;

            const trace = {
                x: steps,
                y: energies,
                mode: 'lines+markers',
                name: 'Energy',
                line: {color: '#667eea', width: 3},
                marker: {size: 8, color: '#764ba2'},
                hovertemplate: 'Step %{x}<br>Energy: %{y:.8f} Eh<extra></extra>'
            };

            const layout = {
                title: 'Geometry Optimization Energy Trajectory',
                xaxis: {title: 'Optimization Step'},
                yaxis: {title: 'Energy (Eh)'},
                hovermode: 'closest',
                showlegend: false
            };

            Plotly.newPlot('opt-trajectory-plot', [trace], layout, {responsive: true});

            // Add click event to jump to step
            document.getElementById('opt-trajectory-plot').on('plotly_click', function(data) {
                if (data.points && data.points.length > 0) {
                    const step = data.points[0].pointIndex;
                    updateOptStep(step);
                    slider.value = step;
                }
            });
        }

        function updateOptStep(step) {
            document.getElementById('opt-step-label').textContent = parseInt(step) + 1;

            // Highlight the selected point on the plot
            if (!data || !data.optimization_energies) return;

            const energies = data.optimization_energies;
            const steps = Array.from({length: energies.length}, (_, i) => i + 1);

            const trace1 = {
                x: steps,
                y: energies,
                mode: 'lines+markers',
                name: 'Energy',
                line: {color: '#667eea', width: 3},
                marker: {size: 8, color: '#764ba2'},
                hovertemplate: 'Step %{x}<br>Energy: %{y:.8f} Eh<extra></extra>'
            };

            const trace2 = {
                x: [parseInt(step) + 1],
                y: [energies[parseInt(step)]],
                mode: 'markers',
                name: 'Current',
                marker: {size: 15, color: '#ffc107', line: {width: 2, color: 'black'}},
                hovertemplate: 'Current Step: %{x}<br>Energy: %{y:.8f} Eh<extra></extra>'
            };

            const layout = {
                title: 'Geometry Optimization Energy Trajectory',
                xaxis: {title: 'Optimization Step'},
                yaxis: {title: 'Energy (Eh)'},
                hovermode: 'closest',
                showlegend: false
            };

            Plotly.react('opt-trajectory-plot', [trace1, trace2], layout, {responsive: true});
        }

        function playOptAnimation() {
            if (optAnimationInterval) return; // Already playing

            const slider = document.getElementById('opt-slider');
            const maxStep = parseInt(slider.max);
            let currentStep = parseInt(slider.value);

            optAnimationInterval = setInterval(() => {
                currentStep++;
                if (currentStep > maxStep) {
                    currentStep = 0;
                }
                slider.value = currentStep;
                updateOptStep(currentStep);
            }, 500); // 500ms per step
        }

        function pauseOptAnimation() {
            if (optAnimationInterval) {
                clearInterval(optAnimationInterval);
                optAnimationInterval = null;
            }
        }

        function resetOptAnimation() {
            pauseOptAnimation();
            const slider = document.getElementById('opt-slider');
            slider.value = 0;
            updateOptStep(0);
        }

        // 2. VIBRATIONAL MODE ANIMATION
        let vibAnimationInterval = null;
        let currentVibMode = null;

        function populateVibrationalModes() {
            if (!data || !data.frequencies || data.frequencies.length === 0) return;

            const selector = document.getElementById('mode-selector');
            selector.innerHTML = '<option value="">-- Select Mode --</option>';

            data.frequencies.forEach((freq, i) => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Mode ${i + 1}: ${freq.toFixed(2)} cm‚Åª¬π`;
                selector.appendChild(option);
            });
        }

        function selectVibrationalMode(modeIndex) {
            if (!modeIndex || !data) return;

            currentVibMode = parseInt(modeIndex);
            const freq = data.frequencies[currentVibMode];
            const irData = data.ir_spectrum ? data.ir_spectrum[currentVibMode] : null;
            const ramanData = data.raman_spectrum ? data.raman_spectrum[currentVibMode] : null;

            // Update info display
            document.getElementById('vib-frequency').textContent = freq.toFixed(2);
            document.getElementById('vib-ir-intensity').textContent = irData ? irData.intensity.toFixed(2) : 'N/A';
            document.getElementById('vib-raman-activity').textContent = ramanData ? ramanData.activity.toFixed(2) : 'N/A';
            document.getElementById('vib-mode-info').style.display = 'block';

            // Display mode info
            alert(`Vibrational mode ${currentVibMode + 1} selected.\n\nNote: Full normal mode displacement vectors are partially available in the parsed data. For complete animation, all 3N displacement vectors would be needed from the ORCA output.`);
        }

        function playVibAnimation() {
            if (!currentVibMode && currentVibMode !== 0) {
                alert('Please select a vibrational mode first.');
                return;
            }
            alert('Vibrational animation would animate atomic displacements based on normal mode vectors. This requires the full normal mode displacement data (3N vectors per mode).');
        }

        function pauseVibAnimation() {
            if (vibAnimationInterval) {
                clearInterval(vibAnimationInterval);
                vibAnimationInterval = null;
            }
        }

        function updateVibAmplitude(value) {
            document.getElementById('vib-amp-label').textContent = value;
        }

        // 3. ORBITAL CHARGE HEATMAP
        let currentHeatmapChargeType = 'mulliken';

        function renderOrbitalChargeHeatmap() {
            if (!data || !data.mulliken_orbital_charges || data.mulliken_orbital_charges.length === 0) return;

            updateHeatmapChargeType('mulliken');
        }

        function updateHeatmapChargeType(chargeType) {
            currentHeatmapChargeType = chargeType;
            const charges = chargeType === 'mulliken' ? data.mulliken_orbital_charges : data.loewdin_orbital_charges;

            if (!charges || charges.length === 0) {
                alert(`${chargeType} orbital charges not available in data`);
                return;
            }

            // Build heatmap data: MOs (rows) √ó Atoms (columns)
            // Each MOCharge has: mo_index, atom_charges (dict)

            // Get all unique atom indices
            const atomIndices = new Set();
            charges.forEach(moCharge => {
                Object.keys(moCharge.atom_charges || {}).forEach(atomIdx => {
                    atomIndices.add(parseInt(atomIdx));
                });
            });
            const sortedAtomIndices = Array.from(atomIndices).sort((a, b) => a - b);

            // Build z matrix (MO √ó Atom)
            const zMatrix = [];
            const moLabels = [];
            const atomLabels = sortedAtomIndices.map(idx => {
                const coord = data.coordinates[idx];
                return coord ? `${coord[0]}${idx}` : `Atom${idx}`;
            });

            charges.forEach(moCharge => {
                const row = [];
                sortedAtomIndices.forEach(atomIdx => {
                    const charge = moCharge.atom_charges[atomIdx] || 0;
                    row.push(charge);
                });
                zMatrix.push(row);
                moLabels.push(`MO ${moCharge.mo_index}`);
            });

            const trace = {
                z: zMatrix,
                x: atomLabels,
                y: moLabels,
                type: 'heatmap',
                colorscale: 'RdBu',
                reversescale: true,
                hovertemplate: 'MO: %{y}<br>Atom: %{x}<br>Charge: %{z:.4f}<extra></extra>',
                colorbar: {
                    title: 'Charge'
                }
            };

            const layout = {
                title: `${chargeType.charAt(0).toUpperCase() + chargeType.slice(1)} Orbital Charges Heatmap`,
                xaxis: {title: 'Atoms', tickangle: -45},
                yaxis: {title: 'Molecular Orbitals', autorange: 'reversed'},
                height: 600
            };

            Plotly.newPlot('orbital-heatmap-plot', [trace], layout, {responsive: true});
        }

        function zoomToHOMOLUMO() {
            if (!data || !data.orbital_energies) return;

            // Find HOMO index (last occupied orbital)
            const homoIndex = data.orbital_energies.findIndex(o => o.occupation <= 0.5) - 1;
            if (homoIndex < 0) return;

            // Show HOMO-10 to LUMO+10
            const startMO = Math.max(0, homoIndex - 10);
            const endMO = Math.min(data.orbital_energies.length - 1, homoIndex + 11);

            Plotly.relayout('orbital-heatmap-plot', {
                'yaxis.range': [endMO, startMO]  // Reversed because y is reversed
            });
        }

        function resetHeatmapZoom() {
            Plotly.relayout('orbital-heatmap-plot', {
                'yaxis.range': null,
                'xaxis.range': null
            });
        }

        // 4. NMR J-COUPLING NETWORK
        function renderJCouplingNetwork() {
            if (!data || !data.nmr_data || !data.nmr_data.j_couplings || data.nmr_data.j_couplings.length === 0) return;

            const jCouplings = data.nmr_data.j_couplings;
            const chemicalShifts = data.nmr_data.chemical_shifts || [];

            // Create nodes (nuclei)
            const nodeIndices = new Set();
            jCouplings.forEach(jc => {
                nodeIndices.add(jc.atom1_index);
                nodeIndices.add(jc.atom2_index);
            });

            const nodes = Array.from(nodeIndices).map(idx => {
                const shift = chemicalShifts.find(s => s.nucleus === idx);
                const coord = data.coordinates[idx];
                return {
                    index: idx,
                    element: coord ? coord[0] : 'X',
                    shift: shift ? shift.isotropic : 0
                };
            });

            // Create edges (J-couplings)
            const edges = jCouplings.map(jc => ({
                from: jc.atom1_index,
                to: jc.atom2_index,
                value: Math.abs(jc.value),
                label: jc.value.toFixed(2) + ' Hz'
            }));

            // Use a force-directed layout approximation with Plotly
            // For simplicity, use a circular layout
            const n = nodes.length;
            const nodeX = nodes.map((node, i) => Math.cos(2 * Math.PI * i / n));
            const nodeY = nodes.map((node, i) => Math.sin(2 * Math.PI * i / n));

            // Edge traces
            const edgeTraces = [];
            edges.forEach(edge => {
                const fromIdx = nodes.findIndex(n => n.index === edge.from);
                const toIdx = nodes.findIndex(n => n.index === edge.to);
                if (fromIdx >= 0 && toIdx >= 0) {
                    const edgeTrace = {
                        x: [nodeX[fromIdx], nodeX[toIdx], null],
                        y: [nodeY[fromIdx], nodeY[toIdx], null],
                        mode: 'lines',
                        line: {
                            width: Math.min(10, Math.max(1, edge.value / 10)),
                            color: '#999'
                        },
                        hovertemplate: `J-coupling: ${edge.label}<extra></extra>`,
                        showlegend: false
                    };
                    edgeTraces.push(edgeTrace);
                }
            });

            // Node trace
            const nodeTrace = {
                x: nodeX,
                y: nodeY,
                mode: 'markers+text',
                marker: {
                    size: 20,
                    color: nodes.map((_, i) => i),
                    colorscale: 'Viridis',
                    line: {width: 2, color: 'white'}
                },
                text: nodes.map(n => `${n.element}${n.index}`),
                textposition: 'top center',
                hovertemplate: 'Nucleus: %{text}<br>Chemical Shift: %{customdata:.2f} ppm<extra></extra>',
                customdata: nodes.map(n => n.shift)
            };

            const traces = [...edgeTraces, nodeTrace];

            const layout = {
                title: 'NMR J-Coupling Network',
                xaxis: {showgrid: false, zeroline: false, showticklabels: false},
                yaxis: {showgrid: false, zeroline: false, showticklabels: false},
                hovermode: 'closest',
                showlegend: false,
                height: 500
            };

            Plotly.newPlot('jcoupling-network-plot', traces, layout, {responsive: true});
        }

        // 5. CHEMICAL SHIELDING TENSORS TABLE
        function renderChemicalShieldingTable() {
            if (!data || !data.chemical_shielding_tensors || data.chemical_shielding_tensors.length === 0) return;

            const tensors = data.chemical_shielding_tensors;

            let html = '<table><thead><tr><th>Atom</th><th>Element</th><th>Isotropic (ppm)</th><th>Components</th><th>Details</th></tr></thead><tbody>';

            tensors.forEach((tensor, i) => {
                const coord = data.coordinates[tensor.atom_index];
                const element = coord ? coord[0] : 'X';

                html += `<tr>
                    <td>${tensor.atom_index}</td>
                    <td><strong>${element}</strong></td>
                    <td>${tensor.total_iso.toFixed(2)}</td>
                    <td>
                        ${tensor.total_components[0]?.toFixed(2) || 'N/A'},
                        ${tensor.total_components[1]?.toFixed(2) || 'N/A'},
                        ${tensor.total_components[2]?.toFixed(2) || 'N/A'}
                    </td>
                    <td>
                        <button class="btn-secondary" onclick="showTensorDetails(${i})" style="font-size: 11px; padding: 4px 8px;">View Tensor</button>
                    </td>
                </tr>`;
            });

            html += '</tbody></table>';
            html += '<div id="tensor-details-modal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 1000; max-width: 600px;"></div>';
            html += '<div id="tensor-modal-overlay" onclick="closeTensorDetails()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>';

            document.getElementById('shielding-tensors-table').innerHTML = html;
        }

        function showTensorDetails(tensorIndex) {
            if (!data || !data.chemical_shielding_tensors) return;

            const tensor = data.chemical_shielding_tensors[tensorIndex];
            const coord = data.coordinates[tensor.atom_index];
            const element = coord ? coord[0] : 'X';

            // Format 3x3 tensor
            const formatTensor = (values) => {
                if (!values || values.length !== 9) return 'N/A';
                return `
                    <table style="margin: 10px auto; border-collapse: collapse;">
                        <tr><td style="padding: 5px;">${values[0].toFixed(3)}</td><td style="padding: 5px;">${values[1].toFixed(3)}</td><td style="padding: 5px;">${values[2].toFixed(3)}</td></tr>
                        <tr><td style="padding: 5px;">${values[3].toFixed(3)}</td><td style="padding: 5px;">${values[4].toFixed(3)}</td><td style="padding: 5px;">${values[5].toFixed(3)}</td></tr>
                        <tr><td style="padding: 5px;">${values[6].toFixed(3)}</td><td style="padding: 5px;">${values[7].toFixed(3)}</td><td style="padding: 5px;">${values[8].toFixed(3)}</td></tr>
                    </table>
                `;
            };

            const html = `
                <h3 style="margin-top: 0;">Chemical Shielding Tensor - ${element}${tensor.atom_index}</h3>
                <button onclick="closeTensorDetails()" style="position: absolute; top: 10px; right: 10px; border: none; background: #dc3545; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;">‚úï</button>

                <h4>Total Tensor (ppm)</h4>
                ${formatTensor(tensor.total_tensor)}

                <h4>Diamagnetic Tensor (ppm)</h4>
                ${formatTensor(tensor.diamagnetic_tensor)}

                <h4>Paramagnetic Tensor (ppm)</h4>
                ${formatTensor(tensor.paramagnetic_tensor)}

                <h4>Isotropic Values</h4>
                <p><strong>Total:</strong> ${tensor.total_iso.toFixed(2)} ppm</p>
                <p><strong>Diamagnetic:</strong> ${tensor.sdso_iso.toFixed(2)} ppm</p>
                <p><strong>Paramagnetic:</strong> ${tensor.spso_iso.toFixed(2)} ppm</p>

                <h4>Eigenvalues (Diagonalized Components)</h4>
                <p>${tensor.total_components[0]?.toFixed(2) || 'N/A'}, ${tensor.total_components[1]?.toFixed(2) || 'N/A'}, ${tensor.total_components[2]?.toFixed(2) || 'N/A'} ppm</p>
            `;

            document.getElementById('tensor-details-modal').innerHTML = html;
            document.getElementById('tensor-details-modal').style.display = 'block';
            document.getElementById('tensor-modal-overlay').style.display = 'block';
        }

        function closeTensorDetails() {
            document.getElementById('tensor-details-modal').style.display = 'none';
            document.getElementById('tensor-modal-overlay').style.display = 'none';
        }

        // 6. HOMO-LUMO GAP TRACKER
        function renderHOMOLUMOGapTracker() {
            if (!data || !data.orbital_energies || data.orbital_energies.length === 0) return;

            // Find HOMO and LUMO for each optimization step
            // Note: We only have one set of orbital energies (final geometry)
            // For a true gap tracker, we'd need orbital energies at each optimization step

            // For now, show a single point with the final HOMO-LUMO gap
            const orbitals = data.orbital_energies;
            const homoIndex = orbitals.findIndex(o => o.occupation <= 0.5) - 1;

            if (homoIndex < 0 || homoIndex >= orbitals.length - 1) {
                // No HOMO-LUMO gap available
                return;
            }

            const homo = orbitals[homoIndex];
            const lumo = orbitals[homoIndex + 1];
            const gap = lumo.energy_ev - homo.energy_ev;

            // If we have optimization energies, create a placeholder plot
            if (data.optimization_energies && data.optimization_energies.length > 1) {
                const steps = Array.from({length: data.optimization_energies.length}, (_, i) => i + 1);
                const gaps = Array(data.optimization_energies.length).fill(gap); // Constant for now

                const trace = {
                    x: steps,
                    y: gaps,
                    mode: 'lines+markers',
                    name: 'HOMO-LUMO Gap',
                    line: {color: '#667eea', width: 3},
                    marker: {size: 8, color: '#764ba2'},
                    hovertemplate: 'Step %{x}<br>Gap: %{y:.4f} eV<extra></extra>'
                };

                const layout = {
                    title: 'HOMO-LUMO Energy Gap Evolution',
                    xaxis: {title: 'Optimization Step'},
                    yaxis: {title: 'HOMO-LUMO Gap (eV)'},
                    hovermode: 'closest',
                    annotations: [{
                        text: 'Note: Gap shown is from final geometry (orbital energies at intermediate steps not available)',
                        x: 0.5,
                        y: 1.1,
                        xref: 'paper',
                        yref: 'paper',
                        showarrow: false,
                        font: {size: 10, color: '#666'}
                    }]
                };

                Plotly.newPlot('homo-lumo-gap-plot', [trace], layout, {responsive: true});
            } else {
                // Single point
                const trace = {
                    x: [1],
                    y: [gap],
                    mode: 'markers',
                    name: 'HOMO-LUMO Gap',
                    marker: {size: 15, color: '#667eea'},
                    hovertemplate: 'Gap: %{y:.4f} eV<extra></extra>'
                };

                const layout = {
                    title: 'HOMO-LUMO Energy Gap',
                    xaxis: {title: 'Final Geometry', showticklabels: false},
                    yaxis: {title: 'HOMO-LUMO Gap (eV)'},
                    hovermode: 'closest'
                };

                Plotly.newPlot('homo-lumo-gap-plot', [trace], layout, {responsive: true});
            }
        }

        // 7. DENSITY OF STATES
        function renderDensityOfStates() {
            if (!data || !data.orbital_energies || data.orbital_energies.length === 0) return;

            const orbitals = data.orbital_energies;

            // Separate occupied and virtual orbitals
            const occupiedEnergies = orbitals.filter(o => o.occupation > 0.5).map(o => o.energy_ev);
            const virtualEnergies = orbitals.filter(o => o.occupation <= 0.5).map(o => o.energy_ev);

            // Create histogram with Gaussian broadening
            const sigma = 0.3; // eV
            const numPoints = 200;

            const allEnergies = orbitals.map(o => o.energy_ev);
            const minE = Math.min(...allEnergies) - 2;
            const maxE = Math.max(...allEnergies) + 2;
            const energyRange = Array.from({length: numPoints}, (_, i) => minE + (maxE - minE) * i / (numPoints - 1));

            // Gaussian function
            const gaussian = (x, mu, sigma) => Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2)) / (sigma * Math.sqrt(2 * Math.PI));

            // Calculate DOS for occupied orbitals
            const dosOccupied = energyRange.map(E => {
                return occupiedEnergies.reduce((sum, e) => sum + gaussian(E, e, sigma), 0);
            });

            // Calculate DOS for virtual orbitals
            const dosVirtual = energyRange.map(E => {
                return virtualEnergies.reduce((sum, e) => sum + gaussian(E, e, sigma), 0);
            });

            const trace1 = {
                x: energyRange,
                y: dosOccupied,
                fill: 'tozeroy',
                name: 'Occupied',
                line: {color: '#28a745', width: 2},
                fillcolor: 'rgba(40, 167, 69, 0.3)',
                hovertemplate: 'Energy: %{x:.2f} eV<br>DOS: %{y:.4f}<extra></extra>'
            };

            const trace2 = {
                x: energyRange,
                y: dosVirtual,
                fill: 'tozeroy',
                name: 'Virtual',
                line: {color: '#dc3545', width: 2},
                fillcolor: 'rgba(220, 53, 69, 0.3)',
                hovertemplate: 'Energy: %{x:.2f} eV<br>DOS: %{y:.4f}<extra></extra>'
            };

            const layout = {
                title: 'Density of States (DOS)',
                xaxis: {title: 'Energy (eV)'},
                yaxis: {title: 'Density of States'},
                hovermode: 'x unified',
                showlegend: true,
                legend: {x: 0.8, y: 1}
            };

            Plotly.newPlot('dos-plot', [trace1, trace2], layout, {responsive: true});
        }

        // 8. MULLIKEN OVERLAP NETWORK
        let currentOverlapLayout = 'circular';
        let currentOverlapThreshold = 1.0;

        function renderMullikenOverlapNetwork() {
            if (!data || !data.mulliken_overlap_charges || data.mulliken_overlap_charges.length === 0) return;

            updateOverlapNetwork();
        }

        function updateOverlapNetwork() {
            if (!data || !data.mulliken_overlap_charges) return;

            const overlaps = data.mulliken_overlap_charges;

            // Filter by threshold
            const filteredOverlaps = overlaps.filter(o => Math.abs(o.overlap_charge) >= currentOverlapThreshold);

            if (filteredOverlaps.length === 0) {
                document.getElementById('overlap-network-plot').innerHTML = '<p style="text-align: center; padding: 40px;">No overlaps above threshold. Reduce minimum overlap value.</p>';
                return;
            }

            // Create nodes (unique atoms)
            const nodeIndices = new Set();
            filteredOverlaps.forEach(o => {
                nodeIndices.add(o.atom1_index);
                nodeIndices.add(o.atom2_index);
            });

            const nodes = Array.from(nodeIndices).map(idx => {
                const coord = data.coordinates[idx];
                return {
                    index: idx,
                    element: coord ? coord[0] : 'X',
                    x: coord ? coord[1] : 0,
                    y: coord ? coord[2] : 0,
                    z: coord ? coord[3] : 0
                };
            });

            let nodeX, nodeY, nodeZ;

            if (currentOverlapLayout === 'circular') {
                // Circular layout
                const n = nodes.length;
                nodeX = nodes.map((node, i) => 10 * Math.cos(2 * Math.PI * i / n));
                nodeY = nodes.map((node, i) => 10 * Math.sin(2 * Math.PI * i / n));
                nodeZ = nodes.map(() => 0);
            } else {
                // 3D molecular coordinates
                nodeX = nodes.map(n => n.x);
                nodeY = nodes.map(n => n.y);
                nodeZ = nodes.map(n => n.z);
            }

            // Edge traces
            const edgeTraces = [];
            filteredOverlaps.forEach(overlap => {
                const fromIdx = nodes.findIndex(n => n.index === overlap.atom1_index);
                const toIdx = nodes.findIndex(n => n.index === overlap.atom2_index);
                if (fromIdx >= 0 && toIdx >= 0) {
                    const absCharge = Math.abs(overlap.overlap_charge);
                    const edgeTrace = {
                        x: [nodeX[fromIdx], nodeX[toIdx], null],
                        y: [nodeY[fromIdx], nodeY[toIdx], null],
                        z: currentOverlapLayout === '3d' ? [nodeZ[fromIdx], nodeZ[toIdx], null] : undefined,
                        mode: 'lines',
                        line: {
                            width: Math.min(10, Math.max(1, absCharge / 2)),
                            color: overlap.overlap_charge > 0 ? '#28a745' : '#dc3545'
                        },
                        hovertemplate: `${nodes[fromIdx].element}${overlap.atom1_index} - ${nodes[toIdx].element}${overlap.atom2_index}<br>Overlap: ${overlap.overlap_charge.toFixed(3)}<extra></extra>`,
                        showlegend: false,
                        type: currentOverlapLayout === '3d' ? 'scatter3d' : 'scatter'
                    };
                    edgeTraces.push(edgeTrace);
                }
            });

            // Node trace
            const nodeTrace = {
                x: nodeX,
                y: nodeY,
                z: currentOverlapLayout === '3d' ? nodeZ : undefined,
                mode: 'markers+text',
                marker: {
                    size: 12,
                    color: nodes.map((_, i) => i),
                    colorscale: 'Viridis',
                    line: {width: 2, color: 'white'}
                },
                text: nodes.map(n => `${n.element}${n.index}`),
                textposition: 'top center',
                hovertemplate: 'Atom: %{text}<br>Index: %{customdata}<extra></extra>',
                customdata: nodes.map(n => n.index),
                type: currentOverlapLayout === '3d' ? 'scatter3d' : 'scatter'
            };

            const traces = [...edgeTraces, nodeTrace];

            const layout = {
                title: 'Mulliken Overlap Charges Network',
                showlegend: false,
                hovermode: 'closest',
                height: 600
            };

            if (currentOverlapLayout === 'circular') {
                layout.xaxis = {showgrid: false, zeroline: false, showticklabels: false};
                layout.yaxis = {showgrid: false, zeroline: false, showticklabels: false};
            } else {
                layout.scene = {
                    xaxis: {title: 'X (√Ö)'},
                    yaxis: {title: 'Y (√Ö)'},
                    zaxis: {title: 'Z (√Ö)'}
                };
            }

            Plotly.newPlot('overlap-network-plot', traces, layout, {responsive: true});
        }

        function updateOverlapLayout(layout) {
            currentOverlapLayout = layout;
            updateOverlapNetwork();
        }

        function updateOverlapThreshold(value) {
            currentOverlapThreshold = parseFloat(value);
            document.getElementById('overlap-threshold-label').textContent = value;
            updateOverlapNetwork();
        }

        // 9. POLARIZABILITY VISUALIZATION
        function renderPolarizabilityVisualization() {
            if (!data || !data.polarizability) return;

            const pol = data.polarizability;

            // Display tensor
            if (pol.tensor && pol.tensor.length === 3) {
                let tensorHTML = '<table style="margin: 10px auto; border-collapse: collapse; text-align: center;">';
                tensorHTML += '<tr><th style="padding: 8px; background: #667eea; color: white;">X</th><th style="padding: 8px; background: #667eea; color: white;">Y</th><th style="padding: 8px; background: #667eea; color: white;">Z</th></tr>';
                pol.tensor.forEach(row => {
                    tensorHTML += '<tr>';
                    row.forEach(val => {
                        tensorHTML += `<td style="padding: 8px; border: 1px solid #ddd;">${val.toFixed(4)}</td>`;
                    });
                    tensorHTML += '</tr>';
                });
                tensorHTML += '</table>';
                tensorHTML += `<p style="text-align: center; margin-top: 10px;"><strong>Isotropic:</strong> ${pol.isotropic.toFixed(4)} a.u.</p>`;
                document.getElementById('polarizability-tensor-display').innerHTML = tensorHTML;
            }

            // Display eigenvalues
            if (pol.eigenvalues && pol.eigenvalues.length === 3) {
                const eigenHTML = `
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; text-align: center;">
                        <div style="padding: 10px; background: white; border-radius: 4px;">
                            <strong>Œ±‚ÇÅ:</strong> ${pol.eigenvalues[0].toFixed(4)} a.u.
                        </div>
                        <div style="padding: 10px; background: white; border-radius: 4px;">
                            <strong>Œ±‚ÇÇ:</strong> ${pol.eigenvalues[1].toFixed(4)} a.u.
                        </div>
                        <div style="padding: 10px; background: white; border-radius: 4px;">
                            <strong>Œ±‚ÇÉ:</strong> ${pol.eigenvalues[2].toFixed(4)} a.u.
                        </div>
                    </div>
                `;
                document.getElementById('polarizability-eigenvalues').innerHTML = eigenHTML;

                // Create bar chart showing anisotropy
                const trace = {
                    x: ['Œ±‚ÇÅ', 'Œ±‚ÇÇ', 'Œ±‚ÇÉ'],
                    y: pol.eigenvalues,
                    type: 'bar',
                    marker: {
                        color: ['#667eea', '#764ba2', '#28a745']
                    },
                    hovertemplate: 'Component: %{x}<br>Value: %{y:.4f} a.u.<extra></extra>'
                };

                const avgValue = pol.isotropic;
                const avgLine = {
                    x: ['Œ±‚ÇÅ', 'Œ±‚ÇÇ', 'Œ±‚ÇÉ'],
                    y: [avgValue, avgValue, avgValue],
                    mode: 'lines',
                    name: 'Isotropic',
                    line: {color: '#dc3545', width: 2, dash: 'dash'},
                    hovertemplate: 'Isotropic: %{y:.4f} a.u.<extra></extra>'
                };

                const layout = {
                    title: 'Polarizability Principal Components',
                    xaxis: {title: 'Principal Component'},
                    yaxis: {title: 'Polarizability (a.u.)'},
                    showlegend: true,
                    hovermode: 'closest'
                };

                Plotly.newPlot('polarizability-plot', [trace, avgLine], layout, {responsive: true});
            }
        }

        // 10. BOND ORDER COMPARISON
        function renderBondOrderComparison() {
            if (!data || !data.mayer_bond_orders || data.mayer_bond_orders.length === 0) return;

            const mayerOrders = data.mayer_bond_orders;
            const loewdinOrders = data.loewdin_bond_orders || [];

            // Match bonds between both methods
            const bondLabels = [];
            const mayerValues = [];
            const loewdinValues = [];

            mayerOrders.forEach(mayer => {
                const loewdin = loewdinOrders.find(l =>
                    (l.atom1_index === mayer.atom1_index && l.atom2_index === mayer.atom2_index) ||
                    (l.atom1_index === mayer.atom2_index && l.atom2_index === mayer.atom1_index)
                );

                if (mayer.bond_order > 0.1) { // Filter weak bonds
                    const coord1 = data.coordinates[mayer.atom1_index];
                    const coord2 = data.coordinates[mayer.atom2_index];
                    const label = coord1 && coord2 ?
                        `${coord1[0]}${mayer.atom1_index}-${coord2[0]}${mayer.atom2_index}` :
                        `${mayer.atom1_index}-${mayer.atom2_index}`;

                    bondLabels.push(label);
                    mayerValues.push(mayer.bond_order);
                    loewdinValues.push(loewdin ? loewdin.bond_order : 0);
                }
            });

            const trace1 = {
                x: bondLabels,
                y: mayerValues,
                name: 'Mayer',
                type: 'bar',
                marker: {color: '#667eea'},
                hovertemplate: 'Bond: %{x}<br>Mayer: %{y:.3f}<extra></extra>'
            };

            const trace2 = {
                x: bondLabels,
                y: loewdinValues,
                name: 'Loewdin',
                type: 'bar',
                marker: {color: '#764ba2'},
                hovertemplate: 'Bond: %{x}<br>Loewdin: %{y:.3f}<extra></extra>'
            };

            const layout = {
                title: 'Bond Order Comparison: Mayer vs Loewdin',
                xaxis: {title: 'Bond', tickangle: -45},
                yaxis: {title: 'Bond Order'},
                barmode: 'group',
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('bond-order-comparison-plot', [trace1, trace2], layout, {responsive: true});
        }

        // 11. CHARGE COMPARISON
        function renderChargeComparison() {
            if (!data || !data.mulliken_charges || Object.keys(data.mulliken_charges).length === 0) return;
            if (!data.loewdin_charges || Object.keys(data.loewdin_charges).length === 0) return;

            const mullikenCharges = [];
            const loewdinCharges = [];
            const labels = [];

            Object.keys(data.mulliken_charges).forEach(atomIdx => {
                const mulliken = data.mulliken_charges[atomIdx][1];
                const loewdin = data.loewdin_charges[atomIdx] ? data.loewdin_charges[atomIdx][1] : null;

                if (loewdin !== null) {
                    mullikenCharges.push(mulliken);
                    loewdinCharges.push(loewdin);
                    labels.push(`${data.mulliken_charges[atomIdx][0]}${atomIdx}`);
                }
            });

            const trace = {
                x: mullikenCharges,
                y: loewdinCharges,
                mode: 'markers+text',
                marker: {
                    size: 10,
                    color: mullikenCharges,
                    colorscale: 'RdBu',
                    reversescale: true,
                    colorbar: {title: 'Charge'},
                    line: {width: 1, color: 'white'}
                },
                text: labels,
                textposition: 'top center',
                hovertemplate: 'Atom: %{text}<br>Mulliken: %{x:.3f}<br>Loewdin: %{y:.3f}<extra></extra>'
            };

            // Diagonal line (perfect agreement)
            const minCharge = Math.min(...mullikenCharges, ...loewdinCharges);
            const maxCharge = Math.max(...mullikenCharges, ...loewdinCharges);
            const diagonalTrace = {
                x: [minCharge, maxCharge],
                y: [minCharge, maxCharge],
                mode: 'lines',
                name: 'Perfect Agreement',
                line: {color: '#dc3545', width: 2, dash: 'dash'},
                hoverinfo: 'skip',
                showlegend: true
            };

            const layout = {
                title: 'Mulliken vs Loewdin Atomic Charges',
                xaxis: {title: 'Mulliken Charge'},
                yaxis: {title: 'Loewdin Charge'},
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('charge-comparison-plot', [trace, diagonalTrace], layout, {responsive: true});
        }

        // 12. ENERGY COMPONENTS
        function renderEnergyComponents() {
            if (!data || !data.energy_components) return;

            const ec = data.energy_components;

            const components = [];
            const values = [];
            const colors = [];

            if (ec.nuclear_repulsion !== undefined && ec.nuclear_repulsion !== 0) {
                components.push('Nuclear Repulsion');
                values.push(Math.abs(ec.nuclear_repulsion));
                colors.push('#ff6b6b');
            }
            if (ec.electronic_energy !== undefined && ec.electronic_energy !== 0) {
                components.push('Electronic Energy');
                values.push(Math.abs(ec.electronic_energy));
                colors.push('#4ecdc4');
            }
            if (ec.one_electron !== undefined && ec.one_electron !== 0) {
                components.push('One-Electron');
                values.push(Math.abs(ec.one_electron));
                colors.push('#667eea');
            }
            if (ec.two_electron !== undefined && ec.two_electron !== 0) {
                components.push('Two-Electron');
                values.push(Math.abs(ec.two_electron));
                colors.push('#764ba2');
            }
            if (ec.exchange_correlation !== undefined && ec.exchange_correlation !== 0) {
                components.push('Exchange-Correlation');
                values.push(Math.abs(ec.exchange_correlation));
                colors.push('#28a745');
            }

            if (components.length === 0) return;

            const trace = {
                labels: components,
                values: values,
                type: 'pie',
                marker: {colors: colors},
                hovertemplate: '%{label}<br>|Energy|: %{value:.4f} Eh<br>%{percent}<extra></extra>'
            };

            const layout = {
                title: 'Energy Components Breakdown (Absolute Values)',
                showlegend: true,
                height: 400
            };

            Plotly.newPlot('energy-components-plot', [trace], layout, {responsive: true});

            // Display details
            let detailsHTML = '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">';
            if (ec.nuclear_repulsion !== undefined) detailsHTML += `<div><strong>Nuclear Repulsion:</strong> ${ec.nuclear_repulsion.toFixed(6)} Eh</div>`;
            if (ec.electronic_energy !== undefined) detailsHTML += `<div><strong>Electronic Energy:</strong> ${ec.electronic_energy.toFixed(6)} Eh</div>`;
            if (ec.one_electron !== undefined) detailsHTML += `<div><strong>One-Electron:</strong> ${ec.one_electron.toFixed(6)} Eh</div>`;
            if (ec.two_electron !== undefined) detailsHTML += `<div><strong>Two-Electron:</strong> ${ec.two_electron.toFixed(6)} Eh</div>`;
            if (ec.exchange_correlation !== undefined) detailsHTML += `<div><strong>Exchange-Correlation:</strong> ${ec.exchange_correlation.toFixed(6)} Eh</div>`;
            detailsHTML += '</div>';
            document.getElementById('energy-components-details').innerHTML = detailsHTML;
        }

        // 13. DISPERSION CORRECTION
        function renderDispersionCorrection() {
            if (!data || !data.dispersion_correction) return;

            const disp = data.dispersion_correction;

            const trace = {
                x: ['E6 (C6)', 'E8 (C8)', 'Total'],
                y: [disp.e6 || 0, disp.e8 || 0, disp.total || 0],
                type: 'bar',
                marker: {
                    color: ['#667eea', '#764ba2', '#28a745']
                },
                hovertemplate: '%{x}<br>Energy: %{y:.6f} Eh<extra></extra>'
            };

            const layout = {
                title: 'DFTD3 Dispersion Correction',
                xaxis: {title: 'Component'},
                yaxis: {title: 'Energy (Eh)'},
                showlegend: false
            };

            Plotly.newPlot('dispersion-plot', [trace], layout, {responsive: true});

            // Display details
            let detailsHTML = `
                <h4 style="margin-top: 0;">Dispersion Parameters</h4>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <div><strong>E6 (C6):</strong> ${(disp.e6 || 0).toFixed(8)} Eh</div>
                    <div><strong>E8 (C8):</strong> ${(disp.e8 || 0).toFixed(8)} Eh</div>
                    <div><strong>Total:</strong> ${(disp.total || 0).toFixed(8)} Eh</div>
            `;
            if (disp.s6) detailsHTML += `<div><strong>s6 parameter:</strong> ${disp.s6.toFixed(4)}</div>`;
            if (disp.s8) detailsHTML += `<div><strong>s8 parameter:</strong> ${disp.s8.toFixed(4)}</div>`;
            detailsHTML += '</div>';
            document.getElementById('dispersion-details').innerHTML = detailsHTML;
        }

        // 14. ORBITAL POPULATION BY ELEMENT
        function renderOrbitalPopulation() {
            if (!data || !data.mulliken_orbital_populations || data.mulliken_orbital_populations.length === 0) return;

            const populations = data.mulliken_orbital_populations;

            // Group by atom
            const atomLabels = [];
            const sData = [];
            const pData = [];
            const dData = [];
            const fData = [];
            const gData = [];

            populations.forEach(pop => {
                const coord = data.coordinates[pop.atom_index];
                const label = coord ? `${coord[0]}${pop.atom_index}` : `Atom${pop.atom_index}`;
                atomLabels.push(label);

                sData.push(pop.s || 0);
                pData.push(pop.p || 0);
                dData.push(pop.d || 0);
                fData.push(pop.f || 0);
                gData.push(pop.g || 0);
            });

            const traces = [
                {x: atomLabels, y: sData, name: 's', type: 'bar', marker: {color: '#667eea'}},
                {x: atomLabels, y: pData, name: 'p', type: 'bar', marker: {color: '#764ba2'}},
                {x: atomLabels, y: dData, name: 'd', type: 'bar', marker: {color: '#28a745'}},
                {x: atomLabels, y: fData, name: 'f', type: 'bar', marker: {color: '#ffc107'}},
                {x: atomLabels, y: gData, name: 'g', type: 'bar', marker: {color: '#dc3545'}}
            ];

            // Only include traces with non-zero data
            const filteredTraces = traces.filter(t => t.y.some(val => val > 0));

            const layout = {
                title: 'Mulliken Orbital Population by Atom',
                xaxis: {title: 'Atom', tickangle: -45},
                yaxis: {title: 'Population'},
                barmode: 'stack',
                hovermode: 'closest',
                showlegend: true
            };

            if (filteredTraces.length > 0) {
                Plotly.newPlot('orbital-population-plot', filteredTraces, layout, {responsive: true});
            }
        }

        // 15. INTERNAL COORDINATES
        function renderInternalCoordinates() {
            if (!data || !data.internal_coords || data.internal_coords.length === 0) return;

            const coords = data.internal_coords;

            const bondLengths = coords.filter(c => c.bond_length !== undefined && c.bond_length > 0).map(c => c.bond_length);
            const bondAngles = coords.filter(c => c.bond_angle !== undefined && c.bond_angle > 0).map(c => c.bond_angle);
            const dihedrals = coords.filter(c => c.dihedral_angle !== undefined).map(c => c.dihedral_angle);

            const traces = [];

            if (bondLengths.length > 0) {
                traces.push({
                    x: bondLengths,
                    type: 'histogram',
                    name: 'Bond Lengths',
                    marker: {color: '#667eea'},
                    xaxis: 'x',
                    yaxis: 'y',
                    hovertemplate: 'Length: %{x:.3f} √Ö<br>Count: %{y}<extra></extra>'
                });
            }

            if (bondAngles.length > 0) {
                traces.push({
                    x: bondAngles,
                    type: 'histogram',
                    name: 'Bond Angles',
                    marker: {color: '#28a745'},
                    xaxis: 'x2',
                    yaxis: 'y2',
                    hovertemplate: 'Angle: %{x:.2f}¬∞<br>Count: %{y}<extra></extra>'
                });
            }

            const layout = {
                title: 'Internal Coordinates Distribution',
                grid: {rows: 1, columns: 2, pattern: 'independent'},
                xaxis: {title: 'Bond Length (√Ö)'},
                yaxis: {title: 'Count'},
                xaxis2: {title: 'Bond Angle (¬∞)'},
                yaxis2: {title: 'Count'},
                showlegend: true
            };

            if (traces.length > 0) {
                Plotly.newPlot('internal-coords-plot', traces, layout, {responsive: true});
            }
        }

        // 16. SCF ITERATION EFFICIENCY
        function renderSCFEfficiency() {
            if (!data || !data.scf_iterations || data.scf_iterations.length < 2) return;

            const iterations = data.scf_iterations;
            const energyReductions = [];
            const iterationNumbers = [];

            for (let i = 1; i < iterations.length; i++) {
                const reduction = iterations[i-1].energy - iterations[i].energy;
                energyReductions.push(reduction);
                iterationNumbers.push(i);
            }

            const trace = {
                x: iterationNumbers,
                y: energyReductions,
                mode: 'lines+markers',
                name: 'Energy Reduction',
                line: {color: '#667eea', width: 3},
                marker: {size: 8, color: '#764ba2'},
                hovertemplate: 'Iteration %{x}<br>ŒîE: %{y:.6e} Eh<extra></extra>'
            };

            const layout = {
                title: 'SCF Iteration Efficiency (Energy Reduction per Step)',
                xaxis: {title: 'Iteration'},
                yaxis: {title: 'Energy Reduction (Eh)', type: 'log'},
                hovermode: 'closest',
                showlegend: false
            };

            Plotly.newPlot('scf-efficiency-plot', [trace], layout, {responsive: true});
        }

        // 17. CPCM SOLVATION ANALYSIS
        function renderSolvationAnalysis() {
            if (!data || !data.cpcm_solvation) return;

            const solv = data.cpcm_solvation;

            const components = [];
            const values = [];
            const colors = ['#667eea', '#764ba2', '#28a745', '#ffc107'];

            if (solv.electrostatic !== undefined && solv.electrostatic !== 0) {
                components.push('Electrostatic');
                values.push(Math.abs(solv.electrostatic));
            }
            if (solv.cavitation !== undefined && solv.cavitation !== 0) {
                components.push('Cavitation');
                values.push(Math.abs(solv.cavitation));
            }
            if (solv.dispersion !== undefined && solv.dispersion !== 0) {
                components.push('Dispersion');
                values.push(Math.abs(solv.dispersion));
            }
            if (solv.repulsion !== undefined && solv.repulsion !== 0) {
                components.push('Repulsion');
                values.push(Math.abs(solv.repulsion));
            }

            if (components.length === 0) return;

            const trace = {
                labels: components,
                values: values,
                type: 'pie',
                marker: {colors: colors.slice(0, components.length)},
                hovertemplate: '%{label}<br>|Energy|: %{value:.6f} Eh<br>%{percent}<extra></extra>'
            };

            const layout = {
                title: 'CPCM Solvation Energy Components',
                showlegend: true
            };

            Plotly.newPlot('solvation-plot', [trace], layout, {responsive: true});

            // Details table
            let detailsHTML = '<h4 style="margin-top: 0;">Solvation Energy Details</h4><div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">';
            if (solv.electrostatic !== undefined) detailsHTML += `<div><strong>Electrostatic:</strong> ${solv.electrostatic.toFixed(6)} Eh</div>`;
            if (solv.cavitation !== undefined) detailsHTML += `<div><strong>Cavitation:</strong> ${solv.cavitation.toFixed(6)} Eh</div>`;
            if (solv.dispersion !== undefined) detailsHTML += `<div><strong>Dispersion:</strong> ${solv.dispersion.toFixed(6)} Eh</div>`;
            if (solv.repulsion !== undefined) detailsHTML += `<div><strong>Repulsion:</strong> ${solv.repulsion.toFixed(6)} Eh</div>`;
            if (solv.total_solvation_energy !== undefined) detailsHTML += `<div><strong>Total:</strong> ${solv.total_solvation_energy.toFixed(6)} Eh</div>`;
            detailsHTML += '</div>';
            document.getElementById('solvation-details').innerHTML = detailsHTML;
        }

        // 18. ORBITAL ENERGY DISTRIBUTION
        function renderOrbitalDistribution() {
            if (!data || !data.orbital_energies || data.orbital_energies.length === 0) return;

            const energies = data.orbital_energies.map(o => o.energy_ev);

            const trace = {
                x: energies,
                type: 'histogram',
                nbinsx: 30,
                marker: {
                    color: '#667eea',
                    line: {color: 'white', width: 1}
                },
                hovertemplate: 'Energy: %{x:.2f} eV<br>Count: %{y}<extra></extra>'
            };

            const layout = {
                title: 'Orbital Energy Distribution',
                xaxis: {title: 'Energy (eV)'},
                yaxis: {title: 'Number of Orbitals'},
                showlegend: false
            };

            Plotly.newPlot('orbital-distribution-plot', [trace], layout, {responsive: true});
        }

        // 19. FREQUENCY ANALYSIS BY TYPE
        function renderFrequencyAnalysis() {
            if (!data || !data.frequencies || data.frequencies.length === 0) return;

            const frequencies = data.frequencies;
            const irSpectrum = data.ir_spectrum || [];
            const ramanSpectrum = data.raman_spectrum || [];

            // Categorize frequencies
            const low = [], mid = [], high = [];
            const lowIR = [], midIR = [], highIR = [];

            frequencies.forEach((freq, i) => {
                const intensity = irSpectrum[i] ? irSpectrum[i].intensity : 0;
                if (freq < 1000) {
                    low.push(freq);
                    lowIR.push(intensity);
                } else if (freq < 2000) {
                    mid.push(freq);
                    midIR.push(intensity);
                } else {
                    high.push(freq);
                    highIR.push(intensity);
                }
            });

            const trace1 = {
                x: ['Low (<1000)', 'Mid (1000-2000)', 'High (>2000)'],
                y: [low.length, mid.length, high.length],
                name: 'Mode Count',
                type: 'bar',
                marker: {color: '#667eea'},
                hovertemplate: 'Range: %{x}<br>Modes: %{y}<extra></extra>'
            };

            const avgLowIR = low.length > 0 ? lowIR.reduce((a,b) => a+b, 0) / low.length : 0;
            const avgMidIR = mid.length > 0 ? midIR.reduce((a,b) => a+b, 0) / mid.length : 0;
            const avgHighIR = high.length > 0 ? highIR.reduce((a,b) => a+b, 0) / high.length : 0;

            const trace2 = {
                x: ['Low (<1000)', 'Mid (1000-2000)', 'High (>2000)'],
                y: [avgLowIR, avgMidIR, avgHighIR],
                name: 'Avg IR Intensity',
                type: 'bar',
                marker: {color: '#28a745'},
                yaxis: 'y2',
                hovertemplate: 'Range: %{x}<br>Avg IR: %{y:.2f} km/mol<extra></extra>'
            };

            const layout = {
                title: 'Frequency Analysis by Energy Range',
                xaxis: {title: 'Frequency Range (cm‚Åª¬π)'},
                yaxis: {title: 'Number of Modes'},
                yaxis2: {title: 'Avg IR Intensity (km/mol)', overlaying: 'y', side: 'right'},
                showlegend: true,
                barmode: 'group'
            };

            Plotly.newPlot('frequency-analysis-plot', [trace1, trace2], layout, {responsive: true});
        }

        // 20. CHARGE DISTRIBUTION PIE
        function renderChargeDistributionPie() {
            if (!data || !data.mulliken_charges || Object.keys(data.mulliken_charges).length === 0) return;

            let positive = 0, negative = 0, neutral = 0;

            Object.values(data.mulliken_charges).forEach(([element, charge]) => {
                if (charge > 0.1) positive++;
                else if (charge < -0.1) negative++;
                else neutral++;
            });

            const trace = {
                labels: ['Positive', 'Neutral', 'Negative'],
                values: [positive, neutral, negative],
                type: 'pie',
                marker: {colors: ['#dc3545', '#ffc107', '#28a745']},
                hovertemplate: '%{label}<br>Count: %{value}<br>%{percent}<extra></extra>'
            };

            const layout = {
                title: 'Atomic Charge Distribution (Mulliken)',
                showlegend: true
            };

            Plotly.newPlot('charge-distribution-plot', [trace], layout, {responsive: true});
        }

        // 21. BOND ORDER VS LENGTH CORRELATION
        function renderBondCorrelation() {
            if (!data || !data.mayer_bond_orders || data.mayer_bond_orders.length === 0) return;
            if (!data.internal_coords || data.internal_coords.length === 0) return;

            const bondOrders = [];
            const bondLengths = [];
            const bondLabels = [];

            data.mayer_bond_orders.forEach(bond => {
                // Find corresponding bond length from internal coords
                const intCoord = data.internal_coords.find(ic =>
                    ic.bond_to === bond.atom1_index || ic.bond_to === bond.atom2_index
                );

                if (intCoord && intCoord.bond_length && bond.bond_order > 0.1) {
                    bondOrders.push(bond.bond_order);
                    bondLengths.push(intCoord.bond_length);
                    const coord1 = data.coordinates[bond.atom1_index];
                    const coord2 = data.coordinates[bond.atom2_index];
                    const label = coord1 && coord2 ?
                        `${coord1[0]}${bond.atom1_index}-${coord2[0]}${bond.atom2_index}` :
                        `${bond.atom1_index}-${bond.atom2_index}`;
                    bondLabels.push(label);
                }
            });

            if (bondOrders.length === 0) return;

            const trace = {
                x: bondLengths,
                y: bondOrders,
                mode: 'markers',
                marker: {
                    size: 10,
                    color: bondOrders,
                    colorscale: 'Viridis',
                    colorbar: {title: 'Bond Order'},
                    line: {width: 1, color: 'white'}
                },
                text: bondLabels,
                hovertemplate: 'Bond: %{text}<br>Length: %{x:.3f} √Ö<br>Order: %{y:.3f}<extra></extra>'
            };

            const layout = {
                title: 'Bond Order vs Bond Length Correlation',
                xaxis: {title: 'Bond Length (√Ö)'},
                yaxis: {title: 'Bond Order (Mayer)'},
                hovermode: 'closest'
            };

            Plotly.newPlot('bond-correlation-plot', [trace], layout, {responsive: true});
        }

        // 22. ORBITAL EIGENVALUE SPECTRUM
        function renderEigenvalueSpectrum() {
            if (!data || !data.orbital_energies || data.orbital_energies.length === 0) return;

            const orbitals = data.orbital_energies;
            const homoIndex = orbitals.findIndex(o => o.occupation <= 0.5) - 1;

            const energies = orbitals.map(o => o.energy_ev);
            const indices = orbitals.map((o, i) => i);
            const colors = orbitals.map((o, i) =>
                i === homoIndex ? '#dc3545' :
                i === homoIndex + 1 ? '#28a745' :
                o.occupation > 0.5 ? '#667eea' : '#ffc107'
            );

            const trace = {
                x: energies,
                y: indices,
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: colors,
                    line: {width: 0.5, color: 'white'}
                },
                hovertemplate: 'MO %{y}<br>Energy: %{x:.3f} eV<br>Occ: %{customdata:.1f}<extra></extra>',
                customdata: orbitals.map(o => o.occupation)
            };

            const layout = {
                title: 'Orbital Eigenvalue Spectrum',
                xaxis: {title: 'Energy (eV)'},
                yaxis: {title: 'Molecular Orbital Index', autorange: 'reversed'},
                height: Math.min(800, orbitals.length * 3 + 100),
                showlegend: false,
                annotations: homoIndex >= 0 ? [{
                    x: orbitals[homoIndex].energy_ev,
                    y: homoIndex,
                    text: 'HOMO',
                    showarrow: true,
                    arrowhead: 2
                }, {
                    x: orbitals[homoIndex + 1].energy_ev,
                    y: homoIndex + 1,
                    text: 'LUMO',
                    showarrow: true,
                    arrowhead: 2
                }] : []
            };

            Plotly.newPlot('eigenvalue-spectrum-plot', [trace], layout, {responsive: true});
        }

        // 23. IR VS RAMAN CORRELATION
        function renderIRRamanCorrelation() {
            if (!data || !data.ir_spectrum || data.ir_spectrum.length === 0) return;
            if (!data.raman_spectrum || data.raman_spectrum.length === 0) return;

            const irIntensities = [];
            const ramanActivities = [];
            const frequencies = [];

            data.ir_spectrum.forEach((ir, i) => {
                const raman = data.raman_spectrum[i];
                if (raman) {
                    irIntensities.push(ir.intensity);
                    ramanActivities.push(raman.activity);
                    frequencies.push(data.frequencies[i] || i);
                }
            });

            const trace = {
                x: irIntensities,
                y: ramanActivities,
                mode: 'markers',
                marker: {
                    size: 8,
                    color: frequencies,
                    colorscale: 'Jet',
                    colorbar: {title: 'Frequency (cm‚Åª¬π)'},
                    line: {width: 1, color: 'white'}
                },
                text: frequencies.map(f => `${f.toFixed(1)} cm‚Åª¬π`),
                hovertemplate: 'Frequency: %{text}<br>IR: %{x:.2f} km/mol<br>Raman: %{y:.2f}<extra></extra>'
            };

            const layout = {
                title: 'IR vs Raman Activity Correlation',
                xaxis: {title: 'IR Intensity (km/mol)', type: 'log'},
                yaxis: {title: 'Raman Activity', type: 'log'},
                hovermode: 'closest'
            };

            Plotly.newPlot('ir-raman-correlation-plot', [trace], layout, {responsive: true});
        }

        // 24. ATOMIC MASS DISTRIBUTION
        function renderMassDistribution() {
            if (!data || !data.coordinates_au || data.coordinates_au.length === 0) return;

            // Group by element
            const elementMasses = {};
            data.coordinates_au.forEach(coord => {
                const element = coord[0]; // element symbol
                const mass = coord[5];    // atomic mass
                if (!elementMasses[element]) {
                    elementMasses[element] = 0;
                }
                elementMasses[element] += mass;
            });

            const elements = Object.keys(elementMasses).sort();
            const masses = elements.map(e => elementMasses[e]);

            const trace = {
                x: elements,
                y: masses,
                type: 'bar',
                marker: {
                    color: masses,
                    colorscale: 'Viridis',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Element: %{x}<br>Total Mass: %{y:.2f} amu<extra></extra>'
            };

            const layout = {
                title: 'Atomic Mass Distribution by Element',
                xaxis: {title: 'Element'},
                yaxis: {title: 'Total Mass (amu)'},
                showlegend: false
            };

            Plotly.newPlot('mass-distribution-plot', [trace], layout, {responsive: true});
        }

        function renderDipoleComponents() {
            if (!data || !data.dipole_moment_components || data.dipole_moment_components.length === 0) return;

            const labels = ['X', 'Y', 'Z'];
            const values = data.dipole_moment_components.slice(0, 3); // X, Y, Z components
            const magnitude = Math.sqrt(values.reduce((sum, v) => sum + v*v, 0));

            const trace = {
                x: labels,
                y: values,
                type: 'bar',
                marker: {
                    color: ['#FF6B6B', '#4ECDC4', '#45B7D1'],
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Component %{x}<br>Value: %{y:.4f} Debye<extra></extra>'
            };

            const layout = {
                title: `Dipole Moment Components (Total: ${magnitude.toFixed(4)} Debye)`,
                xaxis: {title: 'Component'},
                yaxis: {title: 'Dipole Moment (Debye)'},
                showlegend: false
            };

            Plotly.newPlot('dipole-components-plot', [trace], layout, {responsive: true});
        }

        function renderThermoBreakdown() {
            if (!data || !data.thermochemistry) return;

            const thermo = data.thermochemistry;
            const categories = [];
            const values = [];

            if (thermo.zero_point_energy !== null) {
                categories.push('Zero-Point Energy');
                values.push(thermo.zero_point_energy);
            }
            if (thermo.thermal_correction_energy !== null) {
                categories.push('Thermal Correction (E)');
                values.push(thermo.thermal_correction_energy);
            }
            if (thermo.thermal_correction_enthalpy !== null) {
                categories.push('Thermal Correction (H)');
                values.push(thermo.thermal_correction_enthalpy);
            }
            if (thermo.thermal_correction_gibbs !== null) {
                categories.push('Thermal Correction (G)');
                values.push(thermo.thermal_correction_gibbs);
            }

            if (categories.length === 0) return;

            const trace = {
                x: categories,
                y: values,
                type: 'bar',
                marker: {
                    color: values,
                    colorscale: 'Portland',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: '%{x}<br>Energy: %{y:.6f} Eh<extra></extra>'
            };

            const layout = {
                title: 'Thermochemistry Energy Components',
                xaxis: {title: 'Component', tickangle: -45},
                yaxis: {title: 'Energy (Eh)'},
                showlegend: false,
                margin: {b: 120}
            };

            Plotly.newPlot('thermo-breakdown-plot', [trace], layout, {responsive: true});
        }

        function renderAtomStats() {
            if (!data || !data.coordinates_au || data.coordinates_au.length === 0) return;

            // Count atoms by element
            const elementCounts = {};
            data.coordinates_au.forEach(coord => {
                const element = coord[0];
                elementCounts[element] = (elementCounts[element] || 0) + 1;
            });

            const elements = Object.keys(elementCounts).sort();
            const counts = elements.map(e => elementCounts[e]);

            const trace = {
                x: elements,
                y: counts,
                type: 'bar',
                marker: {
                    color: counts,
                    colorscale: 'Viridis',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Element: %{x}<br>Count: %{y}<extra></extra>'
            };

            const layout = {
                title: 'Atom Type Statistics',
                xaxis: {title: 'Element'},
                yaxis: {title: 'Count'},
                showlegend: false
            };

            Plotly.newPlot('atom-stats-plot', [trace], layout, {responsive: true});
        }

        function renderAngleDistribution() {
            if (!data || !data.coordinates_au || data.coordinates_au.length < 3) return;

            // Calculate all bond angles
            const coords = data.coordinates_au;
            const angles = [];

            // Helper to calculate angle between three points
            const calculateAngle = (p1, p2, p3) => {
                const v1 = [p1[1] - p2[1], p1[2] - p2[2], p1[3] - p2[3]];
                const v2 = [p3[1] - p2[1], p3[2] - p2[2], p3[3] - p2[3]];

                const dot = v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
                const mag1 = Math.sqrt(v1[0]**2 + v1[1]**2 + v1[2]**2);
                const mag2 = Math.sqrt(v2[0]**2 + v2[1]**2 + v2[2]**2);

                return Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
            };

            // Sample angles to avoid too many calculations
            const maxAngles = 1000;
            const step = Math.max(1, Math.floor(coords.length / 10));

            for (let i = 0; i < coords.length && angles.length < maxAngles; i += step) {
                for (let j = i + 1; j < coords.length && angles.length < maxAngles; j += step) {
                    for (let k = j + 1; k < coords.length && angles.length < maxAngles; k += step) {
                        const angle = calculateAngle(coords[i], coords[j], coords[k]);
                        if (!isNaN(angle)) angles.push(angle);
                    }
                }
            }

            if (angles.length === 0) return;

            const trace = {
                x: angles,
                type: 'histogram',
                nbinsx: 36,
                marker: {
                    color: '#667eea',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Angle: %{x:.1f}¬∞<br>Count: %{y}<extra></extra>'
            };

            const layout = {
                title: 'Bond Angle Distribution',
                xaxis: {title: 'Angle (degrees)'},
                yaxis: {title: 'Frequency'},
                showlegend: false
            };

            Plotly.newPlot('angle-distribution-plot', [trace], layout, {responsive: true});
        }

        function renderElementComposition() {
            if (!data || !data.coordinates_au || data.coordinates_au.length === 0) return;

            // Count atoms by element
            const elementCounts = {};
            data.coordinates_au.forEach(coord => {
                const element = coord[0];
                elementCounts[element] = (elementCounts[element] || 0) + 1;
            });

            const elements = Object.keys(elementCounts).sort();
            const counts = elements.map(e => elementCounts[e]);

            const trace = {
                labels: elements,
                values: counts,
                type: 'pie',
                marker: {
                    colors: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'],
                    line: {width: 2, color: 'white'}
                },
                hovertemplate: '%{label}<br>Count: %{value}<br>Percentage: %{percent}<extra></extra>',
                textinfo: 'label+percent'
            };

            const layout = {
                title: 'Molecular Element Composition',
                showlegend: true
            };

            Plotly.newPlot('element-composition-plot', [trace], layout, {responsive: true});
        }

        function renderOptConvergence() {
            if (!data || !data.opt_energies || data.opt_energies.length === 0) return;

            const iterations = Array.from({length: data.opt_energies.length}, (_, i) => i + 1);

            // Energy trace
            const energyTrace = {
                x: iterations,
                y: data.opt_energies,
                mode: 'lines+markers',
                name: 'Energy',
                yaxis: 'y1',
                line: {color: '#667eea', width: 2},
                marker: {size: 6},
                hovertemplate: 'Iteration: %{x}<br>Energy: %{y:.6f} Eh<extra></extra>'
            };

            // Gradient norm trace (if available)
            const traces = [energyTrace];
            const layout = {
                title: 'Optimization Convergence Metrics',
                xaxis: {title: 'Optimization Step'},
                yaxis: {title: 'Energy (Eh)', side: 'left'},
                showlegend: true,
                hovermode: 'x unified'
            };

            // Add gradient if available
            if (data.opt_gradients && data.opt_gradients.length > 0) {
                const gradTrace = {
                    x: iterations.slice(0, data.opt_gradients.length),
                    y: data.opt_gradients,
                    mode: 'lines+markers',
                    name: 'Gradient Norm',
                    yaxis: 'y2',
                    line: {color: '#e74c3c', width: 2},
                    marker: {size: 6},
                    hovertemplate: 'Iteration: %{x}<br>Gradient: %{y:.4e}<extra></extra>'
                };
                traces.push(gradTrace);
                layout.yaxis2 = {
                    title: 'Gradient Norm',
                    overlaying: 'y',
                    side: 'right'
                };
            }

            Plotly.newPlot('opt-convergence-plot', traces, layout, {responsive: true});
        }

        function renderPopulationCorrelation() {
            if (!data || !data.mulliken_charges || !data.loewdin_charges) return;
            if (data.mulliken_charges.length === 0 || data.loewdin_charges.length === 0) return;

            const minLen = Math.min(data.mulliken_charges.length, data.loewdin_charges.length);
            const mulliken = data.mulliken_charges.slice(0, minLen);
            const loewdin = data.loewdin_charges.slice(0, minLen);

            const trace = {
                x: mulliken,
                y: loewdin,
                mode: 'markers',
                type: 'scatter',
                marker: {
                    size: 8,
                    color: mulliken,
                    colorscale: 'RdBu',
                    colorbar: {title: 'Mulliken'},
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Mulliken: %{x:.4f}<br>L√∂wdin: %{y:.4f}<extra></extra>'
            };

            // Add diagonal line
            const min = Math.min(...mulliken, ...loewdin);
            const max = Math.max(...mulliken, ...loewdin);
            const diagonalTrace = {
                x: [min, max],
                y: [min, max],
                mode: 'lines',
                line: {color: 'gray', dash: 'dash'},
                showlegend: false,
                hoverinfo: 'skip'
            };

            const layout = {
                title: 'Mulliken vs L√∂wdin Population Analysis',
                xaxis: {title: 'Mulliken Charges'},
                yaxis: {title: 'L√∂wdin Charges'},
                showlegend: false
            };

            Plotly.newPlot('population-correlation-plot', [trace, diagonalTrace], layout, {responsive: true});
        }

        function renderDistanceAnalysis() {
            if (!data || !data.coordinates_au || data.coordinates_au.length < 2) return;

            const coords = data.coordinates_au;
            const distances = [];

            // Calculate all pairwise distances
            for (let i = 0; i < coords.length; i++) {
                for (let j = i + 1; j < coords.length; j++) {
                    const dx = coords[i][1] - coords[j][1];
                    const dy = coords[i][2] - coords[j][2];
                    const dz = coords[i][3] - coords[j][3];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) * 0.529177; // Convert to Angstroms
                    distances.push(dist);
                }
            }

            const trace = {
                x: distances,
                type: 'histogram',
                nbinsx: 50,
                marker: {
                    color: '#45B7D1',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Distance: %{x:.2f} √Ö<br>Count: %{y}<extra></extra>'
            };

            const layout = {
                title: 'Interatomic Distance Distribution',
                xaxis: {title: 'Distance (√Ö)'},
                yaxis: {title: 'Frequency'},
                showlegend: false
            };

            Plotly.newPlot('distance-analysis-plot', [trace], layout, {responsive: true});
        }

        function renderCoordinationNumbers() {
            if (!data || !data.coordinates_au || data.coordinates_au.length < 2) return;

            const coords = data.coordinates_au;
            const cutoff = 3.5; // Angstrom cutoff for coordination
            const coordinationNumbers = [];

            // Calculate coordination number for each atom
            for (let i = 0; i < coords.length; i++) {
                let neighbors = 0;
                for (let j = 0; j < coords.length; j++) {
                    if (i === j) continue;
                    const dx = coords[i][1] - coords[j][1];
                    const dy = coords[i][2] - coords[j][2];
                    const dz = coords[i][3] - coords[j][3];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) * 0.529177; // Convert to Angstroms
                    if (dist < cutoff) neighbors++;
                }
                coordinationNumbers.push(neighbors);
            }

            const labels = coords.map((c, i) => `${c[0]}${i+1}`);

            const trace = {
                x: labels,
                y: coordinationNumbers,
                type: 'bar',
                marker: {
                    color: coordinationNumbers,
                    colorscale: 'Viridis',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Atom: %{x}<br>Coordination #: %{y}<extra></extra>'
            };

            const layout = {
                title: `Coordination Numbers (cutoff: ${cutoff} √Ö)`,
                xaxis: {title: 'Atom', tickangle: -45},
                yaxis: {title: 'Coordination Number'},
                showlegend: false,
                margin: {b: 100}
            };

            Plotly.newPlot('coordination-plot', [trace], layout, {responsive: true});
        }
    </script>
</body>
</html>
