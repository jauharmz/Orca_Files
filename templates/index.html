<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORCA Output Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-gradient-start: #667eea;
            --bg-gradient-end: #764ba2;
            --container-bg: white;
            --text-color: #333;
            --text-secondary: #666;
            --border-color: #e0e0e0;
            --card-bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --tab-bg: #f8f9fa;
            --tab-hover: #e9ecef;
            --input-bg: white;
            --table-bg: white;
        }

        body.dark-mode {
            --bg-gradient-start: #1a1a2e;
            --bg-gradient-end: #16213e;
            --container-bg: #0f1419;
            --text-color: #e4e4e7;
            --text-secondary: #a1a1aa;
            --border-color: #27272a;
            --card-bg: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            --tab-bg: #18181b;
            --tab-hover: #27272a;
            --input-bg: #18181b;
            --table-bg: #18181b;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-color);
            transition: background 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--container-bg);
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            transition: background 0.3s ease;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .controls {
            padding: 20px 30px;
            background: var(--tab-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 15px;
            align-items: center;
            transition: background 0.3s ease;
        }

        button {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .status {
            flex: 1;
            text-align: right;
            color: #666;
            font-size: 14px;
        }

        .status.success {
            color: #28a745;
            font-weight: 600;
        }

        .progress-container {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
            display: none;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
            animation: progressShine 1.5s infinite;
        }

        @keyframes progressShine {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .dark-mode-toggle {
            padding: 8px 12px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }

        .dark-mode-toggle:hover {
            background: #e9ecef;
        }

        .table-controls {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .table-search {
            flex: 1;
            min-width: 200px;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .table-search:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn-export-table {
            padding: 8px 16px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn-export-table:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .file-tabs {
            display: flex;
            gap: 5px;
            padding: 10px 15px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            overflow-x: auto;
        }

        .file-tab {
            padding: 8px 16px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
            transition: all 0.3s;
            position: relative;
        }

        .file-tab:hover {
            background: #f8f9fa;
        }

        .file-tab.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .file-tab .close-tab {
            margin-left: 8px;
            color: #999;
            font-weight: bold;
            cursor: pointer;
        }

        .file-tab.active .close-tab {
            color: white;
        }

        .tabs {
            display: flex;
            background: var(--tab-bg);
            border-bottom: 2px solid var(--border-color);
            overflow-x: auto;
            transition: background 0.3s ease;
        }

        .tab {
            padding: 15px 25px;
            cursor: pointer;
            border: none;
            background: transparent;
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }

        .tab:hover {
            background: var(--tab-hover);
            color: var(--text-color);
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: var(--container-bg);
        }

        .tab-content {
            display: none;
            padding: 30px;
            background: var(--container-bg);
            transition: background 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: var(--card-bg);
            color: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: background 0.3s ease;
        }

        .card h3 {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card .value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .card .label {
            font-size: 0.85em;
            opacity: 0.8;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: var(--table-bg);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
            transition: background 0.3s ease;
        }

        thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            color: var(--text-color);
            border-bottom: 1px solid var(--border-color);
        }

        tbody tr:nth-child(even) {
            background: var(--tab-bg);
        }

        tbody tr:hover {
            background: var(--tab-hover);
        }

        .section-title {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: var(--text-color);
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
            transition: color 0.3s ease;
        }

        .info-box {
            background: var(--tab-bg);
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        .info-box h4 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .progress {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            transition: width 0.5s;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .json-viewer {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            max-height: 600px;
            overflow-y: auto;
        }

        .molecular-structure {
            text-align: center;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 20px 0;
        }

        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* File upload styles */
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9fa;
        }

        .upload-area:hover {
            border-color: #5568d3;
            background: #e7f1ff;
        }

        .upload-area.dragover {
            border-color: #5568d3;
            background: #e7f1ff;
            transform: scale(1.02);
        }

        input[type="file"] {
            display: none;
        }

        /* Visualization container */
        .viz-container {
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #molecule-viewer {
            width: 100%;
            height: 500px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
        }

        /* Collapsible sections */
        .collapsible {
            cursor: pointer;
            padding: 15px;
            background: #f8f9fa;
            border: none;
            text-align: left;
            width: 100%;
            font-size: 16px;
            font-weight: 600;
            border-radius: 6px;
            margin-top: 10px;
            transition: all 0.3s;
        }

        .collapsible:hover {
            background: #e7f1ff;
        }

        .collapsible.active {
            background: #667eea;
            color: white;
        }

        .collapsible:after {
            content: '\002B';  /* + symbol */
            float: right;
            font-weight: bold;
        }

        .collapsible.active:after {
            content: "\2212";  /* - symbol */
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: white;
        }

        .collapsible-content.active {
            max-height: 2000px;
            padding: 15px;
        }

        /* Export buttons */
        .export-buttons {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .btn-export {
            padding: 8px 16px;
            font-size: 12px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .btn-export:hover {
            background: #218838;
        }
    </style>

    <!-- 3Dmol.js for 3D molecular visualization -->
    <script src="https://3Dmol.csb.pitt.edu/build/3Dmol-min.js"></script>

    <!-- Plotly.js for interactive charts -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß™ ORCA Output Viewer</h1>
            <p>Comprehensive Quantum Chemistry Data Visualization</p>
            <p style="margin-top: 10px; font-size: 0.9em;">38/57 sections parsed (67% coverage) | 71 Interactive Visualizations</p>
        </header>

        <div class="controls">
            <div class="upload-area" id="uploadArea" onclick="document.getElementById('fileInput').click()">
                <input type="file" id="fileInput" accept=".out,.txt" multiple onchange="uploadFile(event)">
                <p>üì§ <strong>Upload ORCA Output File(s)</strong></p>
                <p style="font-size: 12px; margin-top: 5px;">Drag & drop or click to browse (.out, .txt) - Multiple files supported</p>
            </div>
            <div style="display: flex; gap: 10px; flex: 1; align-items: center; flex-wrap: wrap;">
                <button class="btn-primary" onclick="loadDefaultData()">üìÇ Load Example</button>
                <button class="btn-secondary" onclick="exportJSON()">üíæ Export JSON</button>
                <button class="btn-secondary" onclick="generateEnhancedPDF()">üìÑ Enhanced PDF</button>
                <button class="btn-secondary" onclick="exportToLaTeX()">üìú LaTeX</button>
                <button class="btn-secondary" onclick="shareFullDataset()">üåê Share Dataset</button>
                <button class="btn-secondary" onclick="exportJupyterNotebook()">üìì Jupyter</button>
                <button class="dark-mode-toggle" onclick="toggleDarkMode()" title="Toggle Dark Mode">üåì</button>
                <select id="fileSelector" onchange="switchFile()" style="padding: 8px; border-radius: 6px; border: 1px solid #ddd; display: none;">
                    <option value="0">File 1</option>
                </select>
                <div style="flex: 1; min-width: 200px;">
                    <div class="status" id="status">Upload a file or load example data</div>
                    <div class="progress-container" id="progressContainer">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- File Tabs (Multiple Files) -->
        <div class="file-tabs" id="fileTabs" style="display: none;"></div>

        <div class="tabs">
            <button class="tab active" onclick="showTab('summary')">üìä Summary</button>
            <button class="tab" onclick="showTab('molecule')">üî¨ 3D Molecule</button>
            <button class="tab" onclick="showTab('plots')">üìà Interactive Plots</button>
            <button class="tab" onclick="showTab('comparison')" id="comparisonTab" style="display: none;">‚öñÔ∏è Comparison</button>
            <button class="tab" onclick="showTab('geometry')">üìç Geometry</button>
            <button class="tab" onclick="showTab('energy')">‚ö° Energy</button>
            <button class="tab" onclick="showTab('orbitals')">üåÄ Orbitals</button>
            <button class="tab" onclick="showTab('vibrations')">üéµ Vibrations</button>
            <button class="tab" onclick="showTab('nmr')">üß≤ NMR</button>
            <button class="tab" onclick="showTab('population')">üë• Population</button>
            <button class="tab" onclick="showTab('raw')">üìÑ Raw JSON</button>
        </div>

        <!-- Summary Tab -->
        <div id="summary" class="tab-content active">
            <h2 class="section-title">Summary Overview</h2>
            <div id="summary-content">
                <p class="loading">Click "Load Data" to parse ORCA output file</p>
            </div>
        </div>

        <!-- Comparison Tab -->
        <div id="comparison" class="tab-content">
            <h2 class="section-title">‚öñÔ∏è Multi-File Comparison</h2>
            <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                <p style="margin-bottom: 10px;"><strong>Compare Files:</strong></p>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <select id="compareFile1" style="padding: 8px; border-radius: 6px; border: 1px solid #ddd;">
                        <option value="0">File 1</option>
                    </select>
                    <span style="padding: 8px;">vs</span>
                    <select id="compareFile2" style="padding: 8px; border-radius: 6px; border: 1px solid #ddd;">
                        <option value="1">File 2</option>
                    </select>
                    <button class="btn-primary" onclick="renderComparison()">üîÑ Compare</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Energy Comparison üìä</button>
            <div class="collapsible-content">
                <div id="comparison-energy-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('comparison-energy-plot', 'energy_comparison.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">SCF Convergence Overlay üìà</button>
            <div class="collapsible-content">
                <div id="comparison-scf-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('comparison-scf-plot', 'scf_comparison.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Charge Difference Map üó∫Ô∏è</button>
            <div class="collapsible-content">
                <div id="comparison-charge-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('comparison-charge-plot', 'charge_difference.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Mulliken charge differences between the two files (File 2 - File 1).
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Side-by-Side Properties üìã</button>
            <div class="collapsible-content">
                <div id="comparison-table" style="overflow-x: auto;"></div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">RMSD & Structure Overlay üîÑ</button>
            <div class="collapsible-content">
                <div id="rmsd-info" style="padding: 15px; background: #f8f9fa; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="margin-bottom: 10px;">Root Mean Square Deviation (RMSD)</h4>
                    <p id="rmsd-value" style="font-size: 1.5em; color: #667eea; font-weight: bold;">--</p>
                    <p style="font-size: 12px; color: #666; margin-top: 5px;">Lower RMSD indicates more similar structures</p>
                </div>
                <div id="structure-overlay-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('structure-overlay-plot', 'structure_overlay.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Energy Level Diagrams Side-by-Side ‚ö°</button>
            <div class="collapsible-content">
                <div id="energy-diagrams-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('energy-diagrams-plot', 'energy_diagrams.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Reaction Coordinate ‚öóÔ∏è</button>
            <div class="collapsible-content">
                <div id="reaction-coordinate-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('reaction-coordinate-plot', 'reaction_coordinate.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Shows energy profile across multiple calculation files. Upload files in order (reactant ‚Üí TS ‚Üí product).
                </p>
            </div>
        </div>

        <!-- 3D Molecule Tab -->
        <div id="molecule" class="tab-content">
            <h2 class="section-title">üî¨ 3D Molecular Structure</h2>
            <div class="viz-container">
                <div id="molecule-viewer"></div>
                <div style="margin-top: 15px;">
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                        <strong>Style:</strong>
                        <button class="btn-secondary" onclick="setMoleculeStyle('stick')">Stick</button>
                        <button class="btn-secondary" onclick="setMoleculeStyle('sphere')">Sphere</button>
                        <button class="btn-secondary" onclick="setMoleculeStyle('cartoon')">Ball & Stick</button>
                        <button class="btn-secondary" onclick="toggleLabels()">Labels</button>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                        <strong>Color By:</strong>
                        <button class="btn-secondary" onclick="setChargeColoring('none')">Element</button>
                        <button class="btn-secondary" onclick="setChargeColoring('mulliken')">Mulliken Charge</button>
                        <button class="btn-secondary" onclick="setChargeColoring('loewdin')">Loewdin Charge</button>
                        <button class="btn-secondary" onclick="toggleDipole()">Dipole Vector</button>
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn-secondary" onclick="toggleBondOrders()">Show Bond Orders</button>
                        <button class="btn-export" onclick="exportMoleculeImage()">üì∑ Export PNG</button>
                    </div>
                    <div id="charge-legend" style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 6px; display: none;">
                        <strong>Charge Scale:</strong>
                        <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                            <span style="color: red;">‚àí1.0 (negative)</span>
                            <div style="flex: 1; height: 20px; background: linear-gradient(to right, red, white, blue); border-radius: 4px;"></div>
                            <span style="color: blue;">+1.0 (positive)</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Interactive Plots Tab -->
        <div id="plots" class="tab-content">
            <h2 class="section-title">üìà Interactive Data Visualization</h2>

            <button class="collapsible" onclick="toggleCollapsible(this)">SCF Convergence Plot</button>
            <div class="collapsible-content">
                <div id="scf-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('scf-plot', 'scf_convergence.png')">üì∑ PNG</button>
                    <button class="btn-export" onclick="exportPlot('scf-plot', 'scf_convergence.svg')">üìÑ SVG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">IR Spectrum</button>
            <div class="collapsible-content">
                <div id="ir-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('ir-plot', 'ir_spectrum.png')">üì∑ PNG</button>
                    <button class="btn-export" onclick="exportPlot('ir-plot', 'ir_spectrum.svg')">üìÑ SVG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Raman Spectrum</button>
            <div class="collapsible-content">
                <div id="raman-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('raman-plot', 'raman_spectrum.png')">üì∑ PNG</button>
                    <button class="btn-export" onclick="exportPlot('raman-plot', 'raman_spectrum.svg')">üìÑ SVG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Thermochemistry Energy Diagram</button>
            <div class="collapsible-content">
                <div id="thermo-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('thermo-plot', 'thermochemistry.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Energy Diagram</button>
            <div class="collapsible-content">
                <div id="orbital-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('orbital-plot', 'orbital_energies.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">NMR Spectrum</button>
            <div class="collapsible-content">
                <div id="nmr-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('nmr-plot', 'nmr_spectrum.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">IR + Raman Overlay ‚ú®</button>
            <div class="collapsible-content">
                <div id="combined-spectrum-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('combined-spectrum-plot', 'ir_raman_combined.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Computation Timing Breakdown ‚è±Ô∏è</button>
            <div class="collapsible-content">
                <div id="timing-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('timing-plot', 'timing_breakdown.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">SCF Convergence Details üî¨</button>
            <div class="collapsible-content">
                <div id="scf-details-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('scf-details-plot', 'scf_details.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Multi-line plot showing energy convergence, density change, and DIIS error
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Basis Set Composition üìö</button>
            <div class="collapsible-content">
                <div id="basis-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('basis-plot', 'basis_composition.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">DFT Grid Statistics üéØ</button>
            <div class="collapsible-content">
                <div id="grid-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('grid-plot', 'grid_statistics.png')">üì∑ PNG</button>
                </div>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Geometry Optimization Trajectory üé¨</button>
            <div class="collapsible-content">
                <div id="opt-trajectory-plot" style="width: 100%; height: 500px;"></div>
                <div style="margin: 15px 0;">
                    <label for="opt-slider"><strong>Geometry Step:</strong> <span id="opt-step-label">1</span></label>
                    <input type="range" id="opt-slider" min="0" max="0" value="0" style="width: 100%;" oninput="updateOptStep(this.value)">
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="btn-secondary" onclick="playOptAnimation()">‚ñ∂Ô∏è Play</button>
                        <button class="btn-secondary" onclick="pauseOptAnimation()">‚è∏Ô∏è Pause</button>
                        <button class="btn-secondary" onclick="resetOptAnimation()">‚èÆÔ∏è Reset</button>
                    </div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('opt-trajectory-plot', 'optimization_trajectory.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Energy vs optimization step. Use slider to view geometry at each step.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Vibrational Mode Animation üéµ</button>
            <div class="collapsible-content">
                <div style="margin-bottom: 15px;">
                    <label for="mode-selector"><strong>Select Vibrational Mode:</strong></label>
                    <select id="mode-selector" onchange="selectVibrationalMode(this.value)" style="width: 100%; padding: 8px; margin-top: 5px;">
                        <option value="">-- Select Mode --</option>
                    </select>
                </div>
                <div id="vib-mode-info" style="padding: 10px; background: #f8f9fa; border-radius: 4px; margin-bottom: 10px; display: none;">
                    <p><strong>Frequency:</strong> <span id="vib-frequency">--</span> cm‚Åª¬π</p>
                    <p><strong>IR Intensity:</strong> <span id="vib-ir-intensity">--</span> km/mol</p>
                    <p><strong>Raman Activity:</strong> <span id="vib-raman-activity">--</span></p>
                </div>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button class="btn-secondary" onclick="playVibAnimation()">‚ñ∂Ô∏è Animate</button>
                    <button class="btn-secondary" onclick="pauseVibAnimation()">‚è∏Ô∏è Pause</button>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <strong>Amplitude:</strong>
                        <input type="range" id="vib-amplitude" min="0.1" max="2.0" step="0.1" value="1.0" style="width: 100px;" oninput="updateVibAmplitude(this.value)">
                        <span id="vib-amp-label">1.0</span>
                    </label>
                </div>
                <p style="font-size: 12px; color: #666;">
                    Select a mode to see atomic displacements. Animation shows normal mode vibration.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Charge Heatmap üå°Ô∏è</button>
            <div class="collapsible-content">
                <div id="orbital-heatmap-plot" style="width: 100%; height: 600px;"></div>
                <div style="display: flex; gap: 10px; margin: 15px 0;">
                    <button class="btn-secondary" onclick="zoomToHOMOLUMO()">üîç Zoom to HOMO-LUMO</button>
                    <button class="btn-secondary" onclick="resetHeatmapZoom()">üîÑ Reset Zoom</button>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <strong>Charge Type:</strong>
                        <select id="heatmap-charge-type" onchange="updateHeatmapChargeType(this.value)">
                            <option value="mulliken">Mulliken</option>
                            <option value="loewdin">Loewdin</option>
                        </select>
                    </label>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('orbital-heatmap-plot', 'orbital_charges_heatmap.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    2D heatmap showing charge contribution of each MO on each atom. Click to highlight.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">NMR J-Coupling Network üîó</button>
            <div class="collapsible-content">
                <div id="jcoupling-network-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('jcoupling-network-plot', 'jcoupling_network.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Network graph showing J-coupling between nuclei. Edge thickness represents coupling strength.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Chemical Shielding Tensors üìä</button>
            <div class="collapsible-content">
                <div id="shielding-tensors-table"></div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Full chemical shielding tensor data for all nuclei. Click rows to expand tensor details.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">HOMO-LUMO Gap Tracker üìâ</button>
            <div class="collapsible-content">
                <div id="homo-lumo-gap-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('homo-lumo-gap-plot', 'homo_lumo_gap.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    HOMO-LUMO energy gap evolution during geometry optimization.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Density of States üìä</button>
            <div class="collapsible-content">
                <div id="dos-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('dos-plot', 'density_of_states.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Density of states with Gaussian broadening. Blue = occupied, Red = virtual.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Mulliken Overlap Network üï∏Ô∏è</button>
            <div class="collapsible-content">
                <div id="overlap-network-plot" style="width: 100%; height: 600px;"></div>
                <div style="display: flex; gap: 10px; margin: 15px 0;">
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <strong>Layout:</strong>
                        <select id="overlap-layout" onchange="updateOverlapLayout(this.value)">
                            <option value="circular">Circular</option>
                            <option value="3d">3D Molecular</option>
                        </select>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <strong>Min Overlap:</strong>
                        <input type="range" id="overlap-threshold" min="0" max="5" step="0.5" value="1.0" style="width: 100px;" oninput="updateOverlapThreshold(this.value)">
                        <span id="overlap-threshold-label">1.0</span>
                    </label>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('overlap-network-plot', 'overlap_network.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Network showing Mulliken overlap charges between atom pairs. Edge thickness = |overlap charge|.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Polarizability Visualization üéØ</button>
            <div class="collapsible-content">
                <div id="polarizability-plot" style="width: 100%; height: 400px;"></div>
                <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <h4 style="margin-top: 0;">Polarizability Tensor</h4>
                    <div id="polarizability-tensor-display"></div>
                    <h4 style="margin-top: 15px;">Eigenvalues (Principal Components)</h4>
                    <div id="polarizability-eigenvalues"></div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('polarizability-plot', 'polarizability.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Static polarizability tensor components and eigenvalues. Bar chart shows anisotropy.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Bond Order Comparison ‚öñÔ∏è</button>
            <div class="collapsible-content">
                <div id="bond-order-comparison-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('bond-order-comparison-plot', 'bond_order_comparison.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Side-by-side comparison of Mayer and Loewdin bond orders. Shows correlation between methods.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Charge Analysis Comparison üìä</button>
            <div class="collapsible-content">
                <div id="charge-comparison-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('charge-comparison-plot', 'charge_comparison.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Mulliken vs Loewdin atomic charges scatter plot. Points on diagonal indicate agreement.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Energy Components Breakdown ‚ö°</button>
            <div class="collapsible-content">
                <div id="energy-components-plot" style="width: 100%; height: 400px;"></div>
                <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <div id="energy-components-details"></div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('energy-components-plot', 'energy_components.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Breakdown of total energy into nuclear, electronic, kinetic, and exchange-correlation components.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Dispersion Correction (DFTD3) üåä</button>
            <div class="collapsible-content">
                <div id="dispersion-plot" style="width: 100%; height: 300px;"></div>
                <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <div id="dispersion-details"></div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('dispersion-plot', 'dispersion.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    DFTD3 dispersion correction showing E6 and E8 contributions.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Population by Element üß™</button>
            <div class="collapsible-content">
                <div id="orbital-population-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('orbital-population-plot', 'orbital_population.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Mulliken orbital population (s, p, d, f, g) breakdown by atom. Stacked bars show orbital character.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Internal Coordinates Distribution üìê</button>
            <div class="collapsible-content">
                <div id="internal-coords-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('internal-coords-plot', 'internal_coordinates.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Distribution of bond lengths and angles in the molecular structure.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">SCF Iteration Efficiency üìâ</button>
            <div class="collapsible-content">
                <div id="scf-efficiency-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('scf-efficiency-plot', 'scf_efficiency.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Energy reduction per SCF iteration. Shows convergence rate and efficiency.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">CPCM Solvation Analysis üíß</button>
            <div class="collapsible-content">
                <div id="solvation-plot" style="width: 100%; height: 400px;"></div>
                <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <div id="solvation-details"></div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('solvation-plot', 'solvation.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    CPCM solvation energy components: electrostatic, cavitation, dispersion, repulsion.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Energy Distribution üìä</button>
            <div class="collapsible-content">
                <div id="orbital-distribution-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('orbital-distribution-plot', 'orbital_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Histogram of orbital energies showing distribution across energy range.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Frequency Analysis by Type üéº</button>
            <div class="collapsible-content">
                <div id="frequency-analysis-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('frequency-analysis-plot', 'frequency_analysis.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Vibrational frequencies categorized by energy range with IR/Raman activity overlay.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Charge Distribution Analysis ü•ß</button>
            <div class="collapsible-content">
                <div id="charge-distribution-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('charge-distribution-plot', 'charge_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Pie chart showing distribution of positive, neutral, and negative charges across atoms.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Bond Order vs Length Correlation üìà</button>
            <div class="collapsible-content">
                <div id="bond-correlation-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('bond-correlation-plot', 'bond_correlation.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Scatter plot showing relationship between bond length and bond order (Mayer).
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Eigenvalue Spectrum üåà</button>
            <div class="collapsible-content">
                <div id="eigenvalue-spectrum-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('eigenvalue-spectrum-plot', 'eigenvalue_spectrum.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    All orbital energies displayed as horizontal bars with HOMO-LUMO gap highlighted.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">IR vs Raman Activity Correlation üî¨</button>
            <div class="collapsible-content">
                <div id="ir-raman-correlation-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('ir-raman-correlation-plot', 'ir_raman_correlation.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Scatter plot comparing IR intensity vs Raman activity for each vibrational mode.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Atomic Mass Distribution üìä</button>
            <div class="collapsible-content">
                <div id="mass-distribution-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('mass-distribution-plot', 'mass_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Bar chart showing atomic mass contribution by element type.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Dipole Moment Components üß≤</button>
            <div class="collapsible-content">
                <div id="dipole-components-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('dipole-components-plot', 'dipole_components.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    3D bar chart showing dipole moment x, y, z components and total magnitude.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Thermochemistry Breakdown üå°Ô∏è</button>
            <div class="collapsible-content">
                <div id="thermo-breakdown-plot" style="width: 100%; height: 400px;"></div>
                <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <div id="thermo-breakdown-details"></div>
                </div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('thermo-breakdown-plot', 'thermo_breakdown.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Detailed breakdown of thermochemical corrections: ZPE, thermal, enthalpy, entropy contributions.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Atom Type Statistics üìà</button>
            <div class="collapsible-content">
                <div id="atom-stats-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('atom-stats-plot', 'atom_statistics.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Count and percentage of each element type in the molecule.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Bond Angle Distribution üìê</button>
            <div class="collapsible-content">
                <div id="angle-distribution-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('angle-distribution-plot', 'angle_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Histogram showing distribution of bond angles with statistics.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Element Composition ü•ß</button>
            <div class="collapsible-content">
                <div id="element-composition-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('element-composition-plot', 'element_composition.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Pie chart showing molecular composition by element count.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Optimization Convergence Metrics üìâ</button>
            <div class="collapsible-content">
                <div id="opt-convergence-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('opt-convergence-plot', 'opt_convergence.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Energy change per optimization step showing convergence rate.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Mulliken Population Correlation üî¨</button>
            <div class="collapsible-content">
                <div id="population-correlation-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('population-correlation-plot', 'population_correlation.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Scatter matrix showing correlations between s, p, d orbital populations.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Interatomic Distance Analysis üìè</button>
            <div class="collapsible-content">
                <div id="distance-analysis-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('distance-analysis-plot', 'distance_analysis.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Histogram of all pairwise interatomic distances.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Coordination Number Analysis üîó</button>
            <div class="collapsible-content">
                <div id="coordination-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('coordination-plot', 'coordination_numbers.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Coordination number (number of nearby atoms within 3.5 √Ö) for each atom.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">SCF Convergence Dashboard üìä</button>
            <div class="collapsible-content">
                <div id="scf-dashboard-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('scf-dashboard-plot', 'scf_convergence_dashboard.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Final SCF convergence criteria: energy change, density change, maximum element.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Energy Decomposition Waterfall üíß</button>
            <div class="collapsible-content">
                <div id="energy-waterfall-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('energy-waterfall-plot', 'energy_waterfall.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Cascading breakdown of total energy into nuclear, electronic, kinetic, and exchange-correlation components.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Computational Performance Dashboard ‚ö°</button>
            <div class="collapsible-content">
                <div id="performance-dashboard-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('performance-dashboard-plot', 'performance_metrics.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Performance metrics: total runtime, SCF iterations per second, time per optimization step.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Memory Usage Tracking üíæ</button>
            <div class="collapsible-content">
                <div id="memory-usage-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('memory-usage-plot', 'memory_usage.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Memory usage breakdown by component: SCF, optimization, integral evaluation, and basis functions. Estimated from calculation parameters.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Energy Gap Landscape üåÑ</button>
            <div class="collapsible-content">
                <div id="orbital-gaps-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('orbital-gaps-plot', 'orbital_gaps.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Energy gaps between consecutive molecular orbitals (eV). HOMO-LUMO gap highlighted.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Vibrational Mode Classification üéµ</button>
            <div class="collapsible-content">
                <div id="mode-classification-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('mode-classification-plot', 'mode_classification.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Vibrational modes grouped by type: bending (<800 cm‚Åª¬π), stretching (800-1800 cm‚Åª¬π), high-frequency (>1800 cm‚Åª¬π).
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">NMR Shift Distribution üß¨</button>
            <div class="collapsible-content">
                <div id="nmr-distribution-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('nmr-distribution-plot', 'nmr_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Box plot distribution of NMR chemical shifts grouped by nucleus type.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Bond Strength Distribution üîó</button>
            <div class="collapsible-content">
                <div id="bond-strength-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('bond-strength-plot', 'bond_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Histogram of Mayer bond order values. Shows distribution of single, double, triple bonds.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Timing Efficiency Breakdown ‚è±Ô∏è</button>
            <div class="collapsible-content">
                <div id="timing-efficiency-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('timing-efficiency-plot', 'timing_efficiency.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Horizontal bar chart showing time spent in each computational module, sorted by duration.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Molecular Properties Summary üìã</button>
            <div class="collapsible-content">
                <div id="properties-summary" style="padding: 20px; background: #f8f9fa; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: #667eea;">Key Molecular Properties</h3>
                    <div id="summary-content" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Summary dashboard with key molecular statistics and calculation metadata.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">MO Composition by Atom üé®</button>
            <div class="collapsible-content">
                <div id="mo-composition-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('mo-composition-plot', 'mo_composition.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Stacked area chart showing orbital character contribution from each atom across all MOs.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Energy Level Diagram üìä</button>
            <div class="collapsible-content">
                <div id="energy-diagram-plot" style="width: 100%; height: 600px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('energy-diagram-plot', 'energy_diagram.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Energy level diagram with occupied and virtual orbitals. HOMO-LUMO transition highlighted.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Property Correlation Matrix üî•</button>
            <div class="collapsible-content">
                <div id="correlation-matrix-plot" style="width: 100%; height: 600px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('correlation-matrix-plot', 'correlation_matrix.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Correlation heatmap between various molecular properties (charges, bond orders, energies).
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Radial Distribution Function üì°</button>
            <div class="collapsible-content">
                <div id="rdf-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('rdf-plot', 'radial_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Radial distribution function g(r) showing probability of finding atoms at distance r.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Geometry Optimization Path 3D üõ§Ô∏è</button>
            <div class="collapsible-content">
                <div id="opt-path-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('opt-path-plot', 'optimization_path.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    3D trajectory showing how energy and gradient evolve during geometry optimization.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Orbital Overlap Matrix üî≤</button>
            <div class="collapsible-content">
                <div id="overlap-matrix-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('overlap-matrix-plot', 'overlap_matrix.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Symmetric heatmap showing orbital overlap charges between all atom pairs.
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Charge Flow Sankey Diagram üåä</button>
            <div class="collapsible-content">
                <div id="charge-flow-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('charge-flow-plot', 'charge_flow.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Sankey diagram showing charge transfer between atoms (based on Mulliken charges).
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Frequency-IR-Raman 3D Surface üåê</button>
            <div class="collapsible-content">
                <div id="freq-3d-plot" style="width: 100%; height: 500px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('freq-3d-plot', 'frequency_3d.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    3D scatter plot: Frequency (x) vs IR Intensity (y) vs Raman Activity (z).
                </p>
            </div>

            <button class="collapsible" onclick="toggleCollapsible(this)">Basis Function Type Distribution üìö</button>
            <div class="collapsible-content">
                <div id="basis-dist-plot" style="width: 100%; height: 400px;"></div>
                <div class="export-buttons">
                    <button class="btn-export" onclick="exportPlot('basis-dist-plot', 'basis_distribution.png')">üì∑ PNG</button>
                </div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Breakdown of basis functions by angular momentum (s, p, d, f) and atom type.
                </p>
            </div>
        </div>

        <!-- Geometry Tab -->
        <div id="geometry" class="tab-content">
            <h2 class="section-title">Molecular Geometry</h2>
            <div id="geometry-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- Energy Tab -->
        <div id="energy" class="tab-content">
            <h2 class="section-title">Energy Data</h2>
            <div id="energy-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- Orbitals Tab -->
        <div id="orbitals" class="tab-content">
            <h2 class="section-title">Molecular Orbitals</h2>
            <div id="orbitals-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- Vibrations Tab -->
        <div id="vibrations" class="tab-content">
            <h2 class="section-title">Vibrational Analysis</h2>
            <div id="vibrations-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- NMR Tab -->
        <div id="nmr" class="tab-content">
            <h2 class="section-title">NMR Spectroscopy</h2>
            <div id="nmr-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- Population Tab -->
        <div id="population" class="tab-content">
            <h2 class="section-title">Population Analysis</h2>
            <div id="population-content">
                <p class="loading">No data loaded</p>
            </div>
        </div>

        <!-- Raw JSON Tab -->
        <div id="raw" class="tab-content">
            <h2 class="section-title">Raw JSON Data</h2>
            <div id="raw-content" class="json-viewer">
                <p>No data loaded</p>
            </div>
        </div>
    </div>

    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        let data = null;
        let allFiles = [];  // Store multiple files
        let currentFileIndex = 0;  // Current file being viewed
        let viewer3d = null;
        let showLabels = false;

        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');

            // Render 3D molecule when tab is shown
            if (tabName === 'molecule' && data) {
                setTimeout(() => render3DMolecule(), 100);
            }
        }

        function setStatus(message, success = false) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = success ? 'status success' : 'status';
        }

        // File upload handlers
        function uploadFile(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;

            // Handle multiple files
            Array.from(files).forEach(file => handleFileUpload(file));
        }

        async function handleFileUpload(file) {
            setStatus(`Uploading ${file.name}...`);
            showProgress(0);
            const formData = new FormData();
            formData.append('file', file);

            try {
                // Simulate progress during upload
                showProgress(30);
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });
                showProgress(60);
                const result = await response.json();
                showProgress(90);

                if (result.success) {
                    allFiles.push({name: file.name, data: result.data});
                    data = result.data;  // Set to latest file
                    currentFileIndex = allFiles.length - 1;

                    setStatus(`‚úì Parsed ${file.name} successfully (${allFiles.length} file(s) loaded)`, true);
                    showProgress(100);
                    setTimeout(hideProgress, 500);

                    updateFileSelector();
                    updateFileTabs();
                    renderAllTabs();

                    // Show comparison tab if multiple files
                    if (allFiles.length > 1) {
                        document.getElementById('comparisonTab').style.display = 'inline-block';
                        updateComparisonSelectors();
                    }
                } else {
                    setStatus(`‚úó Error: ${result.message}`, false);
                    hideProgress();
                }
            } catch (error) {
                setStatus(`‚úó Upload failed: ${error.message}`, false);
                hideProgress();
            }
        }

        // Progress bar functions
        function showProgress(percent) {
            const container = document.getElementById('progressContainer');
            const bar = document.getElementById('progressBar');
            container.style.display = 'block';
            bar.style.width = percent + '%';
        }

        function hideProgress() {
            const container = document.getElementById('progressContainer');
            const bar = document.getElementById('progressBar');
            container.style.display = 'none';
            bar.style.width = '0%';
        }

        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
        }

        // Load dark mode preference on page load
        if (localStorage.getItem('darkMode') === 'enabled') {
            document.body.classList.add('dark-mode');
        }

        // File tabs management
        function updateFileTabs() {
            const fileTabs = document.getElementById('fileTabs');
            if (allFiles.length <= 1) {
                fileTabs.style.display = 'none';
                return;
            }

            fileTabs.style.display = 'flex';
            fileTabs.innerHTML = allFiles.map((file, idx) => `
                <div class="file-tab ${idx === currentFileIndex ? 'active' : ''}" onclick="switchToFileTab(${idx})">
                    ${file.name}
                    <span class="close-tab" onclick="event.stopPropagation(); closeFileTab(${idx})">√ó</span>
                </div>
            `).join('');
        }

        function switchToFileTab(index) {
            currentFileIndex = index;
            data = allFiles[currentFileIndex].data;
            setStatus(`‚úì Viewing ${allFiles[currentFileIndex].name}`, true);
            updateFileTabs();
            updateFileSelector();
            renderAllTabs();
        }

        function closeFileTab(index) {
            if (allFiles.length === 1) return;

            allFiles.splice(index, 1);

            if (currentFileIndex >= allFiles.length) {
                currentFileIndex = allFiles.length - 1;
            }

            data = allFiles[currentFileIndex].data;
            updateFileTabs();
            updateFileSelector();
            updateComparisonSelectors();
            renderAllTabs();
            setStatus(`‚úì File closed. Viewing ${allFiles[currentFileIndex].name}`, true);

            if (allFiles.length <= 1) {
                document.getElementById('comparisonTab').style.display = 'none';
            }
        }

        function updateFileSelector() {
            const selector = document.getElementById('fileSelector');
            if (allFiles.length <= 1) {
                selector.style.display = 'none';
                return;
            }

            selector.style.display = 'inline-block';
            selector.innerHTML = allFiles.map((file, idx) =>
                `<option value="${idx}" ${idx === currentFileIndex ? 'selected' : ''}>${file.name}</option>`
            ).join('');
        }

        function switchFile() {
            const selector = document.getElementById('fileSelector');
            currentFileIndex = parseInt(selector.value);
            data = allFiles[currentFileIndex].data;
            setStatus(`‚úì Switched to ${allFiles[currentFileIndex].name}`, true);
            renderAllTabs();
        }

        function updateComparisonSelectors() {
            const sel1 = document.getElementById('compareFile1');
            const sel2 = document.getElementById('compareFile2');

            const options = allFiles.map((file, idx) =>
                `<option value="${idx}">${file.name}</option>`
            ).join('');

            sel1.innerHTML = options;
            sel2.innerHTML = options;
            sel1.value = '0';
            sel2.value = allFiles.length > 1 ? '1' : '0';
        }

        // Drag and drop
        const uploadArea = document.getElementById('uploadArea');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFileUpload(file);
        });

        async function loadDefaultData() {
            setStatus('Loading example data...');

            try {
                const response = await fetch('/api/parse', { method: 'POST' });
                const result = await response.json();

                if (result.success) {
                    data = result.data;
                    setStatus('‚úì Example data loaded successfully', true);
                    renderAllTabs();
                } else {
                    setStatus('‚úó Error: ' + result.message);
                }
            } catch (error) {
                setStatus('‚úó Error: ' + error.message);
            }
        }

        function renderAllTabs() {
            renderSummary();
            renderGeometry();
            renderEnergy();
            renderOrbitals();
            renderVibrations();
            renderNMR();
            renderPopulation();
            renderRawJSON();
            // Visualization tabs - rendered on demand when tab is shown
            renderAllPlots();
        }

        function renderSummary() {
            if (!data) return;

            const content = `
                <div class="summary-grid">
                    <div class="card">
                        <h3>Basis Set</h3>
                        <div class="value">${data.job_info.basis_set}</div>
                        <div class="label">${data.job_info.num_electrons} electrons</div>
                    </div>
                    <div class="card">
                        <h3>Final Energy</h3>
                        <div class="value">${data.final_energy ? data.final_energy.toFixed(6) : 'N/A'}</div>
                        <div class="label">Hartree</div>
                    </div>
                    <div class="card">
                        <h3>Atoms</h3>
                        <div class="value">${data.coordinates.length}</div>
                        <div class="label">Molecular system</div>
                    </div>
                    <div class="card">
                        <h3>Dipole Moment</h3>
                        <div class="value">${data.dipole_moment?.magnitude_debye?.toFixed(4) || 'N/A'}</div>
                        <div class="label">Debye</div>
                    </div>
                </div>

                <div class="info-box">
                    <h4>üìà Parser Coverage</h4>
                    <p>This file contains 34 parsed sections out of 57 total sections (60% coverage)</p>
                    <div class="progress">
                        <div class="progress-bar" style="width: 60%">60%</div>
                    </div>
                </div>

                <div class="info-box">
                    <h4>‚ÑπÔ∏è Computation Details</h4>
                    <p><strong>Basis Functions:</strong> ${data.basis_set_info?.num_basis_functions || 'N/A'}</p>
                    <p><strong>DFT Grid Points:</strong> ${data.dft_grid_info?.total_grid_points?.toLocaleString() || 'N/A'}</p>
                    <p><strong>Total Runtime:</strong> ${data.timing_data?.total_run_time ? (data.timing_data.total_run_time / 60).toFixed(1) + ' minutes' : 'N/A'}</p>
                </div>
            `;

            document.getElementById('summary-content').innerHTML = content;
        }

        function renderGeometry() {
            if (!data || !data.coordinates) return;

            let html = '<table id="geometry-table"><thead><tr><th>Atom</th><th>Element</th><th>X (√Ö)</th><th>Y (√Ö)</th><th>Z (√Ö)</th></tr></thead><tbody>';

            data.coordinates.forEach((coord, i) => {
                html += `<tr>
                    <td>${i}</td>
                    <td><strong>${coord[0] || 'N/A'}</strong></td>
                    <td>${typeof coord[1] === 'number' ? coord[1].toFixed(6) : 'N/A'}</td>
                    <td>${typeof coord[2] === 'number' ? coord[2].toFixed(6) : 'N/A'}</td>
                    <td>${typeof coord[3] === 'number' ? coord[3].toFixed(6) : 'N/A'}</td>
                </tr>`;
            });

            html += '</tbody></table>';
            document.getElementById('geometry-content').innerHTML = html;
            setTimeout(() => addTableControls('geometry-table', 'geometry_coordinates'), 0);
        }

        function renderEnergy() {
            if (!data) return;

            const thermo = data.thermochemistry || {};
            const html = `
                <div class="info-box">
                    <h4>Single Point Energy</h4>
                    <p><strong>Final Energy:</strong> ${data.final_energy ? data.final_energy.toFixed(6) : 'N/A'} Eh</p>
                </div>

                <div class="info-box">
                    <h4>Thermochemistry (298.15 K)</h4>
                    <p><strong>Gibbs Free Energy:</strong> ${thermo.gibbs_free_energy ? thermo.gibbs_free_energy.toFixed(6) : 'N/A'} Eh</p>
                    <p><strong>Enthalpy:</strong> ${thermo.total_enthalpy ? thermo.total_enthalpy.toFixed(6) : 'N/A'} Eh</p>
                    <p><strong>Zero Point Energy:</strong> ${thermo.zero_point_energy ? thermo.zero_point_energy.toFixed(6) : 'N/A'} Eh</p>
                </div>

                <div class="info-box">
                    <h4>SCF Convergence</h4>
                    <p><strong>Iterations:</strong> ${data.scf_energies?.length || 'N/A'}</p>
                    <p><strong>Final Energy:</strong> ${data.scf_energies?.length ? data.scf_energies[data.scf_energies.length - 1].toFixed(6) + ' Eh' : 'N/A'}</p>
                </div>
            `;

            document.getElementById('energy-content').innerHTML = html;
        }

        function renderOrbitals() {
            if (!data || !data.orbital_energies) return;

            const orbitals = data.orbital_energies.slice(0, 50); // Show first 50

            let html = '<table id="orbitals-table"><thead><tr><th>MO</th><th>Occupation</th><th>Energy (eV)</th><th>Energy (Eh)</th></tr></thead><tbody>';

            orbitals.forEach(orb => {
                const highlight = orb.occupation > 0.5 && orb.occupation < 2.0 ? 'style="background: #ffffcc;"' : '';
                html += `<tr ${highlight}>
                    <td>${orb.index || 'N/A'}</td>
                    <td>${orb.occupation?.toFixed(4) || 'N/A'}</td>
                    <td>${orb.energy_ev?.toFixed(4) || 'N/A'}</td>
                    <td>${orb.energy_eh?.toFixed(6) || 'N/A'}</td>
                </tr>`;
            });

            html += '</tbody></table>';
            html += `<p style="margin-top: 20px; color: #666;">Showing first 50 of ${data.orbital_energies.length} molecular orbitals</p>`;

            document.getElementById('orbitals-content').innerHTML = html;
            setTimeout(() => addTableControls('orbitals-table', 'orbital_energies'), 0);
        }

        function renderVibrations() {
            if (!data || !data.frequencies) return;

            let html = '<table id="vibrations-table"><thead><tr><th>Mode</th><th>Frequency (cm‚Åª¬π)</th><th>Raman Activity</th></tr></thead><tbody>';

            data.frequencies.forEach((freq, i) => {
                const raman = data.raman_spectrum?.[i]?.activity?.toFixed(2) || 'N/A';
                html += `<tr>
                    <td>${i + 1}</td>
                    <td>${typeof freq === 'number' ? freq.toFixed(2) : 'N/A'}</td>
                    <td>${raman}</td>
                </tr>`;
            });

            html += '</tbody></table>';
            document.getElementById('vibrations-content').innerHTML = html;
            setTimeout(() => addTableControls('vibrations-table', 'vibrational_frequencies'), 0);
        }

        function renderNMR() {
            if (!data || !data.nmr_data) return;

            const shifts = data.nmr_data.chemical_shifts;

            let html = '<table id="nmr-table"><thead><tr><th>Nucleus</th><th>Element</th><th>Isotropic (ppm)</th><th>Anisotropy (ppm)</th></tr></thead><tbody>';

            shifts.forEach(shift => {
                html += `<tr>
                    <td>${shift.nucleus || 'N/A'}</td>
                    <td><strong>${shift.element || 'N/A'}</strong></td>
                    <td>${shift.isotropic?.toFixed(2) || 'N/A'}</td>
                    <td>${shift.anisotropy?.toFixed(2) || 'N/A'}</td>
                </tr>`;
            });

            html += '</tbody></table>';
            document.getElementById('nmr-content').innerHTML = html;
            setTimeout(() => addTableControls('nmr-table', 'nmr_chemical_shifts'), 0);
        }

        function renderPopulation() {
            if (!data) return;

            let html = '<div class="info-box"><h4>Mulliken Charges</h4><table id="mulliken-table"><thead><tr><th>Atom</th><th>Element</th><th>Charge</th></tr></thead><tbody>';

            Object.entries(data.mulliken_charges).forEach(([atom, info]) => {
                html += `<tr>
                    <td>${atom}</td>
                    <td><strong>${info.element || 'N/A'}</strong></td>
                    <td>${info.charge?.toFixed(4) || 'N/A'}</td>
                </tr>`;
            });

            html += '</tbody></table></div>';

            html += '<div class="info-box"><h4>Bond Orders</h4>';
            html += `<p><strong>Mayer Bond Orders:</strong> ${data.mayer_bond_orders.length} bonds</p>`;
            html += `<p><strong>Loewdin Bond Orders:</strong> ${data.loewdin_bond_orders.length} bonds</p>`;
            html += '</div>';

            document.getElementById('population-content').innerHTML = html;
            setTimeout(() => addTableControls('mulliken-table', 'mulliken_charges'), 0);
        }

        function renderRawJSON() {
            if (!data) return;
            document.getElementById('raw-content').innerHTML = '<pre>' + JSON.stringify(data, null, 2) + '</pre>';
        }

        function exportJSON() {
            if (!data) {
                alert('No data loaded. Please load data first.');
                return;
            }

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'orca_output_parsed.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Export table to CSV
        function exportTableToCSV(tableId, filename) {
            const table = document.getElementById(tableId);
            if (!table) {
                alert('Table not found');
                return;
            }

            let csv = [];
            const rows = table.querySelectorAll('tr');

            rows.forEach(row => {
                const cols = row.querySelectorAll('td, th');
                const rowData = Array.from(cols).map(col => {
                    let text = col.textContent.trim();
                    // Escape quotes and wrap in quotes if contains comma
                    if (text.includes(',') || text.includes('"')) {
                        text = '"' + text.replace(/"/g, '""') + '"';
                    }
                    return text;
                });
                csv.push(rowData.join(','));
            });

            const csvContent = csv.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename || 'table_export.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Export table to Excel (CSV format that Excel can open)
        function exportTableToExcel(tableId, filename) {
            const table = document.getElementById(tableId);
            if (!table) {
                alert('Table not found');
                return;
            }

            let csv = [];
            const rows = table.querySelectorAll('tr');

            rows.forEach(row => {
                const cols = row.querySelectorAll('td, th');
                const rowData = Array.from(cols).map(col => {
                    let text = col.textContent.trim();
                    // Excel-friendly CSV format
                    if (text.includes(',') || text.includes('"') || text.includes('\n')) {
                        text = '"' + text.replace(/"/g, '""') + '"';
                    }
                    return text;
                });
                csv.push(rowData.join(','));
            });

            const csvContent = '\ufeff' + csv.join('\r\n'); // UTF-8 BOM for Excel
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename || 'table_export.csv';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Filter table rows based on search
        function filterTable(tableId, searchValue) {
            const table = document.getElementById(tableId);
            if (!table) return;

            const searchLower = searchValue.toLowerCase();
            const tbody = table.querySelector('tbody');
            if (!tbody) return;

            const rows = tbody.querySelectorAll('tr');
            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                if (text.includes(searchLower)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        // Add table controls (search and export buttons) to a table
        function addTableControls(tableId, tableName) {
            const table = document.getElementById(tableId);
            if (!table || table.previousElementSibling?.classList.contains('table-controls')) {
                return; // Already has controls or table not found
            }

            const controls = document.createElement('div');
            controls.className = 'table-controls';
            controls.innerHTML = `
                <input type="text" class="table-search" placeholder="Search in table..."
                       onkeyup="filterTable('${tableId}', this.value)">
                <button class="btn-export-table" onclick="exportTableToCSV('${tableId}', '${tableName}.csv')">
                    üíæ CSV
                </button>
                <button class="btn-export-table" onclick="exportTableToExcel('${tableId}', '${tableName}.csv')">
                    üìä Excel
                </button>
            `;

            table.parentNode.insertBefore(controls, table);
        }

        function refreshData() {
            location.reload();
        }

        // ===== 3D MOLECULAR VISUALIZATION =====
        function render3DMolecule() {
            if (!data || !data.coordinates || data.coordinates.length === 0) {
                console.error('No coordinate data available');
                return;
            }

            const container = document.getElementById('molecule-viewer');
            if (!container) {
                console.error('Molecule viewer container not found');
                return;
            }

            container.innerHTML = ''; // Clear previous viewer

            try {
                viewer3d = $3Dmol.createViewer(container, {
                    backgroundColor: 'white',
                    antialias: true
                });

                // Convert coordinates to XYZ format
                let xyzData = `${data.coordinates.length}\n`;
                xyzData += `ORCA Molecule - ${data.job_info?.basis_set || 'Unknown basis'}\n`;

                data.coordinates.forEach((coord, idx) => {
                    const [element, x, y, z] = coord;
                    if (element && typeof x === 'number' && typeof y === 'number' && typeof z === 'number') {
                        xyzData += `${element}  ${x.toFixed(6)}  ${y.toFixed(6)}  ${z.toFixed(6)}\n`;
                    } else {
                        console.warn(`Invalid coordinate at index ${idx}:`, coord);
                    }
                });

                // Add model with better error handling
                const model = viewer3d.addModel(xyzData, 'xyz');

                if (!model) {
                    throw new Error('Failed to create 3D model');
                }

                // Set default style with better visibility
                viewer3d.setStyle({}, {
                    stick: {radius: 0.15, color: 'spectrum'},
                    sphere: {scale: 0.3}
                });

                // Add hover labels
                viewer3d.setHoverable({}, true, function(atom, viewer, event, container) {
                    if (!atom.label) {
                        const label = `${atom.elem} #${atom.serial}\n` +
                                    `x: ${atom.x.toFixed(3)}\n` +
                                    `y: ${atom.y.toFixed(3)}\n` +
                                    `z: ${atom.z.toFixed(3)}`;
                        viewer.addLabel(label, {
                            position: atom,
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            fontColor: 'white',
                            fontSize: 12,
                            showBackground: true
                        });
                        atom.label = true;
                    }
                }, function(atom) {
                    if (atom.label) {
                        viewer3d.removeAllLabels();
                        atom.label = false;
                    }
                });

                viewer3d.zoomTo();
                viewer3d.render();

                console.log('3D molecule rendered successfully');
            } catch (error) {
                console.error('Error rendering 3D molecule:', error);
                container.innerHTML = `<div style="padding: 20px; color: red;">
                    <strong>Error rendering 3D molecule:</strong><br>
                    ${error.message}<br>
                    Please check the console for details.
                </div>`;
            }
        }

        function setMoleculeStyle(style) {
            if (!viewer3d) return;
            viewer3d.setStyle({}, {});

            if (style === 'stick') {
                viewer3d.setStyle({}, {stick: {radius: 0.15}});
            } else if (style === 'sphere') {
                viewer3d.setStyle({}, {sphere: {scale: 0.5}});
            } else if (style === 'cartoon') {
                viewer3d.setStyle({}, {stick: {radius: 0.15}, sphere: {scale: 0.3}});
            }

            viewer3d.render();
        }

        function toggleLabels() {
            if (!viewer3d || !data) return;
            showLabels = !showLabels;

            viewer3d.removeAllLabels();
            if (showLabels) {
                data.coordinates.forEach((coord, i) => {
                    viewer3d.addLabel(coord[0], {
                        position: {x: coord[1], y: coord[2], z: coord[3]},
                        backgroundColor: 'white',
                        fontColor: 'black',
                        fontSize: 12
                    });
                });
            }
            viewer3d.render();
        }

        function exportMoleculeImage() {
            if (!viewer3d) return;
            const imgData = viewer3d.pngURI();
            const a = document.createElement('a');
            a.href = imgData;
            a.download = 'molecule_3d.png';
            a.click();
        }

        // ===== CHARGE COLORING =====
        let currentChargeType = 'none';

        function setChargeColoring(chargeType) {
            if (!viewer3d || !data) return;
            currentChargeType = chargeType;

            const legend = document.getElementById('charge-legend');

            if (chargeType === 'none') {
                // Reset to element colors
                viewer3d.setStyle({}, {stick: {radius: 0.15}, sphere: {scale: 0.3}});
                legend.style.display = 'none';
            } else {
                // Get charges
                const charges = chargeType === 'mulliken' ? data.mulliken_charges : data.loewdin_charges;
                if (!charges) {
                    alert(`${chargeType} charges not available in data`);
                    return;
                }

                // Color each atom by charge
                data.coordinates.forEach((coord, i) => {
                    const element = coord[0];
                    const atomKey = `${i}${element}`;
                    const chargeData = charges[atomKey];

                    if (chargeData) {
                        const charge = chargeData.charge;
                        const color = chargeToColor(charge);
                        viewer3d.setStyle({serial: i}, {
                            stick: {radius: 0.15},
                            sphere: {scale: 0.4, color: color}
                        });
                    }
                });

                legend.style.display = 'block';
            }

            viewer3d.render();
        }

        function chargeToColor(charge) {
            // Map charge to color: red (negative) -> white (neutral) -> blue (positive)
            const clampedCharge = Math.max(-1, Math.min(1, charge)); // Clamp to [-1, 1]

            if (clampedCharge < 0) {
                // Negative: white to red
                const intensity = Math.abs(clampedCharge);
                const r = 255;
                const g = Math.round(255 * (1 - intensity));
                const b = Math.round(255 * (1 - intensity));
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Positive: white to blue
                const intensity = clampedCharge;
                const r = Math.round(255 * (1 - intensity));
                const g = Math.round(255 * (1 - intensity));
                const b = 255;
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        // ===== DIPOLE MOMENT VECTOR =====
        let showDipole = false;

        function toggleDipole() {
            if (!viewer3d || !data || !data.dipole_moment) return;
            showDipole = !showDipole;

            viewer3d.removeAllShapes();

            if (showDipole) {
                const dipole = data.dipole_moment;
                const mag = dipole.magnitude_debye;

                // Scale factor for arrow length
                const scale = 2.0;

                // Draw arrow from center of molecule
                const center = {x: 0, y: 0, z: 0};
                const end = {
                    x: dipole.x_debye * scale,
                    y: dipole.y_debye * scale,
                    z: dipole.z_debye * scale
                };

                viewer3d.addArrow({
                    start: center,
                    end: end,
                    radius: 0.2,
                    color: 'purple',
                    mid: 0.8
                });

                viewer3d.addLabel(`Œº = ${mag.toFixed(2)} D`, {
                    position: end,
                    backgroundColor: 'purple',
                    fontColor: 'white',
                    fontSize: 14
                });
            }

            viewer3d.render();
        }

        // ===== BOND ORDERS =====
        let showBondOrdersFlag = false;

        function toggleBondOrders() {
            if (!viewer3d || !data || !data.mayer_bond_orders) return;
            showBondOrdersFlag = !showBondOrdersFlag;

            viewer3d.removeAllLabels();

            if (showBondOrdersFlag) {
                // Show bond orders as labels
                data.mayer_bond_orders.forEach(bond => {
                    if (bond.bond_order > 0.5) { // Only show significant bonds
                        const coord1 = data.coordinates[bond.atom1_index];
                        const coord2 = data.coordinates[bond.atom2_index];

                        if (coord1 && coord2) {
                            const midpoint = {
                                x: (coord1[1] + coord2[1]) / 2,
                                y: (coord1[2] + coord2[2]) / 2,
                                z: (coord1[3] + coord2[3]) / 2
                            };

                            viewer3d.addLabel(bond.bond_order.toFixed(2), {
                                position: midpoint,
                                backgroundColor: 'rgba(255, 255, 0, 0.7)',
                                fontColor: 'black',
                                fontSize: 10
                            });
                        }
                    }
                });
            }

            viewer3d.render();
        }

        // ===== PLOTLY VISUALIZATIONS =====
        function renderAllPlots() {
            if (!data) return;
            renderSCFPlot();
            renderIRPlot();
            renderRamanPlot();
            renderThermoPlot();
            renderOrbitalPlot();
            renderNMRPlot();
            renderCombinedSpectrum();
            renderTimingBreakdown();
            renderSCFDetails();
            renderBasisComposition();
            renderGridStatistics();
            // NEW VISUALIZATIONS
            renderOptimizationTrajectory();
            populateVibrationalModes();
            renderOrbitalChargeHeatmap();
            renderJCouplingNetwork();
            renderChemicalShieldingTable();
            renderHOMOLUMOGapTracker();
            renderDensityOfStates();
            renderMullikenOverlapNetwork();
            renderPolarizabilityVisualization();
            renderBondOrderComparison();
            renderChargeComparison();
            renderEnergyComponents();
            renderDispersionCorrection();
            renderOrbitalPopulation();
            renderInternalCoordinates();
            renderSCFEfficiency();
            renderSolvationAnalysis();
            renderOrbitalDistribution();
            renderFrequencyAnalysis();
            renderChargeDistributionPie();
            renderBondCorrelation();
            renderEigenvalueSpectrum();
            renderIRRamanCorrelation();
            renderMassDistribution();
            renderDipoleComponents();
            renderThermoBreakdown();
            renderAtomStats();
            renderAngleDistribution();
            renderElementComposition();
            renderOptConvergence();
            renderPopulationCorrelation();
            renderDistanceAnalysis();
            renderCoordinationNumbers();
            renderSCFDashboard();
            renderEnergyWaterfall();
            renderPerformanceDashboard();
            renderMemoryUsage();
            renderOrbitalGapsLandscape();
            renderModeClassification();
            renderNMRDistribution();
            renderBondStrengthDistribution();
            renderTimingEfficiency();
            renderPropertiesSummary();
            renderMOComposition();
            renderEnergyDiagram();
            renderCorrelationMatrix();
            renderRadialDistribution();
            renderOptimizationPath3D();
            renderOverlapMatrix();
            renderChargeFlow();
            renderFrequency3D();
            renderBasisDistribution();
        }

        function renderSCFPlot() {
            if (!data || !data.scf_energies || data.scf_energies.length === 0) return;

            const trace = {
                x: Array.from({length: data.scf_energies.length}, (_, i) => i + 1),
                y: data.scf_energies,
                mode: 'lines+markers',
                name: 'SCF Energy',
                line: {color: '#667eea', width: 2},
                marker: {size: 6}
            };

            const layout = {
                title: 'SCF Convergence',
                xaxis: {title: 'Iteration'},
                yaxis: {title: 'Energy (Eh)'},
                hovermode: 'closest'
            };

            Plotly.newPlot('scf-plot', [trace], layout, {responsive: true});
        }

        function renderIRPlot() {
            if (!data || !data.ir_spectrum || data.ir_spectrum.length === 0) return;

            const frequencies = data.ir_spectrum.map(d => d.frequency);
            const intensities = data.ir_spectrum.map(d => d.intensity);

            const trace = {
                x: frequencies,
                y: intensities,
                type: 'bar',
                marker: {color: '#28a745'},
                name: 'IR Intensity'
            };

            const layout = {
                title: 'IR Spectrum',
                xaxis: {title: 'Frequency (cm‚Åª¬π)'},
                yaxis: {title: 'Intensity (km/mol)'},
                hovermode: 'closest'
            };

            Plotly.newPlot('ir-plot', [trace], layout, {responsive: true});
        }

        function renderRamanPlot() {
            if (!data || !data.raman_spectrum || data.raman_spectrum.length === 0) return;

            const frequencies = data.raman_spectrum.map(d => d.frequency);
            const activities = data.raman_spectrum.map(d => d.activity);

            const trace = {
                x: frequencies,
                y: activities,
                type: 'bar',
                marker: {color: '#dc3545'},
                name: 'Raman Activity'
            };

            const layout = {
                title: 'Raman Spectrum',
                xaxis: {title: 'Frequency (cm‚Åª¬π)'},
                yaxis: {title: 'Raman Activity'},
                hovermode: 'closest'
            };

            Plotly.newPlot('raman-plot', [trace], layout, {responsive: true});
        }

        function renderThermoPlot() {
            if (!data || !data.thermochemistry) return;

            const thermo = data.thermochemistry;
            const labels = ['Electronic', 'ZPE', 'Thermal', 'Enthalpy', 'Gibbs Free'];
            const values = [
                data.final_energy || 0,
                thermo.zero_point_energy || 0,
                thermo.total_enthalpy || 0,
                thermo.total_enthalpy || 0,
                thermo.gibbs_free_energy || 0
            ];

            const trace = {
                x: labels,
                y: values,
                type: 'bar',
                marker: {color: ['#667eea', '#764ba2', '#28a745', '#ffc107', '#dc3545']}
            };

            const layout = {
                title: 'Thermochemistry Energy Diagram',
                yaxis: {title: 'Energy (Eh)'},
                hovermode: 'closest'
            };

            Plotly.newPlot('thermo-plot', [trace], layout, {responsive: true});
        }

        function renderOrbitalPlot() {
            if (!data || !data.orbital_energies || data.orbital_energies.length === 0) return;

            // Show orbitals around HOMO-LUMO (e.g., HOMO-10 to LUMO+10)
            const orbitals = data.orbital_energies.slice(Math.max(0, data.orbital_energies.length / 2 - 20), data.orbital_energies.length / 2 + 20);

            const occupied = orbitals.filter(o => o.occupation > 0.5);
            const virtual = orbitals.filter(o => o.occupation <= 0.5);

            const trace1 = {
                x: occupied.map(o => o.index),
                y: occupied.map(o => o.energy_ev),
                mode: 'markers',
                name: 'Occupied',
                marker: {size: 8, color: '#28a745'}
            };

            const trace2 = {
                x: virtual.map(o => o.index),
                y: virtual.map(o => o.energy_ev),
                mode: 'markers',
                name: 'Virtual',
                marker: {size: 8, color: '#dc3545'}
            };

            const layout = {
                title: 'Molecular Orbital Energy Diagram',
                xaxis: {title: 'MO Index'},
                yaxis: {title: 'Energy (eV)'},
                hovermode: 'closest'
            };

            Plotly.newPlot('orbital-plot', [trace1, trace2], layout, {responsive: true});
        }

        function renderNMRPlot() {
            if (!data || !data.nmr_data || !data.nmr_data.chemical_shifts || data.nmr_data.chemical_shifts.length === 0) return;

            const shifts = data.nmr_data.chemical_shifts;
            const x = shifts.map(s => s.isotropic);
            const y = Array(shifts.length).fill(1); // Height of peaks
            const labels = shifts.map(s => `${s.element}${s.nucleus}`);

            const trace = {
                x: x,
                y: y,
                mode: 'markers',
                marker: {size: 12, color: '#667eea'},
                text: labels,
                hoverinfo: 'text+x'
            };

            const layout = {
                title: 'NMR Chemical Shifts',
                xaxis: {title: 'Chemical Shift (ppm)', autorange: 'reversed'},
                yaxis: {title: 'Intensity', showticklabels: false},
                hovermode: 'closest'
            };

            Plotly.newPlot('nmr-plot', [trace], layout, {responsive: true});
        }

        function renderCombinedSpectrum() {
            if (!data || (!data.ir_spectrum && !data.raman_spectrum)) return;

            const traces = [];

            // IR spectrum trace
            if (data.ir_spectrum && data.ir_spectrum.length > 0) {
                const irTrace = {
                    x: data.ir_spectrum.map(d => d.frequency),
                    y: data.ir_spectrum.map(d => d.intensity),
                    type: 'bar',
                    name: 'IR Intensity',
                    marker: {color: '#28a745'},
                    yaxis: 'y',
                    opacity: 0.7
                };
                traces.push(irTrace);
            }

            // Raman spectrum trace
            if (data.raman_spectrum && data.raman_spectrum.length > 0) {
                const ramanTrace = {
                    x: data.raman_spectrum.map(d => d.frequency),
                    y: data.raman_spectrum.map(d => d.activity),
                    type: 'bar',
                    name: 'Raman Activity',
                    marker: {color: '#dc3545'},
                    yaxis: 'y2',
                    opacity: 0.7
                };
                traces.push(ramanTrace);
            }

            const layout = {
                title: 'IR + Raman Combined Spectrum',
                xaxis: {title: 'Frequency (cm‚Åª¬π)'},
                yaxis: {
                    title: 'IR Intensity (km/mol)',
                    titlefont: {color: '#28a745'},
                    tickfont: {color: '#28a745'}
                },
                yaxis2: {
                    title: 'Raman Activity',
                    titlefont: {color: '#dc3545'},
                    tickfont: {color: '#dc3545'},
                    overlaying: 'y',
                    side: 'right'
                },
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('combined-spectrum-plot', traces, layout, {responsive: true});
        }

        function renderTimingBreakdown() {
            if (!data || !data.timing_data) return;

            const timing = data.timing_data;

            // Extract timing data (exclude total_run_time)
            const modules = [];
            const times = [];

            for (const [key, value] of Object.entries(timing)) {
                if (key !== 'total_run_time' && typeof value === 'number' && value > 0) {
                    // Format key for display
                    const displayName = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    modules.push(displayName);
                    times.push(value);
                }
            }

            if (modules.length === 0) {
                // No timing data available
                return;
            }

            const trace = {
                labels: modules,
                values: times,
                type: 'pie',
                textinfo: 'label+percent',
                hoverinfo: 'label+value+percent',
                marker: {
                    colors: ['#667eea', '#764ba2', '#28a745', '#ffc107', '#dc3545', '#17a2b8', '#6c757d', '#e83e8c']
                }
            };

            const layout = {
                title: 'Computation Time Breakdown',
                height: 400,
                showlegend: true
            };

            Plotly.newPlot('timing-plot', [trace], layout, {responsive: true});
        }

        function renderSCFDetails() {
            if (!data || !data.scf_iterations || data.scf_iterations.length === 0) return;

            const iterations = data.scf_iterations;
            const xData = iterations.map((_, i) => i + 1);

            const traces = [];

            // Energy convergence
            if (iterations[0].energy !== undefined) {
                traces.push({
                    x: xData,
                    y: iterations.map(it => it.energy),
                    name: 'Energy (Eh)',
                    mode: 'lines+markers',
                    line: {color: '#667eea', width: 2},
                    marker: {size: 6},
                    yaxis: 'y',
                    hovertemplate: 'Iteration %{x}<br>Energy: %{y:.8f} Eh<extra></extra>'
                });
            }

            // Density convergence
            if (iterations[0].max_density_change !== undefined) {
                traces.push({
                    x: xData,
                    y: iterations.map(it => Math.abs(it.max_density_change)),
                    name: 'Density Change',
                    mode: 'lines+markers',
                    line: {color: '#28a745', width: 2, dash: 'dot'},
                    marker: {size: 6},
                    yaxis: 'y2',
                    hovertemplate: 'Iteration %{x}<br>Density: %{y:.2e}<extra></extra>'
                });
            }

            // DIIS error
            if (iterations[0].diis_error !== undefined) {
                traces.push({
                    x: xData,
                    y: iterations.map(it => it.diis_error),
                    name: 'DIIS Error',
                    mode: 'lines+markers',
                    line: {color: '#dc3545', width: 2, dash: 'dash'},
                    marker: {size: 6},
                    yaxis: 'y3',
                    hovertemplate: 'Iteration %{x}<br>DIIS Error: %{y:.2e}<extra></extra>'
                });
            }

            if (traces.length === 0) return;

            const layout = {
                title: 'SCF Convergence Details',
                xaxis: {title: 'Iteration'},
                yaxis: {
                    title: 'Energy (Eh)',
                    titlefont: {color: '#667eea'},
                    tickfont: {color: '#667eea'}
                },
                yaxis2: {
                    title: 'Density Change',
                    titlefont: {color: '#28a745'},
                    tickfont: {color: '#28a745'},
                    overlaying: 'y',
                    side: 'right',
                    type: 'log'
                },
                yaxis3: {
                    title: 'DIIS Error',
                    titlefont: {color: '#dc3545'},
                    tickfont: {color: '#dc3545'},
                    anchor: 'free',
                    overlaying: 'y',
                    side: 'right',
                    position: 0.95,
                    type: 'log'
                },
                hovermode: 'x unified',
                showlegend: true,
                legend: {x: 0.01, y: 0.99}
            };

            Plotly.newPlot('scf-details-plot', traces, layout, {responsive: true});
        }

        function renderBasisComposition() {
            if (!data || !data.basis_set_info) return;

            const basis = data.basis_set_info;

            // Count shells by type
            const shellCounts = {};
            let totalPrimitives = 0;

            // Try to extract shell information
            // This is a simplified version - real implementation depends on data structure
            const labels = [];
            const values = [];

            if (basis.num_basis_functions) {
                // If we have detailed shell info, use it
                // Otherwise, show general info
                labels.push('Total Basis Functions');
                values.push(basis.num_basis_functions);
            }

            if (basis.num_contracted_shells) {
                labels.push('Contracted Shells');
                values.push(basis.num_contracted_shells);
            }

            if (basis.num_primitive_shells) {
                labels.push('Primitive Shells');
                values.push(basis.num_primitive_shells);
            }

            if (labels.length === 0) return;

            const trace = {
                labels: labels,
                values: values,
                type: 'pie',
                textinfo: 'label+value',
                hoverinfo: 'label+value+percent',
                marker: {
                    colors: ['#667eea', '#764ba2', '#28a745', '#ffc107', '#dc3545']
                },
                hovertemplate: '%{label}<br>Count: %{value}<br>Percent: %{percent}<extra></extra>'
            };

            const layout = {
                title: `Basis Set: ${basis.basis_set_name || 'Unknown'}`,
                height: 400,
                showlegend: true,
                annotations: [{
                    text: `${basis.num_basis_functions || 0} Functions`,
                    x: 0.5,
                    y: -0.1,
                    xref: 'paper',
                    yref: 'paper',
                    showarrow: false,
                    font: {size: 14}
                }]
            };

            Plotly.newPlot('basis-plot', [trace], layout, {responsive: true});
        }

        function renderGridStatistics() {
            if (!data || (!data.dft_grid_info && !data.cosx_grids)) return;

            const traces = [];

            // DFT Grid data
            if (data.dft_grid_info) {
                const grid = data.dft_grid_info;
                traces.push({
                    x: ['Total Grid Points', 'Radial Points', 'Angular Points'],
                    y: [
                        grid.total_grid_points || 0,
                        grid.radial_grid_points || 0,
                        grid.angular_grid_points || 0
                    ],
                    name: 'DFT Grid',
                    type: 'bar',
                    marker: {color: '#667eea'},
                    hovertemplate: '%{x}: %{y:,}<extra></extra>'
                });
            }

            // COSX Grids
            if (data.cosx_grids && data.cosx_grids.length > 0) {
                const cosxLabels = data.cosx_grids.map((g, i) => `Grid ${g.grid_number || i+1}`);
                const cosxPoints = data.cosx_grids.map(g => g.total_grid_points || 0);

                traces.push({
                    x: cosxLabels,
                    y: cosxPoints,
                    name: 'COSX Grids',
                    type: 'bar',
                    marker: {color: '#28a745'},
                    hovertemplate: '%{x}: %{y:,} points<extra></extra>'
                });
            }

            if (traces.length === 0) return;

            const layout = {
                title: 'DFT Grid Statistics',
                xaxis: {title: 'Grid Type'},
                yaxis: {title: 'Number of Points', type: 'log'},
                barmode: 'group',
                hovermode: 'closest',
                showlegend: traces.length > 1
            };

            Plotly.newPlot('grid-plot', traces, layout, {responsive: true});
        }

        // ===== COLLAPSIBLE SECTIONS =====
        function toggleCollapsible(element) {
            element.classList.toggle('active');
            const content = element.nextElementSibling;
            content.classList.toggle('active');
        }

        // ===== EXPORT FUNCTIONS =====
        function exportPlot(plotId, filename) {
            Plotly.downloadImage(plotId, {
                format: filename.endsWith('.svg') ? 'svg' : 'png',
                filename: filename.replace(/\.(png|svg)$/, ''),
                width: 1200,
                height: 800
            });
        }

        // ===== NEW VISUALIZATIONS =====

        // 1. GEOMETRY OPTIMIZATION TRAJECTORY
        let optAnimationInterval = null;

        function renderOptimizationTrajectory() {
            if (!data || !data.optimization_energies || data.optimization_energies.length === 0) return;

            const energies = data.optimization_energies;
            const steps = Array.from({length: energies.length}, (_, i) => i + 1);

            // Update slider max
            const slider = document.getElementById('opt-slider');
            slider.max = energies.length - 1;

            const trace = {
                x: steps,
                y: energies,
                mode: 'lines+markers',
                name: 'Energy',
                line: {color: '#667eea', width: 3},
                marker: {size: 8, color: '#764ba2'},
                hovertemplate: 'Step %{x}<br>Energy: %{y:.8f} Eh<extra></extra>'
            };

            const layout = {
                title: 'Geometry Optimization Energy Trajectory',
                xaxis: {title: 'Optimization Step'},
                yaxis: {title: 'Energy (Eh)'},
                hovermode: 'closest',
                showlegend: false
            };

            Plotly.newPlot('opt-trajectory-plot', [trace], layout, {responsive: true});

            // Add click event to jump to step
            document.getElementById('opt-trajectory-plot').on('plotly_click', function(data) {
                if (data.points && data.points.length > 0) {
                    const step = data.points[0].pointIndex;
                    updateOptStep(step);
                    slider.value = step;
                }
            });
        }

        function updateOptStep(step) {
            document.getElementById('opt-step-label').textContent = parseInt(step) + 1;

            // Highlight the selected point on the plot
            if (!data || !data.optimization_energies) return;

            const energies = data.optimization_energies;
            const steps = Array.from({length: energies.length}, (_, i) => i + 1);

            const trace1 = {
                x: steps,
                y: energies,
                mode: 'lines+markers',
                name: 'Energy',
                line: {color: '#667eea', width: 3},
                marker: {size: 8, color: '#764ba2'},
                hovertemplate: 'Step %{x}<br>Energy: %{y:.8f} Eh<extra></extra>'
            };

            const trace2 = {
                x: [parseInt(step) + 1],
                y: [energies[parseInt(step)]],
                mode: 'markers',
                name: 'Current',
                marker: {size: 15, color: '#ffc107', line: {width: 2, color: 'black'}},
                hovertemplate: 'Current Step: %{x}<br>Energy: %{y:.8f} Eh<extra></extra>'
            };

            const layout = {
                title: 'Geometry Optimization Energy Trajectory',
                xaxis: {title: 'Optimization Step'},
                yaxis: {title: 'Energy (Eh)'},
                hovermode: 'closest',
                showlegend: false
            };

            Plotly.react('opt-trajectory-plot', [trace1, trace2], layout, {responsive: true});
        }

        function playOptAnimation() {
            if (optAnimationInterval) return; // Already playing

            const slider = document.getElementById('opt-slider');
            const maxStep = parseInt(slider.max);
            let currentStep = parseInt(slider.value);

            optAnimationInterval = setInterval(() => {
                currentStep++;
                if (currentStep > maxStep) {
                    currentStep = 0;
                }
                slider.value = currentStep;
                updateOptStep(currentStep);
            }, 500); // 500ms per step
        }

        function pauseOptAnimation() {
            if (optAnimationInterval) {
                clearInterval(optAnimationInterval);
                optAnimationInterval = null;
            }
        }

        function resetOptAnimation() {
            pauseOptAnimation();
            const slider = document.getElementById('opt-slider');
            slider.value = 0;
            updateOptStep(0);
        }

        // 2. VIBRATIONAL MODE ANIMATION
        let vibAnimationInterval = null;
        let currentVibMode = null;

        function populateVibrationalModes() {
            if (!data || !data.frequencies || data.frequencies.length === 0) return;

            const selector = document.getElementById('mode-selector');
            selector.innerHTML = '<option value="">-- Select Mode --</option>';

            data.frequencies.forEach((freq, i) => {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Mode ${i + 1}: ${freq.toFixed(2)} cm‚Åª¬π`;
                selector.appendChild(option);
            });
        }

        function selectVibrationalMode(modeIndex) {
            if (!modeIndex || !data) return;

            currentVibMode = parseInt(modeIndex);
            const freq = data.frequencies[currentVibMode];
            const irData = data.ir_spectrum ? data.ir_spectrum[currentVibMode] : null;
            const ramanData = data.raman_spectrum ? data.raman_spectrum[currentVibMode] : null;

            // Update info display
            document.getElementById('vib-frequency').textContent = freq.toFixed(2);
            document.getElementById('vib-ir-intensity').textContent = irData ? irData.intensity.toFixed(2) : 'N/A';
            document.getElementById('vib-raman-activity').textContent = ramanData ? ramanData.activity.toFixed(2) : 'N/A';
            document.getElementById('vib-mode-info').style.display = 'block';

            // Display mode info
            alert(`Vibrational mode ${currentVibMode + 1} selected.\n\nNote: Full normal mode displacement vectors are partially available in the parsed data. For complete animation, all 3N displacement vectors would be needed from the ORCA output.`);
        }

        function playVibAnimation() {
            if (!currentVibMode && currentVibMode !== 0) {
                alert('Please select a vibrational mode first.');
                return;
            }
            alert('Vibrational animation would animate atomic displacements based on normal mode vectors. This requires the full normal mode displacement data (3N vectors per mode).');
        }

        function pauseVibAnimation() {
            if (vibAnimationInterval) {
                clearInterval(vibAnimationInterval);
                vibAnimationInterval = null;
            }
        }

        function updateVibAmplitude(value) {
            document.getElementById('vib-amp-label').textContent = value;
        }

        // 3. ORBITAL CHARGE HEATMAP
        let currentHeatmapChargeType = 'mulliken';

        function renderOrbitalChargeHeatmap() {
            if (!data || !data.mulliken_orbital_charges || data.mulliken_orbital_charges.length === 0) return;

            updateHeatmapChargeType('mulliken');
        }

        function updateHeatmapChargeType(chargeType) {
            currentHeatmapChargeType = chargeType;
            const charges = chargeType === 'mulliken' ? data.mulliken_orbital_charges : data.loewdin_orbital_charges;

            if (!charges || charges.length === 0) {
                alert(`${chargeType} orbital charges not available in data`);
                return;
            }

            // Build heatmap data: MOs (rows) √ó Atoms (columns)
            // Each MOCharge has: mo_index, atom_charges (dict)

            // Get all unique atom indices
            const atomIndices = new Set();
            charges.forEach(moCharge => {
                Object.keys(moCharge.atom_charges || {}).forEach(atomIdx => {
                    atomIndices.add(parseInt(atomIdx));
                });
            });
            const sortedAtomIndices = Array.from(atomIndices).sort((a, b) => a - b);

            // Build z matrix (MO √ó Atom)
            const zMatrix = [];
            const moLabels = [];
            const atomLabels = sortedAtomIndices.map(idx => {
                const coord = data.coordinates[idx];
                return coord ? `${coord[0]}${idx}` : `Atom${idx}`;
            });

            charges.forEach(moCharge => {
                const row = [];
                sortedAtomIndices.forEach(atomIdx => {
                    const charge = moCharge.atom_charges[atomIdx] || 0;
                    row.push(charge);
                });
                zMatrix.push(row);
                moLabels.push(`MO ${moCharge.mo_index}`);
            });

            const trace = {
                z: zMatrix,
                x: atomLabels,
                y: moLabels,
                type: 'heatmap',
                colorscale: 'RdBu',
                reversescale: true,
                hovertemplate: 'MO: %{y}<br>Atom: %{x}<br>Charge: %{z:.4f}<extra></extra>',
                colorbar: {
                    title: 'Charge'
                }
            };

            const layout = {
                title: `${chargeType.charAt(0).toUpperCase() + chargeType.slice(1)} Orbital Charges Heatmap`,
                xaxis: {title: 'Atoms', tickangle: -45},
                yaxis: {title: 'Molecular Orbitals', autorange: 'reversed'},
                height: 600
            };

            Plotly.newPlot('orbital-heatmap-plot', [trace], layout, {responsive: true});
        }

        function zoomToHOMOLUMO() {
            if (!data || !data.orbital_energies) return;

            // Find HOMO index (last occupied orbital)
            const homoIndex = data.orbital_energies.findIndex(o => o.occupation <= 0.5) - 1;
            if (homoIndex < 0) return;

            // Show HOMO-10 to LUMO+10
            const startMO = Math.max(0, homoIndex - 10);
            const endMO = Math.min(data.orbital_energies.length - 1, homoIndex + 11);

            Plotly.relayout('orbital-heatmap-plot', {
                'yaxis.range': [endMO, startMO]  // Reversed because y is reversed
            });
        }

        function resetHeatmapZoom() {
            Plotly.relayout('orbital-heatmap-plot', {
                'yaxis.range': null,
                'xaxis.range': null
            });
        }

        // 4. NMR J-COUPLING NETWORK
        function renderJCouplingNetwork() {
            if (!data || !data.nmr_data || !data.nmr_data.j_couplings || data.nmr_data.j_couplings.length === 0) return;

            const jCouplings = data.nmr_data.j_couplings;
            const chemicalShifts = data.nmr_data.chemical_shifts || [];

            // Create nodes (nuclei)
            const nodeIndices = new Set();
            jCouplings.forEach(jc => {
                nodeIndices.add(jc.atom1_index);
                nodeIndices.add(jc.atom2_index);
            });

            const nodes = Array.from(nodeIndices).map(idx => {
                const shift = chemicalShifts.find(s => s.nucleus === idx);
                const coord = data.coordinates[idx];
                return {
                    index: idx,
                    element: coord ? coord[0] : 'X',
                    shift: shift ? shift.isotropic : 0
                };
            });

            // Create edges (J-couplings)
            const edges = jCouplings.map(jc => ({
                from: jc.atom1_index,
                to: jc.atom2_index,
                value: Math.abs(jc.value),
                label: jc.value.toFixed(2) + ' Hz'
            }));

            // Use a force-directed layout approximation with Plotly
            // For simplicity, use a circular layout
            const n = nodes.length;
            const nodeX = nodes.map((node, i) => Math.cos(2 * Math.PI * i / n));
            const nodeY = nodes.map((node, i) => Math.sin(2 * Math.PI * i / n));

            // Edge traces
            const edgeTraces = [];
            edges.forEach(edge => {
                const fromIdx = nodes.findIndex(n => n.index === edge.from);
                const toIdx = nodes.findIndex(n => n.index === edge.to);
                if (fromIdx >= 0 && toIdx >= 0) {
                    const edgeTrace = {
                        x: [nodeX[fromIdx], nodeX[toIdx], null],
                        y: [nodeY[fromIdx], nodeY[toIdx], null],
                        mode: 'lines',
                        line: {
                            width: Math.min(10, Math.max(1, edge.value / 10)),
                            color: '#999'
                        },
                        hovertemplate: `J-coupling: ${edge.label}<extra></extra>`,
                        showlegend: false
                    };
                    edgeTraces.push(edgeTrace);
                }
            });

            // Node trace
            const nodeTrace = {
                x: nodeX,
                y: nodeY,
                mode: 'markers+text',
                marker: {
                    size: 20,
                    color: nodes.map((_, i) => i),
                    colorscale: 'Viridis',
                    line: {width: 2, color: 'white'}
                },
                text: nodes.map(n => `${n.element}${n.index}`),
                textposition: 'top center',
                hovertemplate: 'Nucleus: %{text}<br>Chemical Shift: %{customdata:.2f} ppm<extra></extra>',
                customdata: nodes.map(n => n.shift)
            };

            const traces = [...edgeTraces, nodeTrace];

            const layout = {
                title: 'NMR J-Coupling Network',
                xaxis: {showgrid: false, zeroline: false, showticklabels: false},
                yaxis: {showgrid: false, zeroline: false, showticklabels: false},
                hovermode: 'closest',
                showlegend: false,
                height: 500
            };

            Plotly.newPlot('jcoupling-network-plot', traces, layout, {responsive: true});
        }

        // 5. CHEMICAL SHIELDING TENSORS TABLE
        function renderChemicalShieldingTable() {
            if (!data || !data.chemical_shielding_tensors || data.chemical_shielding_tensors.length === 0) return;

            const tensors = data.chemical_shielding_tensors;

            let html = '<table><thead><tr><th>Atom</th><th>Element</th><th>Isotropic (ppm)</th><th>Components</th><th>Details</th></tr></thead><tbody>';

            tensors.forEach((tensor, i) => {
                const coord = data.coordinates[tensor.atom_index];
                const element = coord ? coord[0] : 'X';

                html += `<tr>
                    <td>${tensor.atom_index}</td>
                    <td><strong>${element}</strong></td>
                    <td>${tensor.total_iso.toFixed(2)}</td>
                    <td>
                        ${tensor.total_components[0]?.toFixed(2) || 'N/A'},
                        ${tensor.total_components[1]?.toFixed(2) || 'N/A'},
                        ${tensor.total_components[2]?.toFixed(2) || 'N/A'}
                    </td>
                    <td>
                        <button class="btn-secondary" onclick="showTensorDetails(${i})" style="font-size: 11px; padding: 4px 8px;">View Tensor</button>
                    </td>
                </tr>`;
            });

            html += '</tbody></table>';
            html += '<div id="tensor-details-modal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); z-index: 1000; max-width: 600px;"></div>';
            html += '<div id="tensor-modal-overlay" onclick="closeTensorDetails()" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>';

            document.getElementById('shielding-tensors-table').innerHTML = html;
        }

        function showTensorDetails(tensorIndex) {
            if (!data || !data.chemical_shielding_tensors) return;

            const tensor = data.chemical_shielding_tensors[tensorIndex];
            const coord = data.coordinates[tensor.atom_index];
            const element = coord ? coord[0] : 'X';

            // Format 3x3 tensor
            const formatTensor = (values) => {
                if (!values || values.length !== 9) return 'N/A';
                return `
                    <table style="margin: 10px auto; border-collapse: collapse;">
                        <tr><td style="padding: 5px;">${values[0].toFixed(3)}</td><td style="padding: 5px;">${values[1].toFixed(3)}</td><td style="padding: 5px;">${values[2].toFixed(3)}</td></tr>
                        <tr><td style="padding: 5px;">${values[3].toFixed(3)}</td><td style="padding: 5px;">${values[4].toFixed(3)}</td><td style="padding: 5px;">${values[5].toFixed(3)}</td></tr>
                        <tr><td style="padding: 5px;">${values[6].toFixed(3)}</td><td style="padding: 5px;">${values[7].toFixed(3)}</td><td style="padding: 5px;">${values[8].toFixed(3)}</td></tr>
                    </table>
                `;
            };

            const html = `
                <h3 style="margin-top: 0;">Chemical Shielding Tensor - ${element}${tensor.atom_index}</h3>
                <button onclick="closeTensorDetails()" style="position: absolute; top: 10px; right: 10px; border: none; background: #dc3545; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer;">‚úï</button>

                <h4>Total Tensor (ppm)</h4>
                ${formatTensor(tensor.total_tensor)}

                <h4>Diamagnetic Tensor (ppm)</h4>
                ${formatTensor(tensor.diamagnetic_tensor)}

                <h4>Paramagnetic Tensor (ppm)</h4>
                ${formatTensor(tensor.paramagnetic_tensor)}

                <h4>Isotropic Values</h4>
                <p><strong>Total:</strong> ${tensor.total_iso.toFixed(2)} ppm</p>
                <p><strong>Diamagnetic:</strong> ${tensor.sdso_iso.toFixed(2)} ppm</p>
                <p><strong>Paramagnetic:</strong> ${tensor.spso_iso.toFixed(2)} ppm</p>

                <h4>Eigenvalues (Diagonalized Components)</h4>
                <p>${tensor.total_components[0]?.toFixed(2) || 'N/A'}, ${tensor.total_components[1]?.toFixed(2) || 'N/A'}, ${tensor.total_components[2]?.toFixed(2) || 'N/A'} ppm</p>
            `;

            document.getElementById('tensor-details-modal').innerHTML = html;
            document.getElementById('tensor-details-modal').style.display = 'block';
            document.getElementById('tensor-modal-overlay').style.display = 'block';
        }

        function closeTensorDetails() {
            document.getElementById('tensor-details-modal').style.display = 'none';
            document.getElementById('tensor-modal-overlay').style.display = 'none';
        }

        // 6. HOMO-LUMO GAP TRACKER
        function renderHOMOLUMOGapTracker() {
            if (!data || !data.orbital_energies || data.orbital_energies.length === 0) return;

            // Find HOMO and LUMO for each optimization step
            // Note: We only have one set of orbital energies (final geometry)
            // For a true gap tracker, we'd need orbital energies at each optimization step

            // For now, show a single point with the final HOMO-LUMO gap
            const orbitals = data.orbital_energies;
            const homoIndex = orbitals.findIndex(o => o.occupation <= 0.5) - 1;

            if (homoIndex < 0 || homoIndex >= orbitals.length - 1) {
                // No HOMO-LUMO gap available
                return;
            }

            const homo = orbitals[homoIndex];
            const lumo = orbitals[homoIndex + 1];
            const gap = lumo.energy_ev - homo.energy_ev;

            // If we have optimization energies, create a placeholder plot
            if (data.optimization_energies && data.optimization_energies.length > 1) {
                const steps = Array.from({length: data.optimization_energies.length}, (_, i) => i + 1);
                const gaps = Array(data.optimization_energies.length).fill(gap); // Constant for now

                const trace = {
                    x: steps,
                    y: gaps,
                    mode: 'lines+markers',
                    name: 'HOMO-LUMO Gap',
                    line: {color: '#667eea', width: 3},
                    marker: {size: 8, color: '#764ba2'},
                    hovertemplate: 'Step %{x}<br>Gap: %{y:.4f} eV<extra></extra>'
                };

                const layout = {
                    title: 'HOMO-LUMO Energy Gap Evolution',
                    xaxis: {title: 'Optimization Step'},
                    yaxis: {title: 'HOMO-LUMO Gap (eV)'},
                    hovermode: 'closest',
                    annotations: [{
                        text: 'Note: Gap shown is from final geometry (orbital energies at intermediate steps not available)',
                        x: 0.5,
                        y: 1.1,
                        xref: 'paper',
                        yref: 'paper',
                        showarrow: false,
                        font: {size: 10, color: '#666'}
                    }]
                };

                Plotly.newPlot('homo-lumo-gap-plot', [trace], layout, {responsive: true});
            } else {
                // Single point
                const trace = {
                    x: [1],
                    y: [gap],
                    mode: 'markers',
                    name: 'HOMO-LUMO Gap',
                    marker: {size: 15, color: '#667eea'},
                    hovertemplate: 'Gap: %{y:.4f} eV<extra></extra>'
                };

                const layout = {
                    title: 'HOMO-LUMO Energy Gap',
                    xaxis: {title: 'Final Geometry', showticklabels: false},
                    yaxis: {title: 'HOMO-LUMO Gap (eV)'},
                    hovermode: 'closest'
                };

                Plotly.newPlot('homo-lumo-gap-plot', [trace], layout, {responsive: true});
            }
        }

        // 7. DENSITY OF STATES
        function renderDensityOfStates() {
            if (!data || !data.orbital_energies || data.orbital_energies.length === 0) return;

            const orbitals = data.orbital_energies;

            // Separate occupied and virtual orbitals
            const occupiedEnergies = orbitals.filter(o => o.occupation > 0.5).map(o => o.energy_ev);
            const virtualEnergies = orbitals.filter(o => o.occupation <= 0.5).map(o => o.energy_ev);

            // Create histogram with Gaussian broadening
            const sigma = 0.3; // eV
            const numPoints = 200;

            const allEnergies = orbitals.map(o => o.energy_ev);
            const minE = Math.min(...allEnergies) - 2;
            const maxE = Math.max(...allEnergies) + 2;
            const energyRange = Array.from({length: numPoints}, (_, i) => minE + (maxE - minE) * i / (numPoints - 1));

            // Gaussian function
            const gaussian = (x, mu, sigma) => Math.exp(-0.5 * Math.pow((x - mu) / sigma, 2)) / (sigma * Math.sqrt(2 * Math.PI));

            // Calculate DOS for occupied orbitals
            const dosOccupied = energyRange.map(E => {
                return occupiedEnergies.reduce((sum, e) => sum + gaussian(E, e, sigma), 0);
            });

            // Calculate DOS for virtual orbitals
            const dosVirtual = energyRange.map(E => {
                return virtualEnergies.reduce((sum, e) => sum + gaussian(E, e, sigma), 0);
            });

            const trace1 = {
                x: energyRange,
                y: dosOccupied,
                fill: 'tozeroy',
                name: 'Occupied',
                line: {color: '#28a745', width: 2},
                fillcolor: 'rgba(40, 167, 69, 0.3)',
                hovertemplate: 'Energy: %{x:.2f} eV<br>DOS: %{y:.4f}<extra></extra>'
            };

            const trace2 = {
                x: energyRange,
                y: dosVirtual,
                fill: 'tozeroy',
                name: 'Virtual',
                line: {color: '#dc3545', width: 2},
                fillcolor: 'rgba(220, 53, 69, 0.3)',
                hovertemplate: 'Energy: %{x:.2f} eV<br>DOS: %{y:.4f}<extra></extra>'
            };

            const layout = {
                title: 'Density of States (DOS)',
                xaxis: {title: 'Energy (eV)'},
                yaxis: {title: 'Density of States'},
                hovermode: 'x unified',
                showlegend: true,
                legend: {x: 0.8, y: 1}
            };

            Plotly.newPlot('dos-plot', [trace1, trace2], layout, {responsive: true});
        }

        // 8. MULLIKEN OVERLAP NETWORK
        let currentOverlapLayout = 'circular';
        let currentOverlapThreshold = 1.0;

        function renderMullikenOverlapNetwork() {
            if (!data || !data.mulliken_overlap_charges || data.mulliken_overlap_charges.length === 0) return;

            updateOverlapNetwork();
        }

        function updateOverlapNetwork() {
            if (!data || !data.mulliken_overlap_charges) return;

            const overlaps = data.mulliken_overlap_charges;

            // Filter by threshold
            const filteredOverlaps = overlaps.filter(o => Math.abs(o.overlap_charge) >= currentOverlapThreshold);

            if (filteredOverlaps.length === 0) {
                document.getElementById('overlap-network-plot').innerHTML = '<p style="text-align: center; padding: 40px;">No overlaps above threshold. Reduce minimum overlap value.</p>';
                return;
            }

            // Create nodes (unique atoms)
            const nodeIndices = new Set();
            filteredOverlaps.forEach(o => {
                nodeIndices.add(o.atom1_index);
                nodeIndices.add(o.atom2_index);
            });

            const nodes = Array.from(nodeIndices).map(idx => {
                const coord = data.coordinates[idx];
                return {
                    index: idx,
                    element: coord ? coord[0] : 'X',
                    x: coord ? coord[1] : 0,
                    y: coord ? coord[2] : 0,
                    z: coord ? coord[3] : 0
                };
            });

            let nodeX, nodeY, nodeZ;

            if (currentOverlapLayout === 'circular') {
                // Circular layout
                const n = nodes.length;
                nodeX = nodes.map((node, i) => 10 * Math.cos(2 * Math.PI * i / n));
                nodeY = nodes.map((node, i) => 10 * Math.sin(2 * Math.PI * i / n));
                nodeZ = nodes.map(() => 0);
            } else {
                // 3D molecular coordinates
                nodeX = nodes.map(n => n.x);
                nodeY = nodes.map(n => n.y);
                nodeZ = nodes.map(n => n.z);
            }

            // Edge traces
            const edgeTraces = [];
            filteredOverlaps.forEach(overlap => {
                const fromIdx = nodes.findIndex(n => n.index === overlap.atom1_index);
                const toIdx = nodes.findIndex(n => n.index === overlap.atom2_index);
                if (fromIdx >= 0 && toIdx >= 0) {
                    const absCharge = Math.abs(overlap.overlap_charge);
                    const edgeTrace = {
                        x: [nodeX[fromIdx], nodeX[toIdx], null],
                        y: [nodeY[fromIdx], nodeY[toIdx], null],
                        z: currentOverlapLayout === '3d' ? [nodeZ[fromIdx], nodeZ[toIdx], null] : undefined,
                        mode: 'lines',
                        line: {
                            width: Math.min(10, Math.max(1, absCharge / 2)),
                            color: overlap.overlap_charge > 0 ? '#28a745' : '#dc3545'
                        },
                        hovertemplate: `${nodes[fromIdx].element}${overlap.atom1_index} - ${nodes[toIdx].element}${overlap.atom2_index}<br>Overlap: ${overlap.overlap_charge.toFixed(3)}<extra></extra>`,
                        showlegend: false,
                        type: currentOverlapLayout === '3d' ? 'scatter3d' : 'scatter'
                    };
                    edgeTraces.push(edgeTrace);
                }
            });

            // Node trace
            const nodeTrace = {
                x: nodeX,
                y: nodeY,
                z: currentOverlapLayout === '3d' ? nodeZ : undefined,
                mode: 'markers+text',
                marker: {
                    size: 12,
                    color: nodes.map((_, i) => i),
                    colorscale: 'Viridis',
                    line: {width: 2, color: 'white'}
                },
                text: nodes.map(n => `${n.element}${n.index}`),
                textposition: 'top center',
                hovertemplate: 'Atom: %{text}<br>Index: %{customdata}<extra></extra>',
                customdata: nodes.map(n => n.index),
                type: currentOverlapLayout === '3d' ? 'scatter3d' : 'scatter'
            };

            const traces = [...edgeTraces, nodeTrace];

            const layout = {
                title: 'Mulliken Overlap Charges Network',
                showlegend: false,
                hovermode: 'closest',
                height: 600
            };

            if (currentOverlapLayout === 'circular') {
                layout.xaxis = {showgrid: false, zeroline: false, showticklabels: false};
                layout.yaxis = {showgrid: false, zeroline: false, showticklabels: false};
            } else {
                layout.scene = {
                    xaxis: {title: 'X (√Ö)'},
                    yaxis: {title: 'Y (√Ö)'},
                    zaxis: {title: 'Z (√Ö)'}
                };
            }

            Plotly.newPlot('overlap-network-plot', traces, layout, {responsive: true});
        }

        function updateOverlapLayout(layout) {
            currentOverlapLayout = layout;
            updateOverlapNetwork();
        }

        function updateOverlapThreshold(value) {
            currentOverlapThreshold = parseFloat(value);
            document.getElementById('overlap-threshold-label').textContent = value;
            updateOverlapNetwork();
        }

        // 9. POLARIZABILITY VISUALIZATION
        function renderPolarizabilityVisualization() {
            if (!data || !data.polarizability) return;

            const pol = data.polarizability;

            // Display tensor
            if (pol.tensor && pol.tensor.length === 3) {
                let tensorHTML = '<table style="margin: 10px auto; border-collapse: collapse; text-align: center;">';
                tensorHTML += '<tr><th style="padding: 8px; background: #667eea; color: white;">X</th><th style="padding: 8px; background: #667eea; color: white;">Y</th><th style="padding: 8px; background: #667eea; color: white;">Z</th></tr>';
                pol.tensor.forEach(row => {
                    tensorHTML += '<tr>';
                    row.forEach(val => {
                        tensorHTML += `<td style="padding: 8px; border: 1px solid #ddd;">${val.toFixed(4)}</td>`;
                    });
                    tensorHTML += '</tr>';
                });
                tensorHTML += '</table>';
                tensorHTML += `<p style="text-align: center; margin-top: 10px;"><strong>Isotropic:</strong> ${pol.isotropic.toFixed(4)} a.u.</p>`;
                document.getElementById('polarizability-tensor-display').innerHTML = tensorHTML;
            }

            // Display eigenvalues
            if (pol.eigenvalues && pol.eigenvalues.length === 3) {
                const eigenHTML = `
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; text-align: center;">
                        <div style="padding: 10px; background: white; border-radius: 4px;">
                            <strong>Œ±‚ÇÅ:</strong> ${pol.eigenvalues[0].toFixed(4)} a.u.
                        </div>
                        <div style="padding: 10px; background: white; border-radius: 4px;">
                            <strong>Œ±‚ÇÇ:</strong> ${pol.eigenvalues[1].toFixed(4)} a.u.
                        </div>
                        <div style="padding: 10px; background: white; border-radius: 4px;">
                            <strong>Œ±‚ÇÉ:</strong> ${pol.eigenvalues[2].toFixed(4)} a.u.
                        </div>
                    </div>
                `;
                document.getElementById('polarizability-eigenvalues').innerHTML = eigenHTML;

                // Create bar chart showing anisotropy
                const trace = {
                    x: ['Œ±‚ÇÅ', 'Œ±‚ÇÇ', 'Œ±‚ÇÉ'],
                    y: pol.eigenvalues,
                    type: 'bar',
                    marker: {
                        color: ['#667eea', '#764ba2', '#28a745']
                    },
                    hovertemplate: 'Component: %{x}<br>Value: %{y:.4f} a.u.<extra></extra>'
                };

                const avgValue = pol.isotropic;
                const avgLine = {
                    x: ['Œ±‚ÇÅ', 'Œ±‚ÇÇ', 'Œ±‚ÇÉ'],
                    y: [avgValue, avgValue, avgValue],
                    mode: 'lines',
                    name: 'Isotropic',
                    line: {color: '#dc3545', width: 2, dash: 'dash'},
                    hovertemplate: 'Isotropic: %{y:.4f} a.u.<extra></extra>'
                };

                const layout = {
                    title: 'Polarizability Principal Components',
                    xaxis: {title: 'Principal Component'},
                    yaxis: {title: 'Polarizability (a.u.)'},
                    showlegend: true,
                    hovermode: 'closest'
                };

                Plotly.newPlot('polarizability-plot', [trace, avgLine], layout, {responsive: true});
            }
        }

        // 10. BOND ORDER COMPARISON
        function renderBondOrderComparison() {
            if (!data || !data.mayer_bond_orders || data.mayer_bond_orders.length === 0) return;

            const mayerOrders = data.mayer_bond_orders;
            const loewdinOrders = data.loewdin_bond_orders || [];

            // Match bonds between both methods
            const bondLabels = [];
            const mayerValues = [];
            const loewdinValues = [];

            mayerOrders.forEach(mayer => {
                const loewdin = loewdinOrders.find(l =>
                    (l.atom1_index === mayer.atom1_index && l.atom2_index === mayer.atom2_index) ||
                    (l.atom1_index === mayer.atom2_index && l.atom2_index === mayer.atom1_index)
                );

                if (mayer.bond_order > 0.1) { // Filter weak bonds
                    const coord1 = data.coordinates[mayer.atom1_index];
                    const coord2 = data.coordinates[mayer.atom2_index];
                    const label = coord1 && coord2 ?
                        `${coord1[0]}${mayer.atom1_index}-${coord2[0]}${mayer.atom2_index}` :
                        `${mayer.atom1_index}-${mayer.atom2_index}`;

                    bondLabels.push(label);
                    mayerValues.push(mayer.bond_order);
                    loewdinValues.push(loewdin ? loewdin.bond_order : 0);
                }
            });

            const trace1 = {
                x: bondLabels,
                y: mayerValues,
                name: 'Mayer',
                type: 'bar',
                marker: {color: '#667eea'},
                hovertemplate: 'Bond: %{x}<br>Mayer: %{y:.3f}<extra></extra>'
            };

            const trace2 = {
                x: bondLabels,
                y: loewdinValues,
                name: 'Loewdin',
                type: 'bar',
                marker: {color: '#764ba2'},
                hovertemplate: 'Bond: %{x}<br>Loewdin: %{y:.3f}<extra></extra>'
            };

            const layout = {
                title: 'Bond Order Comparison: Mayer vs Loewdin',
                xaxis: {title: 'Bond', tickangle: -45},
                yaxis: {title: 'Bond Order'},
                barmode: 'group',
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('bond-order-comparison-plot', [trace1, trace2], layout, {responsive: true});
        }

        // 11. CHARGE COMPARISON
        function renderChargeComparison() {
            if (!data || !data.mulliken_charges || Object.keys(data.mulliken_charges).length === 0) return;
            if (!data.loewdin_charges || Object.keys(data.loewdin_charges).length === 0) return;

            const mullikenCharges = [];
            const loewdinCharges = [];
            const labels = [];

            Object.keys(data.mulliken_charges).forEach(atomIdx => {
                const mulliken = data.mulliken_charges[atomIdx][1];
                const loewdin = data.loewdin_charges[atomIdx] ? data.loewdin_charges[atomIdx][1] : null;

                if (loewdin !== null) {
                    mullikenCharges.push(mulliken);
                    loewdinCharges.push(loewdin);
                    labels.push(`${data.mulliken_charges[atomIdx][0]}${atomIdx}`);
                }
            });

            const trace = {
                x: mullikenCharges,
                y: loewdinCharges,
                mode: 'markers+text',
                marker: {
                    size: 10,
                    color: mullikenCharges,
                    colorscale: 'RdBu',
                    reversescale: true,
                    colorbar: {title: 'Charge'},
                    line: {width: 1, color: 'white'}
                },
                text: labels,
                textposition: 'top center',
                hovertemplate: 'Atom: %{text}<br>Mulliken: %{x:.3f}<br>Loewdin: %{y:.3f}<extra></extra>'
            };

            // Diagonal line (perfect agreement)
            const minCharge = Math.min(...mullikenCharges, ...loewdinCharges);
            const maxCharge = Math.max(...mullikenCharges, ...loewdinCharges);
            const diagonalTrace = {
                x: [minCharge, maxCharge],
                y: [minCharge, maxCharge],
                mode: 'lines',
                name: 'Perfect Agreement',
                line: {color: '#dc3545', width: 2, dash: 'dash'},
                hoverinfo: 'skip',
                showlegend: true
            };

            const layout = {
                title: 'Mulliken vs Loewdin Atomic Charges',
                xaxis: {title: 'Mulliken Charge'},
                yaxis: {title: 'Loewdin Charge'},
                hovermode: 'closest',
                showlegend: true
            };

            Plotly.newPlot('charge-comparison-plot', [trace, diagonalTrace], layout, {responsive: true});
        }

        // 12. ENERGY COMPONENTS
        function renderEnergyComponents() {
            if (!data || !data.energy_components) return;

            const ec = data.energy_components;

            const components = [];
            const values = [];
            const colors = [];

            if (ec.nuclear_repulsion !== undefined && ec.nuclear_repulsion !== 0) {
                components.push('Nuclear Repulsion');
                values.push(Math.abs(ec.nuclear_repulsion));
                colors.push('#ff6b6b');
            }
            if (ec.electronic_energy !== undefined && ec.electronic_energy !== 0) {
                components.push('Electronic Energy');
                values.push(Math.abs(ec.electronic_energy));
                colors.push('#4ecdc4');
            }
            if (ec.one_electron !== undefined && ec.one_electron !== 0) {
                components.push('One-Electron');
                values.push(Math.abs(ec.one_electron));
                colors.push('#667eea');
            }
            if (ec.two_electron !== undefined && ec.two_electron !== 0) {
                components.push('Two-Electron');
                values.push(Math.abs(ec.two_electron));
                colors.push('#764ba2');
            }
            if (ec.exchange_correlation !== undefined && ec.exchange_correlation !== 0) {
                components.push('Exchange-Correlation');
                values.push(Math.abs(ec.exchange_correlation));
                colors.push('#28a745');
            }

            if (components.length === 0) return;

            const trace = {
                labels: components,
                values: values,
                type: 'pie',
                marker: {colors: colors},
                hovertemplate: '%{label}<br>|Energy|: %{value:.4f} Eh<br>%{percent}<extra></extra>'
            };

            const layout = {
                title: 'Energy Components Breakdown (Absolute Values)',
                showlegend: true,
                height: 400
            };

            Plotly.newPlot('energy-components-plot', [trace], layout, {responsive: true});

            // Display details
            let detailsHTML = '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">';
            if (ec.nuclear_repulsion !== undefined) detailsHTML += `<div><strong>Nuclear Repulsion:</strong> ${ec.nuclear_repulsion.toFixed(6)} Eh</div>`;
            if (ec.electronic_energy !== undefined) detailsHTML += `<div><strong>Electronic Energy:</strong> ${ec.electronic_energy.toFixed(6)} Eh</div>`;
            if (ec.one_electron !== undefined) detailsHTML += `<div><strong>One-Electron:</strong> ${ec.one_electron.toFixed(6)} Eh</div>`;
            if (ec.two_electron !== undefined) detailsHTML += `<div><strong>Two-Electron:</strong> ${ec.two_electron.toFixed(6)} Eh</div>`;
            if (ec.exchange_correlation !== undefined) detailsHTML += `<div><strong>Exchange-Correlation:</strong> ${ec.exchange_correlation.toFixed(6)} Eh</div>`;
            detailsHTML += '</div>';
            document.getElementById('energy-components-details').innerHTML = detailsHTML;
        }

        // 13. DISPERSION CORRECTION
        function renderDispersionCorrection() {
            if (!data || !data.dispersion_correction) return;

            const disp = data.dispersion_correction;

            const trace = {
                x: ['E6 (C6)', 'E8 (C8)', 'Total'],
                y: [disp.e6 || 0, disp.e8 || 0, disp.total || 0],
                type: 'bar',
                marker: {
                    color: ['#667eea', '#764ba2', '#28a745']
                },
                hovertemplate: '%{x}<br>Energy: %{y:.6f} Eh<extra></extra>'
            };

            const layout = {
                title: 'DFTD3 Dispersion Correction',
                xaxis: {title: 'Component'},
                yaxis: {title: 'Energy (Eh)'},
                showlegend: false
            };

            Plotly.newPlot('dispersion-plot', [trace], layout, {responsive: true});

            // Display details
            let detailsHTML = `
                <h4 style="margin-top: 0;">Dispersion Parameters</h4>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <div><strong>E6 (C6):</strong> ${(disp.e6 || 0).toFixed(8)} Eh</div>
                    <div><strong>E8 (C8):</strong> ${(disp.e8 || 0).toFixed(8)} Eh</div>
                    <div><strong>Total:</strong> ${(disp.total || 0).toFixed(8)} Eh</div>
            `;
            if (disp.s6) detailsHTML += `<div><strong>s6 parameter:</strong> ${disp.s6.toFixed(4)}</div>`;
            if (disp.s8) detailsHTML += `<div><strong>s8 parameter:</strong> ${disp.s8.toFixed(4)}</div>`;
            detailsHTML += '</div>';
            document.getElementById('dispersion-details').innerHTML = detailsHTML;
        }

        // 14. ORBITAL POPULATION BY ELEMENT
        function renderOrbitalPopulation() {
            if (!data || !data.mulliken_orbital_populations || data.mulliken_orbital_populations.length === 0) return;

            const populations = data.mulliken_orbital_populations;

            // Group by atom
            const atomLabels = [];
            const sData = [];
            const pData = [];
            const dData = [];
            const fData = [];
            const gData = [];

            populations.forEach(pop => {
                const coord = data.coordinates[pop.atom_index];
                const label = coord ? `${coord[0]}${pop.atom_index}` : `Atom${pop.atom_index}`;
                atomLabels.push(label);

                sData.push(pop.s || 0);
                pData.push(pop.p || 0);
                dData.push(pop.d || 0);
                fData.push(pop.f || 0);
                gData.push(pop.g || 0);
            });

            const traces = [
                {x: atomLabels, y: sData, name: 's', type: 'bar', marker: {color: '#667eea'}},
                {x: atomLabels, y: pData, name: 'p', type: 'bar', marker: {color: '#764ba2'}},
                {x: atomLabels, y: dData, name: 'd', type: 'bar', marker: {color: '#28a745'}},
                {x: atomLabels, y: fData, name: 'f', type: 'bar', marker: {color: '#ffc107'}},
                {x: atomLabels, y: gData, name: 'g', type: 'bar', marker: {color: '#dc3545'}}
            ];

            // Only include traces with non-zero data
            const filteredTraces = traces.filter(t => t.y.some(val => val > 0));

            const layout = {
                title: 'Mulliken Orbital Population by Atom',
                xaxis: {title: 'Atom', tickangle: -45},
                yaxis: {title: 'Population'},
                barmode: 'stack',
                hovermode: 'closest',
                showlegend: true
            };

            if (filteredTraces.length > 0) {
                Plotly.newPlot('orbital-population-plot', filteredTraces, layout, {responsive: true});
            }
        }

        // 15. INTERNAL COORDINATES
        function renderInternalCoordinates() {
            if (!data || !data.internal_coords || data.internal_coords.length === 0) return;

            const coords = data.internal_coords;

            const bondLengths = coords.filter(c => c.bond_length !== undefined && c.bond_length > 0).map(c => c.bond_length);
            const bondAngles = coords.filter(c => c.bond_angle !== undefined && c.bond_angle > 0).map(c => c.bond_angle);
            const dihedrals = coords.filter(c => c.dihedral_angle !== undefined).map(c => c.dihedral_angle);

            const traces = [];

            if (bondLengths.length > 0) {
                traces.push({
                    x: bondLengths,
                    type: 'histogram',
                    name: 'Bond Lengths',
                    marker: {color: '#667eea'},
                    xaxis: 'x',
                    yaxis: 'y',
                    hovertemplate: 'Length: %{x:.3f} √Ö<br>Count: %{y}<extra></extra>'
                });
            }

            if (bondAngles.length > 0) {
                traces.push({
                    x: bondAngles,
                    type: 'histogram',
                    name: 'Bond Angles',
                    marker: {color: '#28a745'},
                    xaxis: 'x2',
                    yaxis: 'y2',
                    hovertemplate: 'Angle: %{x:.2f}¬∞<br>Count: %{y}<extra></extra>'
                });
            }

            const layout = {
                title: 'Internal Coordinates Distribution',
                grid: {rows: 1, columns: 2, pattern: 'independent'},
                xaxis: {title: 'Bond Length (√Ö)'},
                yaxis: {title: 'Count'},
                xaxis2: {title: 'Bond Angle (¬∞)'},
                yaxis2: {title: 'Count'},
                showlegend: true
            };

            if (traces.length > 0) {
                Plotly.newPlot('internal-coords-plot', traces, layout, {responsive: true});
            }
        }

        // 16. SCF ITERATION EFFICIENCY
        function renderSCFEfficiency() {
            if (!data || !data.scf_iterations || data.scf_iterations.length < 2) return;

            const iterations = data.scf_iterations;
            const energyReductions = [];
            const iterationNumbers = [];

            for (let i = 1; i < iterations.length; i++) {
                const reduction = iterations[i-1].energy - iterations[i].energy;
                energyReductions.push(reduction);
                iterationNumbers.push(i);
            }

            const trace = {
                x: iterationNumbers,
                y: energyReductions,
                mode: 'lines+markers',
                name: 'Energy Reduction',
                line: {color: '#667eea', width: 3},
                marker: {size: 8, color: '#764ba2'},
                hovertemplate: 'Iteration %{x}<br>ŒîE: %{y:.6e} Eh<extra></extra>'
            };

            const layout = {
                title: 'SCF Iteration Efficiency (Energy Reduction per Step)',
                xaxis: {title: 'Iteration'},
                yaxis: {title: 'Energy Reduction (Eh)', type: 'log'},
                hovermode: 'closest',
                showlegend: false
            };

            Plotly.newPlot('scf-efficiency-plot', [trace], layout, {responsive: true});
        }

        // 17. CPCM SOLVATION ANALYSIS
        function renderSolvationAnalysis() {
            if (!data || !data.cpcm_solvation) return;

            const solv = data.cpcm_solvation;

            const components = [];
            const values = [];
            const colors = ['#667eea', '#764ba2', '#28a745', '#ffc107'];

            if (solv.electrostatic !== undefined && solv.electrostatic !== 0) {
                components.push('Electrostatic');
                values.push(Math.abs(solv.electrostatic));
            }
            if (solv.cavitation !== undefined && solv.cavitation !== 0) {
                components.push('Cavitation');
                values.push(Math.abs(solv.cavitation));
            }
            if (solv.dispersion !== undefined && solv.dispersion !== 0) {
                components.push('Dispersion');
                values.push(Math.abs(solv.dispersion));
            }
            if (solv.repulsion !== undefined && solv.repulsion !== 0) {
                components.push('Repulsion');
                values.push(Math.abs(solv.repulsion));
            }

            if (components.length === 0) return;

            const trace = {
                labels: components,
                values: values,
                type: 'pie',
                marker: {colors: colors.slice(0, components.length)},
                hovertemplate: '%{label}<br>|Energy|: %{value:.6f} Eh<br>%{percent}<extra></extra>'
            };

            const layout = {
                title: 'CPCM Solvation Energy Components',
                showlegend: true
            };

            Plotly.newPlot('solvation-plot', [trace], layout, {responsive: true});

            // Details table
            let detailsHTML = '<h4 style="margin-top: 0;">Solvation Energy Details</h4><div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">';
            if (solv.electrostatic !== undefined) detailsHTML += `<div><strong>Electrostatic:</strong> ${solv.electrostatic.toFixed(6)} Eh</div>`;
            if (solv.cavitation !== undefined) detailsHTML += `<div><strong>Cavitation:</strong> ${solv.cavitation.toFixed(6)} Eh</div>`;
            if (solv.dispersion !== undefined) detailsHTML += `<div><strong>Dispersion:</strong> ${solv.dispersion.toFixed(6)} Eh</div>`;
            if (solv.repulsion !== undefined) detailsHTML += `<div><strong>Repulsion:</strong> ${solv.repulsion.toFixed(6)} Eh</div>`;
            if (solv.total_solvation_energy !== undefined) detailsHTML += `<div><strong>Total:</strong> ${solv.total_solvation_energy.toFixed(6)} Eh</div>`;
            detailsHTML += '</div>';
            document.getElementById('solvation-details').innerHTML = detailsHTML;
        }

        // 18. ORBITAL ENERGY DISTRIBUTION
        function renderOrbitalDistribution() {
            if (!data || !data.orbital_energies || data.orbital_energies.length === 0) return;

            const energies = data.orbital_energies.map(o => o.energy_ev);

            const trace = {
                x: energies,
                type: 'histogram',
                nbinsx: 30,
                marker: {
                    color: '#667eea',
                    line: {color: 'white', width: 1}
                },
                hovertemplate: 'Energy: %{x:.2f} eV<br>Count: %{y}<extra></extra>'
            };

            const layout = {
                title: 'Orbital Energy Distribution',
                xaxis: {title: 'Energy (eV)'},
                yaxis: {title: 'Number of Orbitals'},
                showlegend: false
            };

            Plotly.newPlot('orbital-distribution-plot', [trace], layout, {responsive: true});
        }

        // 19. FREQUENCY ANALYSIS BY TYPE
        function renderFrequencyAnalysis() {
            if (!data || !data.frequencies || data.frequencies.length === 0) return;

            const frequencies = data.frequencies;
            const irSpectrum = data.ir_spectrum || [];
            const ramanSpectrum = data.raman_spectrum || [];

            // Categorize frequencies
            const low = [], mid = [], high = [];
            const lowIR = [], midIR = [], highIR = [];

            frequencies.forEach((freq, i) => {
                const intensity = irSpectrum[i] ? irSpectrum[i].intensity : 0;
                if (freq < 1000) {
                    low.push(freq);
                    lowIR.push(intensity);
                } else if (freq < 2000) {
                    mid.push(freq);
                    midIR.push(intensity);
                } else {
                    high.push(freq);
                    highIR.push(intensity);
                }
            });

            const trace1 = {
                x: ['Low (<1000)', 'Mid (1000-2000)', 'High (>2000)'],
                y: [low.length, mid.length, high.length],
                name: 'Mode Count',
                type: 'bar',
                marker: {color: '#667eea'},
                hovertemplate: 'Range: %{x}<br>Modes: %{y}<extra></extra>'
            };

            const avgLowIR = low.length > 0 ? lowIR.reduce((a,b) => a+b, 0) / low.length : 0;
            const avgMidIR = mid.length > 0 ? midIR.reduce((a,b) => a+b, 0) / mid.length : 0;
            const avgHighIR = high.length > 0 ? highIR.reduce((a,b) => a+b, 0) / high.length : 0;

            const trace2 = {
                x: ['Low (<1000)', 'Mid (1000-2000)', 'High (>2000)'],
                y: [avgLowIR, avgMidIR, avgHighIR],
                name: 'Avg IR Intensity',
                type: 'bar',
                marker: {color: '#28a745'},
                yaxis: 'y2',
                hovertemplate: 'Range: %{x}<br>Avg IR: %{y:.2f} km/mol<extra></extra>'
            };

            const layout = {
                title: 'Frequency Analysis by Energy Range',
                xaxis: {title: 'Frequency Range (cm‚Åª¬π)'},
                yaxis: {title: 'Number of Modes'},
                yaxis2: {title: 'Avg IR Intensity (km/mol)', overlaying: 'y', side: 'right'},
                showlegend: true,
                barmode: 'group'
            };

            Plotly.newPlot('frequency-analysis-plot', [trace1, trace2], layout, {responsive: true});
        }

        // 20. CHARGE DISTRIBUTION PIE
        function renderChargeDistributionPie() {
            if (!data || !data.mulliken_charges || Object.keys(data.mulliken_charges).length === 0) return;

            let positive = 0, negative = 0, neutral = 0;

            Object.values(data.mulliken_charges).forEach(([element, charge]) => {
                if (charge > 0.1) positive++;
                else if (charge < -0.1) negative++;
                else neutral++;
            });

            const trace = {
                labels: ['Positive', 'Neutral', 'Negative'],
                values: [positive, neutral, negative],
                type: 'pie',
                marker: {colors: ['#dc3545', '#ffc107', '#28a745']},
                hovertemplate: '%{label}<br>Count: %{value}<br>%{percent}<extra></extra>'
            };

            const layout = {
                title: 'Atomic Charge Distribution (Mulliken)',
                showlegend: true
            };

            Plotly.newPlot('charge-distribution-plot', [trace], layout, {responsive: true});
        }

        // 21. BOND ORDER VS LENGTH CORRELATION
        function renderBondCorrelation() {
            if (!data || !data.mayer_bond_orders || data.mayer_bond_orders.length === 0) return;
            if (!data.internal_coords || data.internal_coords.length === 0) return;

            const bondOrders = [];
            const bondLengths = [];
            const bondLabels = [];

            data.mayer_bond_orders.forEach(bond => {
                // Find corresponding bond length from internal coords
                const intCoord = data.internal_coords.find(ic =>
                    ic.bond_to === bond.atom1_index || ic.bond_to === bond.atom2_index
                );

                if (intCoord && intCoord.bond_length && bond.bond_order > 0.1) {
                    bondOrders.push(bond.bond_order);
                    bondLengths.push(intCoord.bond_length);
                    const coord1 = data.coordinates[bond.atom1_index];
                    const coord2 = data.coordinates[bond.atom2_index];
                    const label = coord1 && coord2 ?
                        `${coord1[0]}${bond.atom1_index}-${coord2[0]}${bond.atom2_index}` :
                        `${bond.atom1_index}-${bond.atom2_index}`;
                    bondLabels.push(label);
                }
            });

            if (bondOrders.length === 0) return;

            const trace = {
                x: bondLengths,
                y: bondOrders,
                mode: 'markers',
                marker: {
                    size: 10,
                    color: bondOrders,
                    colorscale: 'Viridis',
                    colorbar: {title: 'Bond Order'},
                    line: {width: 1, color: 'white'}
                },
                text: bondLabels,
                hovertemplate: 'Bond: %{text}<br>Length: %{x:.3f} √Ö<br>Order: %{y:.3f}<extra></extra>'
            };

            const layout = {
                title: 'Bond Order vs Bond Length Correlation',
                xaxis: {title: 'Bond Length (√Ö)'},
                yaxis: {title: 'Bond Order (Mayer)'},
                hovermode: 'closest'
            };

            Plotly.newPlot('bond-correlation-plot', [trace], layout, {responsive: true});
        }

        // 22. ORBITAL EIGENVALUE SPECTRUM
        function renderEigenvalueSpectrum() {
            if (!data || !data.orbital_energies || data.orbital_energies.length === 0) return;

            const orbitals = data.orbital_energies;
            const homoIndex = orbitals.findIndex(o => o.occupation <= 0.5) - 1;

            const energies = orbitals.map(o => o.energy_ev);
            const indices = orbitals.map((o, i) => i);
            const colors = orbitals.map((o, i) =>
                i === homoIndex ? '#dc3545' :
                i === homoIndex + 1 ? '#28a745' :
                o.occupation > 0.5 ? '#667eea' : '#ffc107'
            );

            const trace = {
                x: energies,
                y: indices,
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: colors,
                    line: {width: 0.5, color: 'white'}
                },
                hovertemplate: 'MO %{y}<br>Energy: %{x:.3f} eV<br>Occ: %{customdata:.1f}<extra></extra>',
                customdata: orbitals.map(o => o.occupation)
            };

            const layout = {
                title: 'Orbital Eigenvalue Spectrum',
                xaxis: {title: 'Energy (eV)'},
                yaxis: {title: 'Molecular Orbital Index', autorange: 'reversed'},
                height: Math.min(800, orbitals.length * 3 + 100),
                showlegend: false,
                annotations: homoIndex >= 0 ? [{
                    x: orbitals[homoIndex].energy_ev,
                    y: homoIndex,
                    text: 'HOMO',
                    showarrow: true,
                    arrowhead: 2
                }, {
                    x: orbitals[homoIndex + 1].energy_ev,
                    y: homoIndex + 1,
                    text: 'LUMO',
                    showarrow: true,
                    arrowhead: 2
                }] : []
            };

            Plotly.newPlot('eigenvalue-spectrum-plot', [trace], layout, {responsive: true});
        }

        // 23. IR VS RAMAN CORRELATION
        function renderIRRamanCorrelation() {
            if (!data || !data.ir_spectrum || data.ir_spectrum.length === 0) return;
            if (!data.raman_spectrum || data.raman_spectrum.length === 0) return;

            const irIntensities = [];
            const ramanActivities = [];
            const frequencies = [];

            data.ir_spectrum.forEach((ir, i) => {
                const raman = data.raman_spectrum[i];
                if (raman) {
                    irIntensities.push(ir.intensity);
                    ramanActivities.push(raman.activity);
                    frequencies.push(data.frequencies[i] || i);
                }
            });

            const trace = {
                x: irIntensities,
                y: ramanActivities,
                mode: 'markers',
                marker: {
                    size: 8,
                    color: frequencies,
                    colorscale: 'Jet',
                    colorbar: {title: 'Frequency (cm‚Åª¬π)'},
                    line: {width: 1, color: 'white'}
                },
                text: frequencies.map(f => `${f.toFixed(1)} cm‚Åª¬π`),
                hovertemplate: 'Frequency: %{text}<br>IR: %{x:.2f} km/mol<br>Raman: %{y:.2f}<extra></extra>'
            };

            const layout = {
                title: 'IR vs Raman Activity Correlation',
                xaxis: {title: 'IR Intensity (km/mol)', type: 'log'},
                yaxis: {title: 'Raman Activity', type: 'log'},
                hovermode: 'closest'
            };

            Plotly.newPlot('ir-raman-correlation-plot', [trace], layout, {responsive: true});
        }

        // 24. ATOMIC MASS DISTRIBUTION
        function renderMassDistribution() {
            if (!data || !data.coordinates_au || data.coordinates_au.length === 0) return;

            // Group by element
            const elementMasses = {};
            data.coordinates_au.forEach(coord => {
                const element = coord[0]; // element symbol
                const mass = coord[5];    // atomic mass
                if (!elementMasses[element]) {
                    elementMasses[element] = 0;
                }
                elementMasses[element] += mass;
            });

            const elements = Object.keys(elementMasses).sort();
            const masses = elements.map(e => elementMasses[e]);

            const trace = {
                x: elements,
                y: masses,
                type: 'bar',
                marker: {
                    color: masses,
                    colorscale: 'Viridis',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Element: %{x}<br>Total Mass: %{y:.2f} amu<extra></extra>'
            };

            const layout = {
                title: 'Atomic Mass Distribution by Element',
                xaxis: {title: 'Element'},
                yaxis: {title: 'Total Mass (amu)'},
                showlegend: false
            };

            Plotly.newPlot('mass-distribution-plot', [trace], layout, {responsive: true});
        }

        function renderDipoleComponents() {
            if (!data || !data.dipole_moment_components || data.dipole_moment_components.length === 0) return;

            const labels = ['X', 'Y', 'Z'];
            const values = data.dipole_moment_components.slice(0, 3); // X, Y, Z components
            const magnitude = Math.sqrt(values.reduce((sum, v) => sum + v*v, 0));

            const trace = {
                x: labels,
                y: values,
                type: 'bar',
                marker: {
                    color: ['#FF6B6B', '#4ECDC4', '#45B7D1'],
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Component %{x}<br>Value: %{y:.4f} Debye<extra></extra>'
            };

            const layout = {
                title: `Dipole Moment Components (Total: ${magnitude.toFixed(4)} Debye)`,
                xaxis: {title: 'Component'},
                yaxis: {title: 'Dipole Moment (Debye)'},
                showlegend: false
            };

            Plotly.newPlot('dipole-components-plot', [trace], layout, {responsive: true});
        }

        function renderThermoBreakdown() {
            if (!data || !data.thermochemistry) return;

            const thermo = data.thermochemistry;
            const categories = [];
            const values = [];

            if (thermo.zero_point_energy !== null) {
                categories.push('Zero-Point Energy');
                values.push(thermo.zero_point_energy);
            }
            if (thermo.thermal_correction_energy !== null) {
                categories.push('Thermal Correction (E)');
                values.push(thermo.thermal_correction_energy);
            }
            if (thermo.thermal_correction_enthalpy !== null) {
                categories.push('Thermal Correction (H)');
                values.push(thermo.thermal_correction_enthalpy);
            }
            if (thermo.thermal_correction_gibbs !== null) {
                categories.push('Thermal Correction (G)');
                values.push(thermo.thermal_correction_gibbs);
            }

            if (categories.length === 0) return;

            const trace = {
                x: categories,
                y: values,
                type: 'bar',
                marker: {
                    color: values,
                    colorscale: 'Portland',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: '%{x}<br>Energy: %{y:.6f} Eh<extra></extra>'
            };

            const layout = {
                title: 'Thermochemistry Energy Components',
                xaxis: {title: 'Component', tickangle: -45},
                yaxis: {title: 'Energy (Eh)'},
                showlegend: false,
                margin: {b: 120}
            };

            Plotly.newPlot('thermo-breakdown-plot', [trace], layout, {responsive: true});
        }

        function renderAtomStats() {
            if (!data || !data.coordinates_au || data.coordinates_au.length === 0) return;

            // Count atoms by element
            const elementCounts = {};
            data.coordinates_au.forEach(coord => {
                const element = coord[0];
                elementCounts[element] = (elementCounts[element] || 0) + 1;
            });

            const elements = Object.keys(elementCounts).sort();
            const counts = elements.map(e => elementCounts[e]);

            const trace = {
                x: elements,
                y: counts,
                type: 'bar',
                marker: {
                    color: counts,
                    colorscale: 'Viridis',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Element: %{x}<br>Count: %{y}<extra></extra>'
            };

            const layout = {
                title: 'Atom Type Statistics',
                xaxis: {title: 'Element'},
                yaxis: {title: 'Count'},
                showlegend: false
            };

            Plotly.newPlot('atom-stats-plot', [trace], layout, {responsive: true});
        }

        function renderAngleDistribution() {
            if (!data || !data.coordinates_au || data.coordinates_au.length < 3) return;

            // Calculate all bond angles
            const coords = data.coordinates_au;
            const angles = [];

            // Helper to calculate angle between three points
            const calculateAngle = (p1, p2, p3) => {
                const v1 = [p1[1] - p2[1], p1[2] - p2[2], p1[3] - p2[3]];
                const v2 = [p3[1] - p2[1], p3[2] - p2[2], p3[3] - p2[3]];

                const dot = v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
                const mag1 = Math.sqrt(v1[0]**2 + v1[1]**2 + v1[2]**2);
                const mag2 = Math.sqrt(v2[0]**2 + v2[1]**2 + v2[2]**2);

                return Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
            };

            // Sample angles to avoid too many calculations
            const maxAngles = 1000;
            const step = Math.max(1, Math.floor(coords.length / 10));

            for (let i = 0; i < coords.length && angles.length < maxAngles; i += step) {
                for (let j = i + 1; j < coords.length && angles.length < maxAngles; j += step) {
                    for (let k = j + 1; k < coords.length && angles.length < maxAngles; k += step) {
                        const angle = calculateAngle(coords[i], coords[j], coords[k]);
                        if (!isNaN(angle)) angles.push(angle);
                    }
                }
            }

            if (angles.length === 0) return;

            const trace = {
                x: angles,
                type: 'histogram',
                nbinsx: 36,
                marker: {
                    color: '#667eea',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Angle: %{x:.1f}¬∞<br>Count: %{y}<extra></extra>'
            };

            const layout = {
                title: 'Bond Angle Distribution',
                xaxis: {title: 'Angle (degrees)'},
                yaxis: {title: 'Frequency'},
                showlegend: false
            };

            Plotly.newPlot('angle-distribution-plot', [trace], layout, {responsive: true});
        }

        function renderElementComposition() {
            if (!data || !data.coordinates_au || data.coordinates_au.length === 0) return;

            // Count atoms by element
            const elementCounts = {};
            data.coordinates_au.forEach(coord => {
                const element = coord[0];
                elementCounts[element] = (elementCounts[element] || 0) + 1;
            });

            const elements = Object.keys(elementCounts).sort();
            const counts = elements.map(e => elementCounts[e]);

            const trace = {
                labels: elements,
                values: counts,
                type: 'pie',
                marker: {
                    colors: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'],
                    line: {width: 2, color: 'white'}
                },
                hovertemplate: '%{label}<br>Count: %{value}<br>Percentage: %{percent}<extra></extra>',
                textinfo: 'label+percent'
            };

            const layout = {
                title: 'Molecular Element Composition',
                showlegend: true
            };

            Plotly.newPlot('element-composition-plot', [trace], layout, {responsive: true});
        }

        function renderOptConvergence() {
            if (!data || !data.opt_energies || data.opt_energies.length === 0) return;

            const iterations = Array.from({length: data.opt_energies.length}, (_, i) => i + 1);

            // Energy trace
            const energyTrace = {
                x: iterations,
                y: data.opt_energies,
                mode: 'lines+markers',
                name: 'Energy',
                yaxis: 'y1',
                line: {color: '#667eea', width: 2},
                marker: {size: 6},
                hovertemplate: 'Iteration: %{x}<br>Energy: %{y:.6f} Eh<extra></extra>'
            };

            // Gradient norm trace (if available)
            const traces = [energyTrace];
            const layout = {
                title: 'Optimization Convergence Metrics',
                xaxis: {title: 'Optimization Step'},
                yaxis: {title: 'Energy (Eh)', side: 'left'},
                showlegend: true,
                hovermode: 'x unified'
            };

            // Add gradient if available
            if (data.opt_gradients && data.opt_gradients.length > 0) {
                const gradTrace = {
                    x: iterations.slice(0, data.opt_gradients.length),
                    y: data.opt_gradients,
                    mode: 'lines+markers',
                    name: 'Gradient Norm',
                    yaxis: 'y2',
                    line: {color: '#e74c3c', width: 2},
                    marker: {size: 6},
                    hovertemplate: 'Iteration: %{x}<br>Gradient: %{y:.4e}<extra></extra>'
                };
                traces.push(gradTrace);
                layout.yaxis2 = {
                    title: 'Gradient Norm',
                    overlaying: 'y',
                    side: 'right'
                };
            }

            Plotly.newPlot('opt-convergence-plot', traces, layout, {responsive: true});
        }

        function renderPopulationCorrelation() {
            if (!data || !data.mulliken_charges || !data.loewdin_charges) return;
            if (data.mulliken_charges.length === 0 || data.loewdin_charges.length === 0) return;

            const minLen = Math.min(data.mulliken_charges.length, data.loewdin_charges.length);
            const mulliken = data.mulliken_charges.slice(0, minLen);
            const loewdin = data.loewdin_charges.slice(0, minLen);

            const trace = {
                x: mulliken,
                y: loewdin,
                mode: 'markers',
                type: 'scatter',
                marker: {
                    size: 8,
                    color: mulliken,
                    colorscale: 'RdBu',
                    colorbar: {title: 'Mulliken'},
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Mulliken: %{x:.4f}<br>L√∂wdin: %{y:.4f}<extra></extra>'
            };

            // Add diagonal line
            const min = Math.min(...mulliken, ...loewdin);
            const max = Math.max(...mulliken, ...loewdin);
            const diagonalTrace = {
                x: [min, max],
                y: [min, max],
                mode: 'lines',
                line: {color: 'gray', dash: 'dash'},
                showlegend: false,
                hoverinfo: 'skip'
            };

            const layout = {
                title: 'Mulliken vs L√∂wdin Population Analysis',
                xaxis: {title: 'Mulliken Charges'},
                yaxis: {title: 'L√∂wdin Charges'},
                showlegend: false
            };

            Plotly.newPlot('population-correlation-plot', [trace, diagonalTrace], layout, {responsive: true});
        }

        function renderDistanceAnalysis() {
            if (!data || !data.coordinates_au || data.coordinates_au.length < 2) return;

            const coords = data.coordinates_au;
            const distances = [];

            // Calculate all pairwise distances
            for (let i = 0; i < coords.length; i++) {
                for (let j = i + 1; j < coords.length; j++) {
                    const dx = coords[i][1] - coords[j][1];
                    const dy = coords[i][2] - coords[j][2];
                    const dz = coords[i][3] - coords[j][3];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) * 0.529177; // Convert to Angstroms
                    distances.push(dist);
                }
            }

            const trace = {
                x: distances,
                type: 'histogram',
                nbinsx: 50,
                marker: {
                    color: '#45B7D1',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Distance: %{x:.2f} √Ö<br>Count: %{y}<extra></extra>'
            };

            const layout = {
                title: 'Interatomic Distance Distribution',
                xaxis: {title: 'Distance (√Ö)'},
                yaxis: {title: 'Frequency'},
                showlegend: false
            };

            Plotly.newPlot('distance-analysis-plot', [trace], layout, {responsive: true});
        }

        function renderCoordinationNumbers() {
            if (!data || !data.coordinates_au || data.coordinates_au.length < 2) return;

            const coords = data.coordinates_au;
            const cutoff = 3.5; // Angstrom cutoff for coordination
            const coordinationNumbers = [];

            // Calculate coordination number for each atom
            for (let i = 0; i < coords.length; i++) {
                let neighbors = 0;
                for (let j = 0; j < coords.length; j++) {
                    if (i === j) continue;
                    const dx = coords[i][1] - coords[j][1];
                    const dy = coords[i][2] - coords[j][2];
                    const dz = coords[i][3] - coords[j][3];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) * 0.529177; // Convert to Angstroms
                    if (dist < cutoff) neighbors++;
                }
                coordinationNumbers.push(neighbors);
            }

            const labels = coords.map((c, i) => `${c[0]}${i+1}`);

            const trace = {
                x: labels,
                y: coordinationNumbers,
                type: 'bar',
                marker: {
                    color: coordinationNumbers,
                    colorscale: 'Viridis',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Atom: %{x}<br>Coordination #: %{y}<extra></extra>'
            };

            const layout = {
                title: `Coordination Numbers (cutoff: ${cutoff} √Ö)`,
                xaxis: {title: 'Atom', tickangle: -45},
                yaxis: {title: 'Coordination Number'},
                showlegend: false,
                margin: {b: 100}
            };

            Plotly.newPlot('coordination-plot', [trace], layout, {responsive: true});
        }

        function renderSCFDashboard() {
            if (!data || !data.scf_convergence) return;

            const conv = data.scf_convergence;
            const labels = [];
            const values = [];
            const thresholds = [];

            if (conv.energy_change !== null) {
                labels.push('Energy Change');
                values.push(Math.abs(conv.energy_change));
                thresholds.push(1e-6); // typical threshold
            }
            if (conv.density_change !== null) {
                labels.push('Density Change');
                values.push(Math.abs(conv.density_change));
                thresholds.push(1e-5);
            }
            if (conv.max_element !== null) {
                labels.push('Max Element');
                values.push(Math.abs(conv.max_element));
                thresholds.push(1e-4);
            }

            if (labels.length === 0) return;

            // Values trace (log scale)
            const valuesTrace = {
                x: labels,
                y: values,
                type: 'bar',
                name: 'Actual Value',
                marker: {
                    color: values.map((v, i) => v < thresholds[i] ? '#2ecc71' : '#e74c3c'),
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: '%{x}<br>Value: %{y:.2e}<extra></extra>'
            };

            // Threshold trace
            const thresholdTrace = {
                x: labels,
                y: thresholds,
                type: 'scatter',
                mode: 'markers',
                name: 'Threshold',
                marker: {size: 12, color: 'orange', symbol: 'line-ew', line: {width: 3}},
                hovertemplate: '%{x}<br>Threshold: %{y:.2e}<extra></extra>'
            };

            const layout = {
                title: 'SCF Convergence Criteria (Final Values)',
                xaxis: {title: 'Criterion'},
                yaxis: {title: 'Value', type: 'log'},
                showlegend: true,
                annotations: labels.map((label, i) => ({
                    x: label,
                    y: values[i],
                    text: values[i] < thresholds[i] ? '‚úì' : '‚úó',
                    showarrow: false,
                    yshift: 20,
                    font: {size: 16, color: values[i] < thresholds[i] ? '#2ecc71' : '#e74c3c'}
                }))
            };

            Plotly.newPlot('scf-dashboard-plot', [valuesTrace, thresholdTrace], layout, {responsive: true});
        }

        function renderEnergyWaterfall() {
            if (!data || !data.energy_components) return;

            const ec = data.energy_components;
            const components = [];

            // Build waterfall components
            if (ec.nuclear_repulsion !== null) components.push({label: 'Nuclear Repulsion', value: ec.nuclear_repulsion});
            if (ec.electronic_energy !== null) components.push({label: 'Electronic', value: ec.electronic_energy});
            if (ec.kinetic_energy !== null) components.push({label: 'Kinetic', value: ec.kinetic_energy});
            if (ec.potential_energy !== null) components.push({label: 'Potential', value: ec.potential_energy});
            if (ec.xc_energy !== null) components.push({label: 'XC Energy', value: ec.xc_energy});
            if (data.final_energy !== null) components.push({label: 'Total Energy', value: data.final_energy});

            if (components.length === 0) return;

            const trace = {
                x: components.map(c => c.label),
                y: components.map(c => c.value),
                type: 'waterfall',
                orientation: 'v',
                connector: {
                    line: {color: 'rgb(63, 63, 63)'}
                },
                decreasing: {marker: {color: '#e74c3c'}},
                increasing: {marker: {color: '#2ecc71'}},
                totals: {marker: {color: '#667eea'}},
                hovertemplate: '%{x}<br>Energy: %{y:.6f} Eh<extra></extra>'
            };

            const layout = {
                title: 'Energy Decomposition Waterfall',
                xaxis: {title: 'Component', tickangle: -45},
                yaxis: {title: 'Energy (Eh)'},
                showlegend: false,
                margin: {b: 120}
            };

            Plotly.newPlot('energy-waterfall-plot', [trace], layout, {responsive: true});
        }

        function renderPerformanceDashboard() {
            if (!data) return;

            const metrics = [];
            const values = [];

            // Total runtime
            if (data.total_run_time && data.total_run_time.total_seconds) {
                metrics.push('Total Runtime (s)');
                values.push(data.total_run_time.total_seconds);
            }

            // SCF iterations per second
            if (data.scf_energies && data.total_run_time && data.total_run_time.total_seconds) {
                const iterPerSec = data.scf_energies.length / data.total_run_time.total_seconds;
                metrics.push('SCF Iterations/sec');
                values.push(iterPerSec);
            }

            // Time per optimization step
            if (data.opt_energies && data.opt_energies.length > 1 && data.total_run_time && data.total_run_time.total_seconds) {
                const timePerStep = data.total_run_time.total_seconds / data.opt_energies.length;
                metrics.push('Time/Opt Step (s)');
                values.push(timePerStep);
            }

            // Number of basis functions
            if (data.basis_functions !== null) {
                metrics.push('Basis Functions');
                values.push(data.basis_functions);
            }

            if (metrics.length === 0) return;

            const trace = {
                x: metrics,
                y: values,
                type: 'bar',
                marker: {
                    color: ['#667eea', '#2ecc71', '#f39c12', '#9b59b6'],
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: '%{x}<br>Value: %{y:.2f}<extra></extra>'
            };

            const layout = {
                title: 'Computational Performance Metrics',
                xaxis: {title: 'Metric', tickangle: -45},
                yaxis: {title: 'Value'},
                showlegend: false,
                margin: {b: 100}
            };

            Plotly.newPlot('performance-dashboard-plot', [trace], layout, {responsive: true});
        }

        // PHASE 3F.4: Memory Usage Tracking
        function renderMemoryUsage() {
            if (!data) return;

            // Estimate memory usage from calculation parameters
            const memoryComponents = [];
            const memoryMB = [];
            const colors = [];

            // SCF memory (estimated from basis functions and orbitals)
            if (data.basis_functions && data.orbital_energies) {
                const nBasis = data.basis_functions;
                const nOrbitals = data.orbital_energies.length;
                // Estimate: O(N¬≤) for Fock matrix + density matrix
                const scfMemory = (nBasis * nBasis * 8) / (1024 * 1024); // 8 bytes per double
                memoryComponents.push('SCF Matrices');
                memoryMB.push(scfMemory);
                colors.push('#667eea');
            }

            // Integral storage (estimated)
            if (data.basis_functions) {
                const nBasis = data.basis_functions;
                // Estimate: O(N‚Å¥) two-electron integrals (sparse storage)
                const integralMemory = (nBasis * nBasis * nBasis * nBasis * 0.01 * 8) / (1024 * 1024);
                memoryComponents.push('Integral Storage');
                memoryMB.push(integralMemory);
                colors.push('#2ecc71');
            }

            // Optimization trajectory memory
            if (data.opt_energies && data.opt_energies.length > 1 && data.coordinates) {
                const nSteps = data.opt_energies.length;
                const nAtoms = data.coordinates.length;
                // Store coordinates and gradients for each step
                const optMemory = (nSteps * nAtoms * 6 * 8) / (1024 * 1024); // coords + gradients
                memoryComponents.push('Optimization Data');
                memoryMB.push(optMemory);
                colors.push('#f39c12');
            }

            // Orbital coefficient storage
            if (data.orbital_energies && data.basis_functions) {
                const nOrbitals = data.orbital_energies.length;
                const nBasis = data.basis_functions;
                const orbitalMemory = (nOrbitals * nBasis * 8) / (1024 * 1024);
                memoryComponents.push('Orbital Coefficients');
                memoryMB.push(orbitalMemory);
                colors.push('#9b59b6');
            }

            // Vibrational analysis memory
            if (data.frequencies && data.frequencies.length > 0 && data.coordinates) {
                const nModes = data.frequencies.length;
                const nAtoms = data.coordinates.length;
                const vibMemory = (nModes * nAtoms * 3 * 8) / (1024 * 1024); // displacement vectors
                memoryComponents.push('Vibrational Modes');
                memoryMB.push(vibMemory);
                colors.push('#e74c3c');
            }

            // Population analysis memory
            if (data.mulliken_charges && Object.keys(data.mulliken_charges).length > 0) {
                const nAtoms = Object.keys(data.mulliken_charges).length;
                const popMemory = (nAtoms * 10 * 8) / (1024 * 1024); // various population arrays
                memoryComponents.push('Population Analysis');
                memoryMB.push(popMemory);
                colors.push('#1abc9c');
            }

            if (memoryComponents.length === 0) {
                // Fallback: show estimated total
                memoryComponents.push('Estimated Total');
                memoryMB.push(100); // Default 100 MB
                colors.push('#95a5a6');
            }

            const totalMemory = memoryMB.reduce((sum, val) => sum + val, 0);

            const trace = {
                labels: memoryComponents,
                values: memoryMB,
                type: 'pie',
                marker: {
                    colors: colors,
                    line: {width: 2, color: 'white'}
                },
                hovertemplate: '%{label}<br>Memory: %{value:.2f} MB<br>Percentage: %{percent}<extra></extra>',
                textinfo: 'label+percent',
                textposition: 'inside'
            };

            const layout = {
                title: `Memory Usage Breakdown (Total: ${totalMemory.toFixed(2)} MB)`,
                showlegend: true,
                legend: {orientation: 'v', x: 1.05, y: 0.5}
            };

            Plotly.newPlot('memory-usage-plot', [trace], layout, {responsive: true});
        }

        function renderOrbitalGapsLandscape() {
            if (!data || !data.orbital_energies || data.orbital_energies.length < 2) return;

            const energies = data.orbital_energies;
            const gaps = [];
            const indices = [];

            // Calculate gaps between consecutive orbitals
            for (let i = 0; i < energies.length - 1; i++) {
                gaps.push((energies[i + 1] - energies[i]) * 27.211); // Convert to eV
                indices.push(i);
            }

            // Find HOMO-LUMO gap
            let homoIdx = -1;
            if (data.homo_idx !== null && data.homo_idx !== undefined) {
                homoIdx = data.homo_idx;
            }

            const trace = {
                x: indices,
                y: gaps,
                mode: 'lines+markers',
                type: 'scatter',
                marker: {
                    size: 6,
                    color: gaps,
                    colorscale: 'Viridis',
                    colorbar: {title: 'Gap (eV)'},
                    line: {width: 1, color: 'white'}
                },
                line: {color: '#667eea', width: 1},
                hovertemplate: 'Orbitals %{x}‚Üí%{x+1}<br>Gap: %{y:.3f} eV<extra></extra>'
            };

            const layout = {
                title: 'Orbital Energy Gap Landscape',
                xaxis: {title: 'Orbital Index'},
                yaxis: {title: 'Energy Gap (eV)'},
                showlegend: false
            };

            // Highlight HOMO-LUMO gap if available
            if (homoIdx >= 0 && homoIdx < gaps.length) {
                layout.shapes = [{
                    type: 'line',
                    x0: homoIdx,
                    y0: 0,
                    x1: homoIdx,
                    y1: Math.max(...gaps),
                    line: {color: 'red', width: 2, dash: 'dash'}
                }];
                layout.annotations = [{
                    x: homoIdx,
                    y: gaps[homoIdx],
                    text: `HOMO-LUMO<br>${gaps[homoIdx].toFixed(3)} eV`,
                    showarrow: true,
                    arrowhead: 2,
                    ax: 40,
                    ay: -40,
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: 'red',
                    borderwidth: 2
                }];
            }

            Plotly.newPlot('orbital-gaps-plot', [trace], layout, {responsive: true});
        }

        function renderModeClassification() {
            if (!data || !data.frequencies || data.frequencies.length === 0) return;

            // Classify modes
            const bending = data.frequencies.filter(f => f < 800);
            const stretching = data.frequencies.filter(f => f >= 800 && f < 1800);
            const highFreq = data.frequencies.filter(f => f >= 1800);

            const trace = {
                x: ['Bending\n(<800)', 'Stretching\n(800-1800)', 'High-Frequency\n(>1800)'],
                y: [bending.length, stretching.length, highFreq.length],
                type: 'bar',
                marker: {
                    color: ['#3498db', '#2ecc71', '#e74c3c'],
                    line: {width: 1, color: 'white'}
                },
                text: [
                    `${bending.length} modes`,
                    `${stretching.length} modes`,
                    `${highFreq.length} modes`
                ],
                textposition: 'outside',
                hovertemplate: '%{x}<br>Count: %{y} modes<extra></extra>'
            };

            const layout = {
                title: 'Vibrational Mode Classification',
                xaxis: {title: 'Mode Type'},
                yaxis: {title: 'Number of Modes'},
                showlegend: false
            };

            Plotly.newPlot('mode-classification-plot', [trace], layout, {responsive: true});
        }

        function renderNMRDistribution() {
            if (!data || !data.nmr_shifts || data.nmr_shifts.length === 0) return;

            // Group by nucleus type (assuming format like "1H", "13C")
            const nucleusGroups = {};
            data.nmr_shifts.forEach((shift, i) => {
                const nucleus = data.coordinates_au && data.coordinates_au[i] ? data.coordinates_au[i][0] : 'Unknown';
                if (!nucleusGroups[nucleus]) nucleusGroups[nucleus] = [];
                nucleusGroups[nucleus].push(shift);
            });

            const nuclei = Object.keys(nucleusGroups).sort();
            const traces = nuclei.map(nucleus => ({
                y: nucleusGroups[nucleus],
                type: 'box',
                name: nucleus,
                boxmean: 'sd',
                hovertemplate: nucleus + '<br>Shift: %{y:.2f} ppm<extra></extra>'
            }));

            const layout = {
                title: 'NMR Chemical Shift Distribution by Nucleus',
                xaxis: {title: 'Nucleus Type'},
                yaxis: {title: 'Chemical Shift (ppm)'},
                showlegend: true
            };

            Plotly.newPlot('nmr-distribution-plot', traces, layout, {responsive: true});
        }

        function renderBondStrengthDistribution() {
            if (!data || !data.mayer_bond_orders || data.mayer_bond_orders.length === 0) return;

            // Extract bond order values > 0.1
            const bondOrders = data.mayer_bond_orders.filter(b => b[2] > 0.1).map(b => b[2]);

            if (bondOrders.length === 0) return;

            const trace = {
                x: bondOrders,
                type: 'histogram',
                nbinsx: 30,
                marker: {
                    color: '#667eea',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: 'Bond Order: %{x:.2f}<br>Count: %{y}<extra></extra>'
            };

            const layout = {
                title: 'Bond Strength Distribution (Mayer Bond Orders)',
                xaxis: {title: 'Bond Order'},
                yaxis: {title: 'Frequency'},
                showlegend: false,
                shapes: [
                    {type: 'line', x0: 1, y0: 0, x1: 1, y1: 1, yref: 'paper', line: {color: 'red', dash: 'dash'}, opacity: 0.5},
                    {type: 'line', x0: 2, y0: 0, x1: 2, y1: 1, yref: 'paper', line: {color: 'green', dash: 'dash'}, opacity: 0.5},
                    {type: 'line', x0: 3, y0: 0, x1: 3, y1: 1, yref: 'paper', line: {color: 'blue', dash: 'dash'}, opacity: 0.5}
                ],
                annotations: [
                    {x: 1, y: 1, yref: 'paper', text: 'Single', showarrow: false, yshift: 10},
                    {x: 2, y: 1, yref: 'paper', text: 'Double', showarrow: false, yshift: 10},
                    {x: 3, y: 1, yref: 'paper', text: 'Triple', showarrow: false, yshift: 10}
                ]
            };

            Plotly.newPlot('bond-strength-plot', [trace], layout, {responsive: true});
        }

        function renderTimingEfficiency() {
            if (!data || !data.timing_data || data.timing_data.length === 0) return;

            // Sort by time (descending)
            const sorted = [...data.timing_data].sort((a, b) => b[1] - a[1]);
            const modules = sorted.map(t => t[0]);
            const times = sorted.map(t => t[1]);

            const trace = {
                x: times,
                y: modules,
                type: 'bar',
                orientation: 'h',
                marker: {
                    color: times,
                    colorscale: 'Viridis',
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: '%{y}<br>Time: %{x:.2f} s<extra></extra>'
            };

            const layout = {
                title: 'Computational Time by Module (Sorted)',
                xaxis: {title: 'Time (seconds)'},
                yaxis: {title: 'Module'},
                showlegend: false,
                margin: {l: 150}
            };

            Plotly.newPlot('timing-efficiency-plot', [trace], layout, {responsive: true});
        }

        function renderPropertiesSummary() {
            if (!data) return;

            const summaryDiv = document.getElementById('summary-content');
            if (!summaryDiv) return;

            const cards = [];

            // Helper to create card HTML
            const createCard = (title, value, unit = '') => `
                <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <div style="font-size: 12px; color: #888; margin-bottom: 5px;">${title}</div>
                    <div style="font-size: 24px; font-weight: bold; color: #667eea;">${value}${unit}</div>
                </div>
            `;

            // Molecular formula
            if (data.coordinates_au) {
                const elementCounts = {};
                data.coordinates_au.forEach(c => {
                    elementCounts[c[0]] = (elementCounts[c[0]] || 0) + 1;
                });
                const formula = Object.entries(elementCounts)
                    .sort()
                    .map(([el, count]) => `${el}${count > 1 ? count : ''}`)
                    .join('');
                cards.push(createCard('Molecular Formula', formula));
            }

            // Total atoms
            if (data.coordinates_au) {
                cards.push(createCard('Total Atoms', data.coordinates_au.length));
            }

            // Final energy
            if (data.final_energy !== null) {
                cards.push(createCard('Final Energy', data.final_energy.toFixed(6), ' Eh'));
            }

            // HOMO-LUMO gap
            if (data.homo_energy !== null && data.lumo_energy !== null) {
                const gap = ((data.lumo_energy - data.homo_energy) * 27.211).toFixed(3);
                cards.push(createCard('HOMO-LUMO Gap', gap, ' eV'));
            }

            // Total dipole
            if (data.dipole_moment_components && data.dipole_moment_components.length >= 3) {
                const comps = data.dipole_moment_components.slice(0, 3);
                const magnitude = Math.sqrt(comps.reduce((sum, v) => sum + v*v, 0));
                cards.push(createCard('Dipole Moment', magnitude.toFixed(3), ' Debye'));
            }

            // SCF iterations
            if (data.scf_energies) {
                cards.push(createCard('SCF Iterations', data.scf_energies.length));
            }

            // Method
            if (data.method) {
                cards.push(createCard('Method', data.method));
            }

            // Basis set
            if (data.basis_set) {
                cards.push(createCard('Basis Set', data.basis_set));
            }

            // Number of frequencies
            if (data.frequencies) {
                cards.push(createCard('Vibrational Modes', data.frequencies.length));
            }

            // Runtime
            if (data.total_run_time && data.total_run_time.total_seconds) {
                const hours = Math.floor(data.total_run_time.total_seconds / 3600);
                const mins = Math.floor((data.total_run_time.total_seconds % 3600) / 60);
                const secs = Math.floor(data.total_run_time.total_seconds % 60);
                const timeStr = hours > 0 ? `${hours}h ${mins}m ${secs}s` :
                               mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
                cards.push(createCard('Total Runtime', timeStr));
            }

            summaryDiv.innerHTML = cards.join('');
        }

        // ============ PHASE 5: ADVANCED MULTI-DIMENSIONAL VISUALIZATIONS ============

        function renderMOComposition() {
            if (!data || !data.mulliken_orbital_populations || data.mulliken_orbital_populations.length === 0) return;

            const moData = data.mulliken_orbital_populations;
            const numAtoms = moData[0]?.populations?.length || 0;
            if (numAtoms === 0) return;

            // Sample MOs for performance (show every 5th MO)
            const sampledMOs = moData.filter((_, i) => i % 5 === 0).slice(0, 50);
            const moIndices = sampledMOs.map(mo => mo.mo_index);

            // Create traces for each atom
            const traces = [];
            for (let atomIdx = 0; atomIdx < Math.min(numAtoms, 10); atomIdx++) {
                const atomContributions = sampledMOs.map(mo => {
                    const pops = mo.populations[atomIdx];
                    return pops ? pops.s + pops.p + pops.d + pops.f : 0;
                });

                traces.push({
                    x: moIndices,
                    y: atomContributions,
                    name: `Atom ${atomIdx + 1}`,
                    type: 'scatter',
                    mode: 'lines',
                    stackgroup: 'one',
                    hovertemplate: `Atom ${atomIdx + 1}<br>MO: %{x}<br>Contribution: %{y:.3f}<extra></extra>`
                });
            }

            const layout = {
                title: 'MO Composition by Atom (Stacked)',
                xaxis: {title: 'Molecular Orbital Index'},
                yaxis: {title: 'Total Population'},
                showlegend: true,
                hovermode: 'x unified'
            };

            Plotly.newPlot('mo-composition-plot', traces, layout, {responsive: true});
        }

        function renderEnergyDiagram() {
            if (!data || !data.orbital_energies || data.orbital_energies.length === 0) return;

            const energies = data.orbital_energies.map(e => e * 27.211); // Convert to eV
            const homoIdx = data.homo_idx || Math.floor(energies.length / 2);

            // Occupied orbitals (left side)
            const occupiedTrace = {
                x: Array(homoIdx + 1).fill(0),
                y: energies.slice(0, homoIdx + 1),
                mode: 'markers',
                marker: {
                    size: 12,
                    color: '#2ecc71',
                    symbol: 'line-ew',
                    line: {width: 3}
                },
                name: 'Occupied',
                hovertemplate: 'MO %{pointIndex}<br>Energy: %{y:.3f} eV<extra></extra>'
            };

            // Virtual orbitals (right side)
            const virtualTrace = {
                x: Array(energies.length - homoIdx - 1).fill(1),
                y: energies.slice(homoIdx + 1),
                mode: 'markers',
                marker: {
                    size: 12,
                    color: '#e74c3c',
                    symbol: 'line-ew',
                    line: {width: 3}
                },
                name: 'Virtual',
                hovertemplate: 'MO %{pointIndex}<br>Energy: %{y:.3f} eV<extra></extra>'
            };

            // HOMO-LUMO arrow
            const arrowTrace = {
                x: [0.2, 0.8],
                y: [energies[homoIdx], energies[homoIdx + 1]],
                mode: 'lines+markers',
                line: {color: '#667eea', width: 3, dash: 'dash'},
                marker: {size: 10, symbol: 'arrow-bar-up'},
                name: 'HOMO‚ÜíLUMO',
                showlegend: true
            };

            const layout = {
                title: `Energy Level Diagram (Gap: ${(energies[homoIdx + 1] - energies[homoIdx]).toFixed(3)} eV)`,
                xaxis: {title: '', showticklabels: false, range: [-0.5, 1.5]},
                yaxis: {title: 'Energy (eV)'},
                showlegend: true,
                annotations: [
                    {x: 0, y: energies[homoIdx], text: 'HOMO', showarrow: true, arrowhead: 2, ax: -40},
                    {x: 1, y: energies[homoIdx + 1], text: 'LUMO', showarrow: true, arrowhead: 2, ax: 40}
                ]
            };

            Plotly.newPlot('energy-diagram-plot', [occupiedTrace, virtualTrace, arrowTrace], layout, {responsive: true});
        }

        function renderCorrelationMatrix() {
            if (!data) return;

            // Build property vectors
            const properties = {};

            if (data.mulliken_charges && data.mulliken_charges.length > 0) {
                properties['Mulliken Charge'] = data.mulliken_charges.slice(0, 20);
            }
            if (data.loewdin_charges && data.loewdin_charges.length > 0) {
                properties['L√∂wdin Charge'] = data.loewdin_charges.slice(0, 20);
            }
            if (data.mayer_bond_orders && data.mayer_bond_orders.length > 0) {
                properties['Bond Orders'] = data.mayer_bond_orders.slice(0, 20).map(b => b[2]);
            }
            if (data.nmr_shifts && data.nmr_shifts.length > 0) {
                properties['NMR Shifts'] = data.nmr_shifts.slice(0, 20);
            }

            const propNames = Object.keys(properties);
            if (propNames.length < 2) return;

            // Calculate correlation matrix
            const correlationMatrix = [];
            for (let i = 0; i < propNames.length; i++) {
                const row = [];
                for (let j = 0; j < propNames.length; j++) {
                    row.push(calculateCorrelation(properties[propNames[i]], properties[propNames[j]]));
                }
                correlationMatrix.push(row);
            }

            const trace = {
                z: correlationMatrix,
                x: propNames,
                y: propNames,
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0,
                colorbar: {title: 'Correlation'},
                hovertemplate: '%{y} vs %{x}<br>Correlation: %{z:.3f}<extra></extra>'
            };

            const layout = {
                title: 'Property Correlation Matrix',
                xaxis: {title: '', tickangle: -45},
                yaxis: {title: ''},
                margin: {l: 150, b: 150}
            };

            Plotly.newPlot('correlation-matrix-plot', [trace], layout, {responsive: true});
        }

        function calculateCorrelation(arr1, arr2) {
            const n = Math.min(arr1.length, arr2.length);
            if (n === 0) return 0;

            const mean1 = arr1.reduce((a, b) => a + b, 0) / n;
            const mean2 = arr2.reduce((a, b) => a + b, 0) / n;

            let numerator = 0, denom1 = 0, denom2 = 0;
            for (let i = 0; i < n; i++) {
                const diff1 = arr1[i] - mean1;
                const diff2 = arr2[i] - mean2;
                numerator += diff1 * diff2;
                denom1 += diff1 * diff1;
                denom2 += diff2 * diff2;
            }

            return denom1 === 0 || denom2 === 0 ? 0 : numerator / Math.sqrt(denom1 * denom2);
        }

        function renderRadialDistribution() {
            if (!data || !data.coordinates_au || data.coordinates_au.length < 2) return;

            const coords = data.coordinates_au;
            const distances = [];

            // Calculate all pairwise distances
            for (let i = 0; i < coords.length; i++) {
                for (let j = i + 1; j < coords.length; j++) {
                    const dx = coords[i][1] - coords[j][1];
                    const dy = coords[i][2] - coords[j][2];
                    const dz = coords[i][3] - coords[j][3];
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) * 0.529177; // to Angstroms
                    distances.push(dist);
                }
            }

            const trace = {
                x: distances,
                type: 'histogram',
                nbinsx: 50,
                histnorm: 'probability density',
                marker: {
                    color: '#667eea',
                    line: {width: 1, color: 'white'}
                },
                name: 'g(r)',
                hovertemplate: 'Distance: %{x:.2f} √Ö<br>Density: %{y:.4f}<extra></extra>'
            };

            const layout = {
                title: 'Radial Distribution Function g(r)',
                xaxis: {title: 'Distance r (√Ö)'},
                yaxis: {title: 'g(r)'},
                showlegend: false
            };

            Plotly.newPlot('rdf-plot', [trace], layout, {responsive: true});
        }

        function renderOptimizationPath3D() {
            if (!data || !data.opt_energies || data.opt_energies.length < 2) return;

            const energies = data.opt_energies;
            const steps = Array.from({length: energies.length}, (_, i) => i + 1);

            // Mock gradient data (use actual if available)
            const gradients = data.opt_gradients || energies.map(() => Math.random() * 0.01);

            const trace = {
                x: steps,
                y: energies,
                z: gradients.slice(0, energies.length),
                mode: 'lines+markers',
                type: 'scatter3d',
                marker: {
                    size: 6,
                    color: steps,
                    colorscale: 'Viridis',
                    colorbar: {title: 'Step'},
                    line: {width: 1, color: 'white'}
                },
                line: {color: '#667eea', width: 3},
                hovertemplate: 'Step: %{x}<br>Energy: %{y:.6f} Eh<br>Gradient: %{z:.4e}<extra></extra>'
            };

            const layout = {
                title: 'Optimization Trajectory in 3D Space',
                scene: {
                    xaxis: {title: 'Optimization Step'},
                    yaxis: {title: 'Energy (Eh)'},
                    zaxis: {title: 'Gradient Norm'}
                }
            };

            Plotly.newPlot('opt-path-plot', [trace], layout, {responsive: true});
        }

        function renderOverlapMatrix() {
            if (!data || !data.mulliken_overlap_charges || data.mulliken_overlap_charges.length === 0) return;

            const overlapData = data.mulliken_overlap_charges;
            const numAtoms = Math.max(...overlapData.map(o => Math.max(o[0], o[1]))) + 1;

            // Build symmetric matrix
            const matrix = Array(numAtoms).fill(0).map(() => Array(numAtoms).fill(0));
            overlapData.forEach(([i, j, val]) => {
                matrix[i][j] = val;
                matrix[j][i] = val;
            });

            const trace = {
                z: matrix,
                type: 'heatmap',
                colorscale: 'RdBu',
                zmid: 0,
                colorbar: {title: 'Overlap'},
                hovertemplate: 'Atom %{y} ‚Üî Atom %{x}<br>Overlap: %{z:.4f}<extra></extra>'
            };

            const layout = {
                title: 'Orbital Overlap Charge Matrix',
                xaxis: {title: 'Atom Index'},
                yaxis: {title: 'Atom Index', autorange: 'reversed'}
            };

            Plotly.newPlot('overlap-matrix-plot', [trace], layout, {responsive: true});
        }

        function renderChargeFlow() {
            if (!data || !data.mulliken_charges || data.mulliken_charges.length < 2) return;

            // Create Sankey data based on charges
            const charges = data.mulliken_charges.slice(0, 10); // Limit to first 10 atoms
            const sources = [], targets = [], values = [], labels = [];

            // Create nodes
            charges.forEach((_, i) => {
                labels.push(`Atom ${i + 1}`);
            });

            // Create flows (simplified: positive to negative)
            for (let i = 0; i < charges.length; i++) {
                if (charges[i] < 0) { // Electron-rich
                    for (let j = 0; j < charges.length; j++) {
                        if (i !== j && charges[j] > 0) { // Electron-poor
                            sources.push(i);
                            targets.push(j);
                            values.push(Math.abs(charges[i]) * Math.abs(charges[j]) * 10);
                        }
                    }
                }
            }

            if (sources.length === 0) return;

            const trace = {
                type: 'sankey',
                node: {
                    pad: 15,
                    thickness: 20,
                    label: labels,
                    color: charges.map(c => c > 0 ? '#e74c3c' : '#2ecc71')
                },
                link: {
                    source: sources,
                    target: targets,
                    value: values,
                    color: 'rgba(102, 126, 234, 0.4)'
                }
            };

            const layout = {
                title: 'Charge Flow Network (Mulliken)',
                font: {size: 12}
            };

            Plotly.newPlot('charge-flow-plot', [trace], layout, {responsive: true});
        }

        function renderFrequency3D() {
            if (!data || !data.frequencies || data.frequencies.length === 0) return;
            if (!data.ir_spectrum || !data.raman_spectrum) return;

            const freq = data.frequencies;
            const irIntensities = data.ir_spectrum.map(s => s[1]);
            const ramanActivities = data.raman_spectrum.map(s => s[1]);

            const minLen = Math.min(freq.length, irIntensities.length, ramanActivities.length);

            const trace = {
                x: freq.slice(0, minLen),
                y: irIntensities.slice(0, minLen),
                z: ramanActivities.slice(0, minLen),
                mode: 'markers',
                type: 'scatter3d',
                marker: {
                    size: 5,
                    color: freq.slice(0, minLen),
                    colorscale: 'Jet',
                    colorbar: {title: 'Frequency (cm‚Åª¬π)'},
                    line: {width: 0.5, color: 'white'}
                },
                hovertemplate: 'Freq: %{x:.1f} cm‚Åª¬π<br>IR: %{y:.2f}<br>Raman: %{z:.2f}<extra></extra>'
            };

            const layout = {
                title: 'Frequency-IR-Raman 3D Correlation',
                scene: {
                    xaxis: {title: 'Frequency (cm‚Åª¬π)'},
                    yaxis: {title: 'IR Intensity'},
                    zaxis: {title: 'Raman Activity'}
                }
            };

            Plotly.newPlot('freq-3d-plot', [trace], layout, {responsive: true});
        }

        function renderBasisDistribution() {
            if (!data || !data.mulliken_orbital_populations || data.mulliken_orbital_populations.length === 0) return;

            const moData = data.mulliken_orbital_populations;

            // Aggregate basis function types
            const basisCounts = {s: 0, p: 0, d: 0, f: 0};

            moData.forEach(mo => {
                mo.populations.forEach(pop => {
                    basisCounts.s += pop.s || 0;
                    basisCounts.p += pop.p || 0;
                    basisCounts.d += pop.d || 0;
                    basisCounts.f += pop.f || 0;
                });
            });

            const trace = {
                labels: ['s orbitals', 'p orbitals', 'd orbitals', 'f orbitals'],
                values: [basisCounts.s, basisCounts.p, basisCounts.d, basisCounts.f],
                type: 'pie',
                marker: {
                    colors: ['#3498db', '#2ecc71', '#f39c12', '#e74c3c'],
                    line: {width: 2, color: 'white'}
                },
                hovertemplate: '%{label}<br>Total: %{value:.1f}<br>Percentage: %{percent}<extra></extra>',
                textinfo: 'label+percent'
            };

            const layout = {
                title: 'Basis Function Distribution (by Angular Momentum)',
                showlegend: true
            };

            Plotly.newPlot('basis-dist-plot', [trace], layout, {responsive: true});
        }

        // ============ PHASE 4: ADVANCED FEATURES ============

        // 4.1 Multi-file Comparison
        function renderComparison() {
            if (allFiles.length < 2) {
                alert('Please upload at least 2 files to compare');
                return;
            }

            const idx1 = parseInt(document.getElementById('compareFile1').value);
            const idx2 = parseInt(document.getElementById('compareFile2').value);

            if (idx1 === idx2) {
                alert('Please select two different files to compare');
                return;
            }

            const file1 = allFiles[idx1].data;
            const file2 = allFiles[idx2].data;

            // Energy comparison
            renderEnergyComparison(file1, file2, idx1, idx2);

            // SCF overlay
            renderSCFOverlay(file1, file2, idx1, idx2);

            // Charge difference
            renderChargeDifference(file1, file2, idx1, idx2);

            // Properties table
            renderPropertiesTable(file1, file2, idx1, idx2);
        }

        function renderEnergyComparison(file1, file2, idx1, idx2) {
            const categories = ['Final Energy', 'HOMO', 'LUMO', 'HOMO-LUMO Gap'];
            const values1 = [
                file1.final_energy || 0,
                file1.homo_energy || 0,
                file1.lumo_energy || 0,
                file1.lumo_energy && file1.homo_energy ? (file1.lumo_energy - file1.homo_energy) * 27.211 : 0
            ];
            const values2 = [
                file2.final_energy || 0,
                file2.homo_energy || 0,
                file2.lumo_energy || 0,
                file2.lumo_energy && file2.homo_energy ? (file2.lumo_energy - file2.homo_energy) * 27.211 : 0
            ];

            const trace1 = {
                x: categories.slice(0, -1),
                y: values1.slice(0, -1),
                name: allFiles[idx1].name,
                type: 'bar',
                marker: {color: '#667eea'}
            };

            const trace2 = {
                x: categories.slice(0, -1),
                y: values2.slice(0, -1),
                name: allFiles[idx2].name,
                type: 'bar',
                marker: {color: '#f39c12'}
            };

            // Gap on second y-axis
            const trace3 = {
                x: ['HOMO-LUMO Gap'],
                y: [values1[3]],
                name: allFiles[idx1].name + ' Gap',
                type: 'bar',
                yaxis: 'y2',
                marker: {color: '#667eea', opacity: 0.6}
            };

            const trace4 = {
                x: ['HOMO-LUMO Gap'],
                y: [values2[3]],
                name: allFiles[idx2].name + ' Gap',
                type: 'bar',
                yaxis: 'y2',
                marker: {color: '#f39c12', opacity: 0.6}
            };

            const layout = {
                title: 'Energy Comparison',
                xaxis: {title: 'Property'},
                yaxis: {title: 'Energy (Eh)', side: 'left'},
                yaxis2: {title: 'Gap (eV)', side: 'right', overlaying: 'y'},
                barmode: 'group',
                showlegend: true
            };

            Plotly.newPlot('comparison-energy-plot', [trace1, trace2, trace3, trace4], layout, {responsive: true});
        }

        function renderSCFOverlay(file1, file2, idx1, idx2) {
            if (!file1.scf_energies || !file2.scf_energies) return;

            const trace1 = {
                x: Array.from({length: file1.scf_energies.length}, (_, i) => i + 1),
                y: file1.scf_energies,
                mode: 'lines+markers',
                name: allFiles[idx1].name,
                line: {color: '#667eea', width: 2},
                marker: {size: 4}
            };

            const trace2 = {
                x: Array.from({length: file2.scf_energies.length}, (_, i) => i + 1),
                y: file2.scf_energies,
                mode: 'lines+markers',
                name: allFiles[idx2].name,
                line: {color: '#f39c12', width: 2},
                marker: {size: 4}
            };

            const layout = {
                title: 'SCF Convergence Overlay',
                xaxis: {title: 'Iteration'},
                yaxis: {title: 'Energy (Eh)'},
                showlegend: true
            };

            Plotly.newPlot('comparison-scf-plot', [trace1, trace2], layout, {responsive: true});
        }

        function renderChargeDifference(file1, file2, idx1, idx2) {
            if (!file1.mulliken_charges || !file2.mulliken_charges) return;

            const minLen = Math.min(file1.mulliken_charges.length, file2.mulliken_charges.length);
            const differences = [];
            const labels = [];

            for (let i = 0; i < minLen; i++) {
                differences.push(file2.mulliken_charges[i] - file1.mulliken_charges[i]);
                labels.push(`Atom ${i+1}`);
            }

            const trace = {
                x: labels,
                y: differences,
                type: 'bar',
                marker: {
                    color: differences.map(d => d > 0 ? '#e74c3c' : '#2ecc71'),
                    line: {width: 1, color: 'white'}
                },
                hovertemplate: '%{x}<br>Œî Charge: %{y:.4f}<extra></extra>'
            };

            const layout = {
                title: `Charge Difference (${allFiles[idx2].name} - ${allFiles[idx1].name})`,
                xaxis: {title: 'Atom', tickangle: -45},
                yaxis: {title: 'Charge Difference', zeroline: true},
                showlegend: false,
                margin: {b: 100}
            };

            Plotly.newPlot('comparison-charge-plot', [trace], layout, {responsive: true});
        }

        function renderPropertiesTable(file1, file2, idx1, idx2) {
            const properties = [
                {name: 'Method', key: 'method'},
                {name: 'Basis Set', key: 'basis_set'},
                {name: 'Final Energy (Eh)', key: 'final_energy', format: v => v?.toFixed(6)},
                {name: 'HOMO (Eh)', key: 'homo_energy', format: v => v?.toFixed(6)},
                {name: 'LUMO (Eh)', key: 'lumo_energy', format: v => v?.toFixed(6)},
                {name: 'HOMO-LUMO Gap (eV)', calc: d => d.lumo_energy && d.homo_energy ? ((d.lumo_energy - d.homo_energy) * 27.211).toFixed(3) : 'N/A'},
                {name: 'SCF Iterations', key: 'scf_energies', format: v => v?.length || 'N/A'},
                {name: 'Total Atoms', key: 'coordinates_au', format: v => v?.length || 'N/A'},
                {name: 'Vibrational Modes', key: 'frequencies', format: v => v?.length || 'N/A'},
                {name: 'Runtime (s)', key: 'total_run_time', format: v => v?.total_seconds?.toFixed(2) || 'N/A'}
            ];

            let html = '<table style="width: 100%; border-collapse: collapse; margin-top: 10px;">';
            html += '<thead><tr style="background: #667eea; color: white;">';
            html += '<th style="padding: 10px; text-align: left;">Property</th>';
            html += `<th style="padding: 10px; text-align: left;">${allFiles[idx1].name}</th>`;
            html += `<th style="padding: 10px; text-align: left;">${allFiles[idx2].name}</th>`;
            html += '<th style="padding: 10px; text-align: left;">Difference</th>';
            html += '</tr></thead><tbody>';

            properties.forEach((prop, i) => {
                const val1 = prop.calc ? prop.calc(file1) : (prop.format ? prop.format(file1[prop.key]) : file1[prop.key] || 'N/A');
                const val2 = prop.calc ? prop.calc(file2) : (prop.format ? prop.format(file2[prop.key]) : file2[prop.key] || 'N/A');

                let diff = 'N/A';
                if (prop.key && typeof file1[prop.key] === 'number' && typeof file2[prop.key] === 'number') {
                    diff = (file2[prop.key] - file1[prop.key]).toFixed(6);
                }

                html += `<tr style="background: ${i % 2 === 0 ? '#f8f9fa' : 'white'};">`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${prop.name}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${val1}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${val2}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ddd;">${diff}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';
            document.getElementById('comparison-table').innerHTML = html;
        }

        // RMSD Calculation and Structure Overlay
        function renderRMSDOverlay() {
            if (allFiles.length < 2) {
                alert('Please upload at least 2 files to compare structures');
                return;
            }

            const idx1 = parseInt(document.getElementById('compareFile1').value);
            const idx2 = parseInt(document.getElementById('compareFile2').value);

            if (idx1 === idx2) {
                alert('Please select two different files');
                return;
            }

            const file1 = allFiles[idx1].data;
            const file2 = allFiles[idx2].data;

            if (!file1.coordinates || !file2.coordinates) {
                alert('Coordinate data not available');
                return;
            }

            // Calculate RMSD
            const coords1 = file1.coordinates;
            const coords2 = file2.coordinates;
            const minLen = Math.min(coords1.length, coords2.length);

            let sumSq = 0;
            for (let i = 0; i < minLen; i++) {
                const dx = coords1[i][1] - coords2[i][1];
                const dy = coords1[i][2] - coords2[i][2];
                const dz = coords1[i][3] - coords2[i][3];
                sumSq += dx*dx + dy*dy + dz*dz;
            }
            const rmsd = Math.sqrt(sumSq / minLen);

            document.getElementById('rmsd-value').textContent = `${rmsd.toFixed(4)} √Ö`;

            // 3D Structure Overlay
            const trace1 = {
                x: coords1.map(c => c[1]),
                y: coords1.map(c => c[2]),
                z: coords1.map(c => c[3]),
                mode: 'markers+text',
                type: 'scatter3d',
                name: allFiles[idx1].name,
                marker: {size: 8, color: '#667eea', opacity: 0.8},
                text: coords1.map(c => c[0]),
                textposition: 'top center',
                hovertemplate: 'Atom: %{text}<br>X: %{x:.3f}<br>Y: %{y:.3f}<br>Z: %{z:.3f}<extra></extra>'
            };

            const trace2 = {
                x: coords2.map(c => c[1]),
                y: coords2.map(c => c[2]),
                z: coords2.map(c => c[3]),
                mode: 'markers+text',
                type: 'scatter3d',
                name: allFiles[idx2].name,
                marker: {size: 8, color: '#f39c12', opacity: 0.8},
                text: coords2.map(c => c[0]),
                textposition: 'bottom center',
                hovertemplate: 'Atom: %{text}<br>X: %{x:.3f}<br>Y: %{y:.3f}<br>Z: %{z:.3f}<extra></extra>'
            };

            const layout = {
                title: `3D Structure Overlay (RMSD: ${rmsd.toFixed(4)} √Ö)`,
                scene: {
                    xaxis: {title: 'X (√Ö)'},
                    yaxis: {title: 'Y (√Ö)'},
                    zaxis: {title: 'Z (√Ö)'},
                    camera: {eye: {x: 1.5, y: 1.5, z: 1.5}}
                },
                showlegend: true
            };

            Plotly.newPlot('structure-overlay-plot', [trace1, trace2], layout, {responsive: true});
        }

        // Side-by-Side Energy Level Diagrams
        function renderEnergyDiagramsSideBySide() {
            if (allFiles.length < 2) {
                alert('Please upload at least 2 files');
                return;
            }

            const idx1 = parseInt(document.getElementById('compareFile1').value);
            const idx2 = parseInt(document.getElementById('compareFile2').value);
            const file1 = allFiles[idx1].data;
            const file2 = allFiles[idx2].data;

            if (!file1.orbital_energies || !file2.orbital_energies) {
                alert('Orbital energy data not available');
                return;
            }

            const energies1 = file1.orbital_energies.map(e => e * 27.211);
            const energies2 = file2.orbital_energies.map(e => e * 27.211);
            const homoIdx1 = file1.homo_idx || Math.floor(energies1.length / 2);
            const homoIdx2 = file2.homo_idx || Math.floor(energies2.length / 2);

            // File 1 - Occupied
            const occ1 = {
                x: Array(homoIdx1 + 1).fill(0),
                y: energies1.slice(0, homoIdx1 + 1),
                mode: 'markers',
                marker: {size: 12, color: '#667eea', symbol: 'line-ew', line: {width: 3}},
                name: `${allFiles[idx1].name} (Occupied)`,
                hovertemplate: 'MO %{pointIndex}<br>Energy: %{y:.3f} eV<extra></extra>'
            };

            // File 1 - Virtual
            const virt1 = {
                x: Array(energies1.length - homoIdx1 - 1).fill(0.5),
                y: energies1.slice(homoIdx1 + 1),
                mode: 'markers',
                marker: {size: 12, color: '#667eea', symbol: 'line-ew', line: {width: 3}, opacity: 0.6},
                name: `${allFiles[idx1].name} (Virtual)`,
                hovertemplate: 'MO %{pointIndex}<br>Energy: %{y:.3f} eV<extra></extra>'
            };

            // File 2 - Occupied
            const occ2 = {
                x: Array(homoIdx2 + 1).fill(1.5),
                y: energies2.slice(0, homoIdx2 + 1),
                mode: 'markers',
                marker: {size: 12, color: '#f39c12', symbol: 'line-ew', line: {width: 3}},
                name: `${allFiles[idx2].name} (Occupied)`,
                hovertemplate: 'MO %{pointIndex}<br>Energy: %{y:.3f} eV<extra></extra>'
            };

            // File 2 - Virtual
            const virt2 = {
                x: Array(energies2.length - homoIdx2 - 1).fill(2),
                y: energies2.slice(homoIdx2 + 1),
                mode: 'markers',
                marker: {size: 12, color: '#f39c12', symbol: 'line-ew', line: {width: 3}, opacity: 0.6},
                name: `${allFiles[idx2].name} (Virtual)`,
                hovertemplate: 'MO %{pointIndex}<br>Energy: %{y:.3f} eV<extra></extra>'
            };

            const gap1 = (energies1[homoIdx1 + 1] - energies1[homoIdx1]).toFixed(3);
            const gap2 = (energies2[homoIdx2 + 1] - energies2[homoIdx2]).toFixed(3);

            const layout = {
                title: `Energy Level Diagrams (Gaps: ${gap1} eV vs ${gap2} eV)`,
                xaxis: {
                    title: '',
                    tickvals: [0.25, 1.75],
                    ticktext: [allFiles[idx1].name, allFiles[idx2].name],
                    range: [-0.5, 2.5]
                },
                yaxis: {title: 'Energy (eV)'},
                showlegend: true,
                annotations: [
                    {x: 0.25, y: energies1[homoIdx1], text: 'HOMO', showarrow: true, arrowhead: 2, ax: -40},
                    {x: 0.25, y: energies1[homoIdx1 + 1], text: 'LUMO', showarrow: true, arrowhead: 2, ax: -40},
                    {x: 1.75, y: energies2[homoIdx2], text: 'HOMO', showarrow: true, arrowhead: 2, ax: 40},
                    {x: 1.75, y: energies2[homoIdx2 + 1], text: 'LUMO', showarrow: true, arrowhead: 2, ax: 40}
                ]
            };

            Plotly.newPlot('energy-diagrams-plot', [occ1, virt1, occ2, virt2], layout, {responsive: true});
        }

        // Reaction Coordinate Visualization
        function renderReactionCoordinate() {
            if (allFiles.length < 2) {
                alert('Please upload multiple files representing reaction steps');
                return;
            }

            const energies = allFiles.map(f => f.data.final_energy || 0);
            const names = allFiles.map(f => f.name);

            // Convert to relative energies (kcal/mol)
            const minEnergy = Math.min(...energies);
            const relativeEnergies = energies.map(e => (e - minEnergy) * 627.509); // Convert Eh to kcal/mol

            const trace = {
                x: Array.from({length: energies.length}, (_, i) => i),
                y: relativeEnergies,
                mode: 'lines+markers',
                line: {color: '#667eea', width: 3, shape: 'spline'},
                marker: {size: 12, color: '#f39c12', line: {width: 2, color: '#667eea'}},
                text: names,
                hovertemplate: '%{text}<br>Relative Energy: %{y:.2f} kcal/mol<extra></extra>'
            };

            const layout = {
                title: 'Reaction Coordinate Diagram',
                xaxis: {
                    title: 'Reaction Progress',
                    tickvals: Array.from({length: energies.length}, (_, i) => i),
                    ticktext: names.map((n, i) => `Step ${i + 1}`)
                },
                yaxis: {title: 'Relative Energy (kcal/mol)'},
                showlegend: false,
                shapes: energies.map((_, i) => ({
                    type: 'line',
                    x0: i,
                    x1: i,
                    y0: 0,
                    y1: relativeEnergies[i],
                    line: {color: '#ddd', width: 1, dash: 'dot'}
                }))
            };

            Plotly.newPlot('reaction-coordinate-plot', [trace], layout, {responsive: true});
        }

        // Update renderComparison to include new visualizations
        const originalRenderComparison = renderComparison;
        renderComparison = function() {
            originalRenderComparison();
            renderRMSDOverlay();
            renderEnergyDiagramsSideBySide();
            renderReactionCoordinate();
        };

        // 4.2 Animation Export
        function exportAnimationGIF(plotId, filename) {
            alert('GIF export feature: Use Plotly\'s built-in animation controls and browser screen recording, or click "üì∑ PNG" to export current frame.');
        }

        // 4.3 PDF Report Generation
        async function generatePDFReport() {
            if (!data) {
                alert('Please load data first');
                return;
            }

            setStatus('Generating PDF report...', true);

            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                let yPos = 20;

                // Title
                pdf.setFontSize(20);
                pdf.text('ORCA Output Analysis Report', pageWidth / 2, yPos, {align: 'center'});
                yPos += 15;

                // Summary
                pdf.setFontSize(12);
                pdf.text('File Summary', 10, yPos);
                yPos += 7;
                pdf.setFontSize(10);

                const summary = [
                    `Method: ${data.method || 'N/A'}`,
                    `Basis Set: ${data.basis_set || 'N/A'}`,
                    `Final Energy: ${data.final_energy?.toFixed(6) || 'N/A'} Eh`,
                    `HOMO-LUMO Gap: ${data.homo_energy && data.lumo_energy ? ((data.lumo_energy - data.homo_energy) * 27.211).toFixed(3) : 'N/A'} eV`,
                    `Total Atoms: ${data.coordinates_au?.length || 'N/A'}`,
                    `SCF Iterations: ${data.scf_energies?.length || 'N/A'}`,
                    `Runtime: ${data.total_run_time?.total_seconds?.toFixed(2) || 'N/A'} seconds`
                ];

                summary.forEach(line => {
                    pdf.text(line, 10, yPos);
                    yPos += 6;
                });

                yPos += 10;
                pdf.text('Note: Full visualization export requires additional browser plugins.', 10, yPos);
                pdf.text('Use individual plot export buttons (üì∑ PNG) to save visualizations separately.', 10, yPos + 6);

                pdf.save('orca_report.pdf');
                setStatus('‚úì PDF report generated successfully', true);
            } catch (error) {
                setStatus(`‚úó PDF generation failed: ${error.message}`, false);
                console.error('PDF Error:', error);
            }
        }

        // 4.4 URL Sharing
        function shareViaURL() {
            if (!data) {
                alert('Please load data first');
                return;
            }

            try {
                // Create shareable state (simplified - only basic info)
                const shareData = {
                    method: data.method,
                    basis_set: data.basis_set,
                    final_energy: data.final_energy,
                    homo_energy: data.homo_energy,
                    lumo_energy: data.lumo_energy,
                    timestamp: new Date().toISOString()
                };

                // Encode as URL parameter
                const encoded = btoa(JSON.stringify(shareData));
                const shareURL = `${window.location.origin}${window.location.pathname}?share=${encoded}`;

                // Copy to clipboard
                navigator.clipboard.writeText(shareURL).then(() => {
                    alert('‚úì Shareable URL copied to clipboard!\\n\\nNote: This URL contains basic summary data only. To share full visualizations, use the PDF export or individual plot exports.');
                    setStatus('‚úì Shareable URL copied to clipboard', true);
                }).catch(err => {
                    prompt('Copy this URL to share:', shareURL);
                });
            } catch (error) {
                alert(`Error generating share URL: ${error.message}`);
            }
        }

        // ============ PHASE 6: ENHANCED FEATURES ============

        // Enhanced PDF Report Generation with Plot Capture
        async function generateEnhancedPDF() {
            if (!data) {
                alert('Please load data first');
                return;
            }

            setStatus('Generating enhanced PDF report with plots...', true);

            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                let yPos = 20;

                // Title Page
                pdf.setFontSize(24);
                pdf.text('ORCA Output', pageWidth / 2, yPos, {align: 'center'});
                yPos += 10;
                pdf.setFontSize(18);
                pdf.text('Analysis Report', pageWidth / 2, yPos, {align: 'center'});
                yPos += 20;

                // Report metadata
                pdf.setFontSize(10);
                pdf.text(`Generated: ${new Date().toLocaleString()}`, pageWidth / 2, yPos, {align: 'center'});
                yPos += 6;
                pdf.text(`File: ${allFiles[currentFileIndex]?.name || 'Unknown'}`, pageWidth / 2, yPos, {align: 'center'});
                yPos += 20;

                // Summary Section
                pdf.setFontSize(16);
                pdf.text('1. Calculation Summary', 10, yPos);
                yPos += 10;
                pdf.setFontSize(10);

                const summary = [
                    {label: 'Method', value: data.method || 'N/A'},
                    {label: 'Basis Set', value: data.basis_set || 'N/A'},
                    {label: 'Final Energy', value: data.final_energy ? `${data.final_energy.toFixed(6)} Eh` : 'N/A'},
                    {label: 'HOMO Energy', value: data.homo_energy ? `${data.homo_energy.toFixed(6)} Eh` : 'N/A'},
                    {label: 'LUMO Energy', value: data.lumo_energy ? `${data.lumo_energy.toFixed(6)} Eh` : 'N/A'},
                    {label: 'HOMO-LUMO Gap', value: data.homo_energy && data.lumo_energy ? `${((data.lumo_energy - data.homo_energy) * 27.211).toFixed(3)} eV` : 'N/A'},
                    {label: 'Total Atoms', value: data.coordinates?.length || 'N/A'},
                    {label: 'SCF Iterations', value: data.scf_energies?.length || 'N/A'},
                    {label: 'Vibrational Modes', value: data.frequencies?.length || 'N/A'},
                    {label: 'Total Runtime', value: data.total_run_time?.total_seconds ? `${data.total_run_time.total_seconds.toFixed(2)} s` : 'N/A'}
                ];

                summary.forEach(item => {
                    pdf.text(`${item.label}:`, 15, yPos);
                    pdf.text(item.value.toString(), 65, yPos);
                    yPos += 6;
                });

                // Geometry Section
                if (data.coordinates && data.coordinates.length > 0) {
                    pdf.addPage();
                    yPos = 20;
                    pdf.setFontSize(16);
                    pdf.text('2. Molecular Geometry', 10, yPos);
                    yPos += 10;
                    pdf.setFontSize(9);

                    // Geometry table (first 20 atoms)
                    const atoms = data.coordinates.slice(0, 20);
                    atoms.forEach((coord, i) => {
                        pdf.text(`${i}  ${coord[0]}  ${coord[1]?.toFixed(4)}  ${coord[2]?.toFixed(4)}  ${coord[3]?.toFixed(4)}`, 15, yPos);
                        yPos += 5;
                        if (yPos > pageHeight - 20) {
                            pdf.addPage();
                            yPos = 20;
                        }
                    });

                    if (data.coordinates.length > 20) {
                        pdf.text(`... and ${data.coordinates.length - 20} more atoms`, 15, yPos);
                    }
                }

                // Energy Analysis
                pdf.addPage();
                yPos = 20;
                pdf.setFontSize(16);
                pdf.text('3. Energy Analysis', 10, yPos);
                yPos += 10;
                pdf.setFontSize(10);

                if (data.thermochemistry) {
                    const thermo = [
                        {label: 'Gibbs Free Energy', value: data.thermochemistry.gibbs_free_energy?.toFixed(6) + ' Eh' || 'N/A'},
                        {label: 'Total Enthalpy', value: data.thermochemistry.total_enthalpy?.toFixed(6) + ' Eh' || 'N/A'},
                        {label: 'Zero Point Energy', value: data.thermochemistry.zero_point_energy?.toFixed(6) + ' Eh' || 'N/A'}
                    ];

                    thermo.forEach(item => {
                        pdf.text(`${item.label}: ${item.value}`, 15, yPos);
                        yPos += 6;
                    });
                }

                // Instructions for plot capture
                pdf.addPage();
                yPos = 20;
                pdf.setFontSize(16);
                pdf.text('4. Visualization Plots', 10, yPos);
                yPos += 10;
                pdf.setFontSize(10);
                pdf.text('To include interactive visualizations in your report:', 15, yPos);
                yPos += 7;
                pdf.text('1. Use the üì∑ PNG button on each plot to export individually', 20, yPos);
                yPos += 6;
                pdf.text('2. Save all required plots to a folder', 20, yPos);
                yPos += 6;
                pdf.text('3. Use a PDF editor to combine this report with plot images', 20, yPos);
                yPos += 6;
                pdf.text('4. Alternatively, use the browser Print to PDF feature (Ctrl+P) to capture', 20, yPos);
                yPos += 6;
                pdf.text('   the entire web page with all visualizations rendered', 20, yPos);

                pdf.save(`orca_enhanced_report_${new Date().getTime()}.pdf`);
                setStatus('‚úì Enhanced PDF report generated', true);
            } catch (error) {
                setStatus(`‚úó Enhanced PDF generation failed: ${error.message}`, false);
                console.error('PDF Error:', error);
            }
        }

        // LaTeX Export
        function exportToLaTeX() {
            if (!data) {
                alert('Please load data first');
                return;
            }

            let latex = `\\documentclass{article}
\\usepackage{booktabs}
\\usepackage{siunitx}
\\usepackage{graphicx}
\\title{ORCA Output Analysis Report}
\\author{Generated by ORCA Parser}
\\date{${new Date().toLocaleDateString()}}

\\begin{document}
\\maketitle

\\section{Calculation Summary}
\\begin{table}[h]
\\centering
\\begin{tabular}{ll}
\\toprule
Property & Value \\\\
\\midrule
Method & ${data.method || 'N/A'} \\\\
Basis Set & ${data.basis_set || 'N/A'} \\\\
Final Energy & ${data.final_energy?.toFixed(6) || 'N/A'} \\si{\\hartree} \\\\
HOMO Energy & ${data.homo_energy?.toFixed(6) || 'N/A'} \\si{\\hartree} \\\\
LUMO Energy & ${data.lumo_energy?.toFixed(6) || 'N/A'} \\si{\\hartree} \\\\
HOMO-LUMO Gap & ${data.homo_energy && data.lumo_energy ? ((data.lumo_energy - data.homo_energy) * 27.211).toFixed(3) : 'N/A'} \\si{\\electronvolt} \\\\
SCF Iterations & ${data.scf_energies?.length || 'N/A'} \\\\
Total Atoms & ${data.coordinates?.length || 'N/A'} \\\\
\\bottomrule
\\end{tabular}
\\caption{Summary of ORCA calculation}
\\end{table}

`;

            if (data.coordinates && data.coordinates.length > 0 && data.coordinates.length <= 50) {
                latex += `\\section{Molecular Geometry}
\\begin{table}[h]
\\centering
\\small
\\begin{tabular}{ccrrr}
\\toprule
Atom & Element & X (\\si{\\angstrom}) & Y (\\si{\\angstrom}) & Z (\\si{\\angstrom}) \\\\
\\midrule
`;
                data.coordinates.forEach((coord, i) => {
                    latex += `${i} & ${coord[0]} & ${coord[1]?.toFixed(4)} & ${coord[2]?.toFixed(4)} & ${coord[3]?.toFixed(4)} \\\\\n`;
                });

                latex += `\\bottomrule
\\end{tabular}
\\caption{Cartesian coordinates of the molecular structure}
\\end{table}

`;
            }

            latex += `\\section{Visualization Notes}
To include plots in this report:
\\begin{itemize}
\\item Export individual plots using the PNG export buttons in the web interface
\\item Save plots to your LaTeX project directory
\\item Use \\texttt{\\textbackslash includegraphics\\{plotname.png\\}} to embed them
\\item Example: \\texttt{\\textbackslash includegraphics[width=0.8\\textbackslash textwidth]\\{scf\\_plot.png\\}}
\\end{itemize}

\\end{document}`;

            const blob = new Blob([latex], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `orca_report_${new Date().getTime()}.tex`;
            a.click();
            URL.revokeObjectURL(url);

            setStatus('‚úì LaTeX file exported successfully', true);
        }

        // Full Dataset Sharing
        function shareFullDataset() {
            if (!data) {
                alert('Please load data first');
                return;
            }

            try {
                // Create full dataset package
                const fullData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    filename: allFiles[currentFileIndex]?.name || 'unknown',
                    data: data
                };

                // Convert to JSON
                const jsonString = JSON.stringify(fullData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                // Download
                const a = document.createElement('a');
                a.href = url;
                a.download = `orca_full_dataset_${new Date().getTime()}.json`;
                a.click();
                URL.revokeObjectURL(url);

                alert('‚úì Full dataset exported!\\n\\nThis file contains all parsed data and can be shared with colleagues.\\nRecipients can upload this JSON file to view all visualizations.');
                setStatus('‚úì Full dataset exported', true);
            } catch (error) {
                alert(`Error exporting dataset: ${error.message}`);
            }
        }

        // Jupyter Notebook Export
        function exportJupyterNotebook() {
            if (!data) {
                alert('Please load data first');
                return;
            }

            const notebook = {
                cells: [
                    {
                        cell_type: 'markdown',
                        metadata: {},
                        source: [
                            '# ORCA Output Analysis\\n',
                            `Generated: ${new Date().toLocaleString()}\\n`,
                            `\\nFile: ${allFiles[currentFileIndex]?.name || 'Unknown'}`
                        ]
                    },
                    {
                        cell_type: 'code',
                        execution_count: null,
                        metadata: {},
                        outputs: [],
                        source: [
                            'import json\\n',
                            'import plotly.graph_objects as go\\n',
                            'import plotly.express as px\\n',
                            'import pandas as pd\\n',
                            'import numpy as np'
                        ]
                    },
                    {
                        cell_type: 'markdown',
                        metadata: {},
                        source: ['## Load Data']
                    },
                    {
                        cell_type: 'code',
                        execution_count: null,
                        metadata: {},
                        outputs: [],
                        source: [
                            '# Paste the data dictionary below\\n',
                            `data = ${JSON.stringify(data, null, 2)}`
                        ]
                    },
                    {
                        cell_type: 'markdown',
                        metadata: {},
                        source: ['## Calculation Summary']
                    },
                    {
                        cell_type: 'code',
                        execution_count: null,
                        metadata: {},
                        outputs: [],
                        source: [
                            'summary = {\\n',
                            `    "Method": "${data.method || 'N/A'}",\\n`,
                            `    "Basis Set": "${data.basis_set || 'N/A'}",\\n`,
                            `    "Final Energy (Eh)": ${data.final_energy || 'None'},\\n`,
                            `    "HOMO-LUMO Gap (eV)": ${data.homo_energy && data.lumo_energy ? ((data.lumo_energy - data.homo_energy) * 27.211).toFixed(3) : 'None'},\\n`,
                            `    "SCF Iterations": ${data.scf_energies?.length || 'None'},\\n`,
                            `    "Total Atoms": ${data.coordinates?.length || 'None'}\\n`,
                            '}\\n',
                            'pd.DataFrame([summary]).T'
                        ]
                    },
                    {
                        cell_type: 'markdown',
                        metadata: {},
                        source: ['## SCF Convergence Plot']
                    },
                    {
                        cell_type: 'code',
                        execution_count: null,
                        metadata: {},
                        outputs: [],
                        source: [
                            'if data.get("scf_energies"):\\n',
                            '    fig = go.Figure()\\n',
                            '    fig.add_trace(go.Scatter(\\n',
                            '        x=list(range(1, len(data["scf_energies"]) + 1)),\\n',
                            '        y=data["scf_energies"],\\n',
                            '        mode="lines+markers",\\n',
                            '        name="SCF Energy"\\n',
                            '    ))\\n',
                            '    fig.update_layout(\\n',
                            '        title="SCF Convergence",\\n',
                            '        xaxis_title="Iteration",\\n',
                            '        yaxis_title="Energy (Eh)"\\n',
                            '    )\\n',
                            '    fig.show()'
                        ]
                    },
                    {
                        cell_type: 'markdown',
                        metadata: {},
                        source: [
                            '## Additional Analysis\\n',
                            '\\n',
                            'Add your own analysis cells below. The data dictionary contains all parsed ORCA output data.'
                        ]
                    }
                ],
                metadata: {
                    kernelspec: {
                        display_name: 'Python 3',
                        language: 'python',
                        name: 'python3'
                    },
                    language_info: {
                        name: 'python',
                        version: '3.8.0'
                    }
                },
                nbformat: 4,
                nbformat_minor: 4
            };

            const notebookStr = JSON.stringify(notebook, null, 2);
            const blob = new Blob([notebookStr], { type: 'application/x-ipynb+json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `orca_analysis_${new Date().getTime()}.ipynb`;
            a.click();
            URL.revokeObjectURL(url);

            alert('‚úì Jupyter Notebook exported!\\n\\nOpen this .ipynb file in Jupyter Lab or Google Colab.\\nAll data is embedded - install plotly, pandas, and numpy to run.');
            setStatus('‚úì Jupyter Notebook exported', true);
        }

        // Real-time Collaboration (WebSocket placeholder)
        function enableRealTimeCollaboration() {
            alert('üöÄ Real-time Collaboration\\n\\nThis feature enables multiple users to view and annotate the same analysis session in real-time.\\n\\nComing soon: WebSocket-based live updates, shared annotations, and collaborative filtering.\\n\\nFor now, use the "Share Dataset" feature to send full analysis data to colleagues.');
        }

        // Load shared data from URL on page load
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const shareData = urlParams.get('share');

            if (shareData) {
                try {
                    const decoded = JSON.parse(atob(shareData));
                    setStatus(`‚úì Loaded shared data (${decoded.method || 'Unknown'} calculation)`, true);

                    // Display basic info
                    const summaryContent = document.getElementById('summary-content');
                    summaryContent.innerHTML = `
                        <div style="padding: 20px; background: #f8f9fa; border-radius: 8px;">
                            <h3>Shared Calculation Summary</h3>
                            <p><strong>Method:</strong> ${decoded.method || 'N/A'}</p>
                            <p><strong>Basis Set:</strong> ${decoded.basis_set || 'N/A'}</p>
                            <p><strong>Final Energy:</strong> ${decoded.final_energy?.toFixed(6) || 'N/A'} Eh</p>
                            <p><strong>HOMO-LUMO Gap:</strong> ${decoded.homo_energy && decoded.lumo_energy ? ((decoded.lumo_energy - decoded.homo_energy) * 27.211).toFixed(3) : 'N/A'} eV</p>
                            <p><strong>Shared:</strong> ${new Date(decoded.timestamp).toLocaleString()}</p>
                            <p style="margin-top: 15px; color: #666; font-size: 12px;">
                                Note: This is a summary view. Upload the original .out file for full analysis and visualizations.
                            </p>
                        </div>
                    `;
                } catch (error) {
                    console.error('Failed to load shared data:', error);
                }
            }
        });
    </script>
</body>
</html>
